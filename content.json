{"meta":{"title":"Akashi_Sai","subtitle":null,"description":null,"author":"Akashi Sai","url":"http://akashigakki.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-30T01:36:47.000Z","updated":"2020-10-06T11:15:40.930Z","comments":true,"path":"about/index.html","permalink":"http://akashigakki.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-30T01:36:19.000Z","updated":"2020-10-06T11:15:40.937Z","comments":true,"path":"tags/index.html","permalink":"http://akashigakki.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-30T01:18:17.000Z","updated":"2020-10-06T11:15:40.930Z","comments":true,"path":"categories/index.html","permalink":"http://akashigakki.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CesiumJS 进阶","slug":"cesium-advanced/cesium-advanced","date":"2020-10-03T16:00:00.000Z","updated":"2020-10-06T11:19:10.186Z","comments":true,"path":"2020/10/04/cesium-advanced/cesium-advanced/","link":"","permalink":"http://akashigakki.github.io/2020/10/04/cesium-advanced/cesium-advanced/","excerpt":"CesiumJS 进阶 记录使用 Cesium 的实体（Entity）API绘制空间数据、使用 Viewer 为操作 entities 提供出来的功能函数、使用 Primitive API 的几何图形和外观系统、创建使用 ParticleSystem 粒子系统等。","text":"CesiumJS 进阶 记录使用 Cesium 的实体（Entity）API绘制空间数据、使用 Viewer 为操作 entities 提供出来的功能函数、使用 Primitive API 的几何图形和外观系统、创建使用 ParticleSystem 粒子系统等。 空间数据可视化（Entity） Cesium 具有丰富的用于空间数据的 API，可以分为两类：面向图形开发人员的低级API（通常称为原始(Primitive) API）和用于数据驱动的可视化的高级API（称为实体(Entity) API）。 Primitive API 原始API 的主要目标是暴露手头执行任务所需的最小抽象量。它希望我们像图形程序员一样思考，并使用图形术语。它的结构是为给定的可视化类型提供最有性能和灵活性的实现，而不是为了 API 的一致性。 原始API 功能强大且灵活，但大多数应用程序都提供比 Primitive API 的抽象级别更高的服务接口。Primitive API 更面向于底层图形开发。 Entity API 实体API 的目的是公开一组设计一致的高级对象，这些对象将相关的可视化和信息聚合到一个统一的数据结构中，我们称之为实体。它让我们专注于展示我们的数据，而不是担心可视化的潜在机制。它还提供了易于构建复杂的、时间动态可视化的构造，这种可视化方式与静态数据自然相适应。 虽然 实体API 实际上在背后使用了 Primitive API，但我们几乎永远不必关注实现细节。通过将各种启发式应用到我们提供的数据，实体API 能够提供灵活的、高性能的可视化，同时公开一致的、易于学习和易于使用的接口。 管理 Entities 每一个 Entity 对象都被添加到 EntityCollection 对象集合中，其中每个实体都有唯一的 ID。 添加 12345let entity = new Entity(&#123; id : 'uniqueId', ...&#125;);this.$viewer.entities.add(entity); 所有实体实例都有一个唯一的 id，在创建或修改时可用于从集合中检索实体。我们可以为实体指定一个 ID，否则将自动生成一个 ID。 隐藏 1entity.show = false; 获取 使用 getByiId 检索实体。如果不存在具有提供的 ID 的实体，则返回 undefined。 1let entity = this.$viewer.entities.getById('uniqueId') 要获取实体或创建新实体（如果不存在），可以使用 getOrCreateEntity。 1let entity = this.$viewer.entities.getOrCreateEntity('uniqueId'); 修改 可以在获取实体后对其属性进行修改。 12let entity = this.$viewer.entities.getById('uniqueId')entity.label.text= \"akashi\"; 移除 123456789// 先查后删let entity = viewer.entities.getById('uniqueId');this.$viewer.entities.remove(entity);// 直接移除this.$viewer.entities.removeById('uniqueId');//移除所有this.$viewer.entities.removeAll(); 点、图标和标签（Points, billboards, and labels） 可以通过设置 position、point 和 label 来创建图形点或标签。 点 &amp;&amp; 文字标签 12345678910111213141516171819202122232425262728let point = this.$viewer.entities.add(&#123; name: \"point\", position: Cesium.Cartesian3.fromDegrees(121.506377, 31.245105), point: &#123; pixelSize: 5, color: Cesium.Color.RED, outlineColor: Cesium.Color.WHITE, outlineWidth: 2, &#125;, label: &#123; text: \"Shanghai\", font: \"14pt monospace\", style: Cesium.LabelStyle.FILL_AND_OUTLINE, outlineWidth: 2, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(0, -9), &#125;,&#125;);this.$viewer.zoomTo(point);let camera = new Cesium.Camera(this.$viewer.scene);camera.flyTo(&#123; destination: Cesium.Cartesian3.fromDegrees( 121.506377, 31.245105, 1000000.0 ),&#125;); 图标 123456789101112131415161718let logo = this.$viewer.entities.add(&#123; position: Cesium.Cartesian3.fromDegrees(139.46, 35.42), billboard: &#123; image: \"images/Nogizaka46_Logo.png\", width: 128, height: 128, &#125;,&#125;);this.$viewer.trackedEntity = logo;let camera = new Cesium.Camera(this.$viewer.scene);camera.flyTo(&#123; destination: Cesium.Cartesian3.fromDegrees( 136, 36, 1000000 ),&#125;); Picking 拾取 在 Cesium 中，想获取不同的对象，需要通过 pick 方法来进行拾取。 然而其中又有多种 pick 的方法，包括 scene 中的 pick、pickPosition 和 drillPick；camera 中的 getPickRay 和 pickEllipsoid；以及 Globe 中的 pick。 屏幕坐标 通过 movement.position 获取。 1234567// 屏幕坐标let handler = new Cesium.ScreenSpaceEventHandler( this.$viewer.scene.canvas);handler.setInputAction((movement) =&gt; &#123; console.log(movement.position);&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 世界坐标 通过 viewer.scene.camera.pickEllipsoid(movement.position, ellipsoid) 获取，可以获取当前点击视线与椭球面相交处的坐标，其中 ellipsoid 是当前地球使用的椭球对象。 123456789 // 世界坐标let handler = new Cesium.ScreenSpaceEventHandler(this.$viewer.scene.canvas);handler.setInputAction((movement) =&gt; &#123; let position = this.$viewer.scene.camera.pickEllipsoid( movement.position, this.$viewer.scene.globe.ellipsoid ); console.log(position);&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 场景坐标 通过 viewer.scene.pickPosition(movement.position) 获取，根据窗口坐标，从场景的深度缓冲区中拾取相应的位置，返回笛卡尔坐标。 123456// 场景坐标let handler = new Cesium.ScreenSpaceEventHandler(this.$viewer.scene.canvas);handler.setInputAction((movement) =&gt; &#123; let position = this.$viewer.scene.pickPosition(movement.position); console.log(position);&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 地标坐标 通过 viewer.scene.globe.pick(ray, scene) 获取，可以获取点击处地球表面的世界坐标，不包括模型、倾斜摄影表面。其中 ray=viewer.camera.getPickRay(movement.position)。 1234567// 地标坐标let handler = new Cesium.ScreenSpaceEventHandler(this.$viewer.scene.canvas);handler.setInputAction((movement) =&gt; &#123; let ray = this.$viewer.camera.getPickRay(movement.position); let position = this.$viewer.scene.globe.pick(ray, this.$viewer.scene); console.log(position);&#125;, Cesium.ScreenSpaceEventType.LEFT_CLICK); 形状和体积（Shapes and Volumes）之前介绍过，Cesium 加载点线面矢量数据可以通过 Entity API 或 Primitive API 实现，而无论我们怎样定义实体实例和几何，所有形状和物体都有一组共同的属性来控制它们的外观。 fill 布尔型，用于指定目标形状是否被填充，默认为 true outline 布尔型，用于指定是否绘制形状的边缘， 默认为 false material 如果 fill 为 true，该属性可以控制填充的材质类型，默认为 Color.WHITE 具体形状的外观属性可通过官方 API 中的 Cesium.Entity 下各形状的 Type 属性查看。 Cesium.Entity API 材质例如我们创建一个蓝色半透明的椭圆实例，默认 fill 为 true： 12345678910let entity = this.$viewer.entities.add(&#123; position: Cesium.Cartesian3.fromDegrees(-103.0, 40.0), ellipse: &#123; semiMinorAxis: 250000.0, semiMajorAxis: 400000.0, material: Cesium.Color.BLUE.withAlpha(0.5), &#125;,&#125;);this.$viewer.zoomTo(entity); 然后改变其材质属性，实现各种不同的效果： 123456// 棋盘材质entity.ellipse.material = new Cesium.CheckerboardMaterialProperty(&#123; evenColor: Cesium.Color.WHITE, oddColor: Cesium.Color.BLACK, repeat: new Cesium.Cartesian2(4, 4),&#125;); 123456// 条纹材质entity.ellipse.material = new Cesium.StripeMaterialProperty(&#123; evenColor: Cesium.Color.WHITE, oddColor: Cesium.Color.BLACK, repeat: 32,&#125;); 1234567// 网格材质entity.ellipse.material = new Cesium.GridMaterialProperty(&#123; color: Cesium.Color.YELLOW, cellAlpha: 0.2, lineCount: new Cesium.Cartesian2(8, 8), lineThickness: new Cesium.Cartesian2(2.0, 2.0),&#125;); 轮廓outline 没有相应的材料，而是依赖于两个独立的 outlineColor 和 outlineWidth 属性。 123456entity.ellipse.fill = false;entity.ellipse.outline = true;entity.ellipse.outlineColor = Cesium.Color.YELLOW;entity.ellipse.outlineWidth = 5.0;this.$viewer.zoomTo(entity); 高度与挤压 覆盖在地球上的所有形状，当前是圆、椭圆、多边形和矩形，也可以放置在海拔高度或挤压成一个物体。在这两种情况下，形状或物体仍然符合其下方的地球曲率。 当需要物体距离地面一定高度的时候，可以在相应的图形对象上设置高度属性： 12345678910111213let polygon = this.$viewer.entities.add(&#123; name: \"正方形\", id: \"square\", polygon: &#123; hierarchy: Cesium.Cartesian3.fromDegreesArray([...]), material: Cesium.Color.RED.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.BLACK, height: 250000, &#125;,&#125;);this.$viewer.zoomTo(polygon); 在侧面可以看到物体就有了高度。 将形状挤压成物体同样，需要设置 extrudedHeight 属性: 123456789101112let polygon = this.$viewer.entities.add(&#123; name: \"正方形\", id: \"square\", polygon: &#123; hierarchy: Cesium.Cartesian3.fromDegreesArray([...]), material: Cesium.Color.RED.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.BLACK, height: 200000, extrudedHeight: 250000, &#125;,&#125;); 注意：意外发现当同时使用 height 与 extrudedHeight 并且值相同时，extrudedHeight 不会生效。 三维图形（3D models） CesiumJS 支持通过 glTF（运行时asset format）创建 3D 模型。 123456789101112131415161718192021222324252627282930313233343536373839let position = Cesium.Cartesian3.fromDegrees( -75.62808254394531, 40.02824946899414);let modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);let heading = Cesium.Math.toRadians(10.0);let pitch = Cesium.Math.toRadians(-10.0);let roll = Cesium.Math.toRadians(0.0);let headingPitchRoll = new Cesium.HeadingPitchRoll(heading, pitch, roll);let orientation = new Cesium.Transforms.headingPitchRollQuaternion( position, headingPitchRoll);let carModel = this.$viewer.scene.primitives.add( new Cesium.Model.fromGltf(&#123; //异步的加载模型 url: \"model3D/Truck.glb\", scale: 3.0, //缩放 position: position, orientation: orientation, modelMatrix: modelMatrix, //模型矩阵 &#125;));this.$viewer.scene.camera.setView(&#123; destination: new Cesium.Cartesian3.fromDegrees( -75.62808254394531, 40.02624946899414, 50.0 ), orientation: &#123; heading, pitch, roll, &#125;,&#125;); 1234567891011121314151617181920212223let position = Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 0);let heading = Cesium.Math.toRadians(135);let pitch = 0;let roll = 0;let hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);let orientation = Cesium.Transforms.headingPitchRollQuaternion( position, hpr);let entity = this.$viewer.entities.add(&#123; name: \"J15\", position: position, orientation: orientation, model: &#123; uri: \"model3D/J15.glb\", minimumPixelSize: 128, maximumScale: 20000, &#125;,&#125;);this.$viewer.trackedEntity = entity; 默认情况下，模型竖直放置、并且面向东面。可以指定四元组（Quaternion）给 Entity.orientation 属性，以改变放置的方向。 12345678910111213//位置let position = Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706);//绕垂直于地心的轴旋转let heading = Cesium.Math.toRadians(45.0);//绕纬度线旋转let pitch = Cesium.Math.toRadians(15.0);//绕经度线旋转let roll = Cesium.Math.toRadians(0.0);let orientation = Cesium.Transforms.headingPitchRollQuaternion(position, heading, pitch, roll); heading（yaw）、pitch、roll 对应了绕 Z（垂直轴）、Y（维度方向）、X（经度方向）进行旋转，正数表示顺时针旋转（由于相对运动，在浏览器上看起来是地球在逆时针旋转），可以参考下图理解（人面向北面，摇头heading、点头pitch、歪头roll）。 Entity API Entity 实例将多种形式的可视化聚集到单个高级对象中。通过手动创建并将实体添加到 Viewer.entities 中。 Name Type Description box BoxGraphics 与该实体关联的框。 corridor CorridorGraphics 与该实体关联的走廊。 cylinder CylinderGraphics 与该实体关联的圆柱体。 ellipse EllipseGraphics 与该实体关联的椭圆。 ellipsoid EllipsoidGraphics 与该实体关联的椭球。 label LabelGraphics 与该实体关联的options.label。 model ModelGraphics 与该实体关联的模型。 path PathGraphics 与该实体关联的路径。 plane PlaneGraphics 与该实体关联的平面。 point PointGraphics 与该实体关联的点。 polygon PolygonGraphics 与该实体关联的多边形。 polyline PolylineGraphics 与该实体关联的折线。 rectangle RectangleGraphics 与该实体关联的矩形。 wall WallGraphics 与该实体关联的墙。 Box1234567891011121314151617181920212223242526272829303132333435// 立方体let blueBox = this.$viewer.entities.add(&#123; name: \"Blue box\", //中心的位置 position: Cesium.Cartesian3.fromDegrees(-114.0, 40.0, 300000.0), box: &#123; //长宽高 dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0), material: Cesium.Color.BLUE.withAlpha(0.5), &#125;,&#125;);let redBox = this.$viewer.entities.add(&#123; name: \"Red box with black outline\", position: Cesium.Cartesian3.fromDegrees(-107.0, 40.0, 300000.0), box: &#123; dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0), material: Cesium.Color.RED, outline: true, //显示轮廓 outlineColor: Cesium.Color.BLACK, &#125;,&#125;);let outlineOnly = this.$viewer.entities.add(&#123; name: \"Yellow box outline\", position: Cesium.Cartesian3.fromDegrees(-100.0, 40.0, 300000.0), box: &#123; dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0), fill: false, //不显示填充 outline: true, outlineColor: Cesium.Color.YELLOW, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Ellipse123456789101112131415161718192021222324252627282930313233343536373839404142// 椭圆// 浮空的绿色圆形let greenCircle = this.$viewer.entities.add(&#123; position: Cesium.Cartesian3.fromDegrees(-111.0, 40.0, 150000.0), name: \"Green circle at height\", ellipse: &#123; semiMinorAxis: 300000.0, semiMajorAxis: 300000.0, height: 200000.0, //浮空 material: Cesium.Color.GREEN, &#125;,&#125;);// 红色椭圆形，位于地表，带轮廓let redEllipse = this.$viewer.entities.add(&#123; //不带高度 position: Cesium.Cartesian3.fromDegrees(-103.0, 40.0), name: \"Red ellipse on surface with outline\", ellipse: &#123; semiMinorAxis: 250000.0, semiMajorAxis: 400000.0, material: Cesium.Color.RED.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.RED, &#125;,&#125;);//蓝色椭圆柱，旋转了角度let blueEllipse = this.$viewer.entities.add(&#123; position: Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 100000.0), name: \"Blue translucent, rotated, and extruded ellipse\", ellipse: &#123; semiMinorAxis: 150000.0, semiMajorAxis: 300000.0, extrudedHeight: 200000.0, //拉伸 rotation: Cesium.Math.toRadians(45), //旋转 material: Cesium.Color.BLUE.withAlpha(0.7), outline: true, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Corridor 走廊。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 // Corridorlet redCorridor = this.$viewer.entities.add(&#123; name: \"Red corridor on surface with rounded corners and outline\", corridor: &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -100.0, 40.0, -105.0, 40.0, -105.0, 35.0, ]), width: 200000.0, material: Cesium.Color.RED.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.RED, &#125;,&#125;);let greenCorridor = this.$viewer.entities.add(&#123; name: \"Green corridor at height with mitered corners\", corridor: &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -90.0, 40.0, -95.0, 40.0, -95.0, 35.0, ]), height: 100000.0, width: 200000.0, cornerType: Cesium.CornerType.MITERED, material: Cesium.Color.GREEN, &#125;,&#125;);let blueCorridor = this.$viewer.entities.add(&#123; name: \"Blue extruded corridor with beveled corners and outline\", corridor: &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -80.0, 40.0, -85.0, 40.0, -85.0, 35.0, ]), height: 200000.0, extrudedHeight: 100000.0, width: 200000.0, cornerType: Cesium.CornerType.BEVELED, material: Cesium.Color.BLUE.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.BLUE, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Cylinder12345678910111213141516171819202122232425262728//圆柱和圆锥 Cylinder Coneslet greenCylinder = this.$viewer.entities.add(&#123; name: \"Green cylinder with black outline\", position: Cesium.Cartesian3.fromDegrees(-100.0, 40.0, 200000.0), cylinder: &#123; //圆柱 length: 400000.0, topRadius: 200000.0, bottomRadius: 200000.0, material: Cesium.Color.GREEN, outline: true, outlineColor: Cesium.Color.DARK_GREEN, &#125;,&#125;);let redCone = this.$viewer.entities.add(&#123; name: \"Red cone\", position: Cesium.Cartesian3.fromDegrees(-105.0, 40.0, 200000.0), cylinder: &#123; //圆锥 length: 400000.0, topRadius: 0.0, bottomRadius: 200000.0, material: Cesium.Color.RED, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Polygon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 多边形 Polygonlet redPolygon = this.$viewer.entities.add(&#123; name: \"贴着地表的多边形\", polygon: &#123; hierarchy: Cesium.Cartesian3.fromDegreesArray([ -115.0, 37.0, -115.0, 32.0, -107.0, 33.0, -102.0, 31.0, -102.0, 35.0, ]), material: Cesium.Color.RED, &#125;,&#125;);let greenPolygon = this.$viewer.entities.add(&#123; name: \"绿色拉伸多边形\", polygon: &#123; hierarchy: Cesium.Cartesian3.fromDegreesArray([ -108.0, 42.0, -100.0, 42.0, -104.0, 40.0, ]), extrudedHeight: 500000.0, material: Cesium.Color.GREEN, &#125;,&#125;);let orangePolygon = this.$viewer.entities.add(&#123; name: \"每个顶点具有不同拉伸高度的橘色多边形\", polygon: &#123; hierarchy: Cesium.Cartesian3.fromDegreesArrayHeights([ -108.0, 25.0, 100000, -100.0, 25.0, 100000, -100.0, 30.0, 100000, -108.0, 30.0, 300000, ]), extrudedHeight: 0, perPositionHeight: true, material: Cesium.Color.ORANGE, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);let bluePolygon = this.$viewer.entities.add(&#123; name: \"具有挖空效果的蓝色多边形\", polygon: &#123; hierarchy: &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -99.0, 30.0, -85.0, 30.0, -85.0, 40.0, -99.0, 40.0, ]), holes: [ &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -97.0, 31.0, -97.0, 39.0, -87.0, 39.0, -87.0, 31.0, ]), holes: [ &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -95.0, 33.0, -89.0, 33.0, -89.0, 37.0, -95.0, 37.0, ]), holes: [ &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -93.0, 34.0, -91.0, 34.0, -91.0, 36.0, -93.0, 36.0, ]), &#125;, ], &#125;, ], &#125;, ], &#125;, material: Cesium.Color.BLUE, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Polylines123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// Polylineslet redLine = this.$viewer.entities.add(&#123; name: \"Red line on terrain\", polyline: &#123; positions: Cesium.Cartesian3.fromDegreesArray([-75, 35, -125, 35]), width: 5, material: Cesium.Color.RED, clampToGround: true, &#125;,&#125;);redLine.show = false;let greenRhumbLine = this.$viewer.entities.add(&#123; name: \"Green rhumb line\", polyline: &#123; positions: Cesium.Cartesian3.fromDegreesArray([-75, 35, -125, 35]), width: 5, arcType: Cesium.ArcType.RHUMB, material: Cesium.Color.GREEN, &#125;,&#125;);greenRhumbLine.show = false;let glowingLine = this.$viewer.entities.add(&#123; name: \"Glowing blue line on the surface\", polyline: &#123; positions: Cesium.Cartesian3.fromDegreesArray([-75, 37, -125, 37]), width: 10, material: new Cesium.PolylineGlowMaterialProperty(&#123; glowPower: 0.2, taperPower: 0.5, color: Cesium.Color.CORNFLOWERBLUE, &#125;), &#125;,&#125;);glowingLine.show = false;let orangeOutlined = this.$viewer.entities.add(&#123; name: \"Orange line with black outline at height and following the surface\", polyline: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -75, 39, 250000, -125, 39, 250000, ]), width: 5, material: new Cesium.PolylineOutlineMaterialProperty(&#123; color: Cesium.Color.ORANGE, outlineWidth: 2, outlineColor: Cesium.Color.BLACK, &#125;), &#125;,&#125;);orangeOutlined.show = false;let purpleArrow = this.$viewer.entities.add(&#123; name: \"Purple straight arrow at height\", polyline: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -75, 43, 500000, -125, 43, 500000, ]), width: 10, arcType: Cesium.ArcType.NONE, material: new Cesium.PolylineArrowMaterialProperty( Cesium.Color.PURPLE ), &#125;,&#125;);purpleArrow.show = false;let dashedLine = this.$viewer.entities.add(&#123; name: \"Blue dashed line\", polyline: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -75, 45, 500000, -125, 45, 500000, ]), width: 4, material: new Cesium.PolylineDashMaterialProperty(&#123; color: Cesium.Color.CYAN, &#125;), &#125;,&#125;);dashedLine.show = false;this.$viewer.zoomTo(this.$viewer.entities); Polyline Volumes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// Polyline Volumesfunction computeCircle(radius) &#123; var positions = []; for (var i = 0; i &lt; 360; i++) &#123; var radians = Cesium.Math.toRadians(i); positions.push( new Cesium.Cartesian2( radius * Math.cos(radians), radius * Math.sin(radians) ) ); &#125; return positions;&#125;function computeStar(arms, rOuter, rInner) &#123; var angle = Math.PI / arms; var length = 2 * arms; var positions = new Array(length); for (var i = 0; i &lt; length; i++) &#123; var r = i % 2 === 0 ? rOuter : rInner; positions[i] = new Cesium.Cartesian2( Math.cos(i * angle) * r, Math.sin(i * angle) * r ); &#125; return positions;&#125;let redTube = this.$viewer.entities.add(&#123; name: \"Red tube with rounded corners\", polylineVolume: &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -85.0, 32.0, -85.0, 36.0, -89.0, 36.0, ]), shape: computeCircle(60000.0), material: Cesium.Color.RED, &#125;,&#125;);let greenBox = this.$viewer.entities.add(&#123; name: \"Green box with beveled corners and outline\", polylineVolume: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -90.0, 32.0, 0.0, -90.0, 36.0, 100000.0, -94.0, 36.0, 0.0, ]), shape: [ new Cesium.Cartesian2(-50000, -50000), new Cesium.Cartesian2(50000, -50000), new Cesium.Cartesian2(50000, 50000), new Cesium.Cartesian2(-50000, 50000), ], cornerType: Cesium.CornerType.BEVELED, material: Cesium.Color.GREEN, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);let blueStar = this.$viewer.entities.add(&#123; name: \"Blue star with mitered corners and outline\", polylineVolume: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -95.0, 32.0, 0.0, -95.0, 36.0, 100000.0, -99.0, 36.0, 200000.0, ]), shape: computeStar(7, 70000, 50000), cornerType: Cesium.CornerType.MITERED, material: Cesium.Color.BLUE, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Rectangle123456789101112131415161718192021222324252627// rectangle//红色矩形let redRectangle = this.$viewer.entities.add(&#123; name: \"Red translucent rectangle with outline\", rectangle: &#123; coordinates: Cesium.Rectangle.fromDegrees(-110.0, 20.0, -80.0, 25.0), material: Cesium.Color.RED.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.RED, &#125;,&#125;);//绿色旋转、拉伸的矩形let greenRectangle = this.$viewer.entities.add(&#123; name: \"Green translucent, rotated, and extruded rectangle\", rectangle: &#123; coordinates: Cesium.Rectangle.fromDegrees(-100.0, 30.0, -90.0, 40.0), material: Cesium.Color.GREEN.withAlpha(0.5), rotation: Cesium.Math.toRadians(45), extrudedHeight: 300000.0, height: 100000.0, outline: true, outlineColor: Cesium.Color.GREEN, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Sphere Ellipsoid12345678910111213141516171819202122232425262728293031323334353637// Sphere Ellipsoidlet blueEllipsoid = this.$viewer.entities.add(&#123; name: \"Blue ellipsoid\", position: Cesium.Cartesian3.fromDegrees(-114.0, 40.0, 300000.0), ellipsoid: &#123; //可以指定三个轴的半径 radii: new Cesium.Cartesian3(200000.0, 200000.0, 300000.0), material: Cesium.Color.BLUE, &#125;,&#125;);let redSphere = this.$viewer.entities.add(&#123; name: \"Red sphere with black outline\", position: Cesium.Cartesian3.fromDegrees(-107.0, 40.0, 300000.0), ellipsoid: &#123; //正球体 radii: new Cesium.Cartesian3(300000.0, 300000.0, 300000.0), material: Cesium.Color.RED, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);let ellipsoidOutlineOnly = this.$viewer.entities.add(&#123; name: \"Yellow ellipsoid outline\", position: Cesium.Cartesian3.fromDegrees(-100.0, 40.0, 300000.0), ellipsoid: &#123; radii: new Cesium.Cartesian3(200000.0, 200000.0, 300000.0), fill: false, outline: true, outlineColor: Cesium.Color.YELLOW, slicePartitions: 24, //横向切割线 stackPartitions: 36, //纵向切割线 &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); Wall123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// wall//东西方向的横墙let redWall = this.$viewer.entities.add(&#123; name: \"Red wall at height\", wall: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -115.0, 44.0, 200000.0, //坐标点 -90.0, 44.0, 200000.0, ]), minimumHeights: [100000.0, 100000.0], //按坐标点的最小高度数组 material: Cesium.Color.RED, &#125;,&#125;);//四边围墙let greenWall = this.$viewer.entities.add(&#123; name: \"Green wall from surface with outline\", wall: &#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -107.0, 43.0, 100000.0, -97.0, 43.0, 100000.0, -97.0, 40.0, 100000.0, -107.0, 40.0, 100000.0, -107.0, 43.0, 100000.0, ]), material: Cesium.Color.GREEN, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);//曲折的墙let blueWall = this.$viewer.entities.add(&#123; name: \"Blue wall with sawtooth heights and outline\", wall: &#123; //坐标点，不指定高度 positions: Cesium.Cartesian3.fromDegreesArray([ -115.0, 50.0, -112.5, 50.0, -110.0, 50.0, -107.5, 50.0, -105.0, 50.0, -102.5, 50.0, -100.0, 50.0, -97.5, 50.0, -95.0, 50.0, -92.5, 50.0, -90.0, 50.0, ]), maximumHeights: [ //上高 100000, 200000, 100000, 200000, 100000, 200000, 100000, 200000, 100000, 200000, 100000, ], minimumHeights: [ //下高 0, 100000, 0, 100000, 0, 100000, 0, 100000, 0, 100000, 0, ], material: Cesium.Color.BLUE, outline: true, outlineColor: Cesium.Color.BLACK, &#125;,&#125;);this.$viewer.zoomTo(this.$viewer.entities); 几何图形和外观（Geometry and Appearances）我们可以通过 Primitive API来操控几何图形及其外观，或者绘制各种特殊的形状。需要先得到 Scene 对象，然后在其上添加 Primitive 对象： Primitive 由两个部分组成： 几何形状（Geometry）：定义了 Primitive 的结构，例如三角形、线条、点等 外观（Appearance）：定义 Primitive 的着色（Sharding），包括GLSL（OpenGL着色语言，OpenGL Shading Language）顶点着色器和片段着色器（ vertex and fragment shaders），以及渲染状态（render state） Primitive APICesium支持以下几何图形： 几何图形 说明 BoxGeometry 立方体 BoxOutlineGeometry 仅有轮廓的立方体 CircleGeometry 圆形或者拉伸的圆形 CircleOutlineGeometry 只有轮廓的圆形 CorridorGeometry 走廊：沿着地表的多段线，且具有一定的宽度，可以拉伸到一定的高度 CorridorOutlineGeometry 只有轮廓的走廊 CylinderGeometry 圆柱、圆锥或者截断的圆锥 CylinderOutlineGeometry 只有轮廓的圆柱、圆锥或者截断的圆锥 EllipseGeometry 椭圆或者拉伸的椭圆 EllipseOutlineGeometry 只有轮廓的椭圆或者拉伸的椭圆 EllipsoidGeometry 椭球体 EllipsoidOutlineGeometry 只有轮廓的椭球体 RectangleGeometry 矩形或者拉伸的矩形 RectangleOutlineGeometry 只有轮廓的矩形或者拉伸的矩形 PolygonGeometry 多边形，可以具有空洞或者拉伸一定的高度 PolygonOutlineGeometry 只有轮廓的多边形 PolylineGeometry 多段线，可以具有一定的宽度 SimplePolylineGeometry 简单的多段线 PolylineVolumeGeometry 多段线柱体 PolylineVolumeOutlineGeometry 只有轮廓的多段线柱体 SphereGeometry 球体 SphereOutlineGeometry 只有轮廓的球体 WallGeometry 墙 WallOutlineGeometry 只有轮廓的墙 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328// 盒子 boxthis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: Cesium.BoxGeometry.fromDimensions(&#123; vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT, dimensions: new Cesium.Cartesian3(400000.0, 300000.0, 500000.0), &#125;), modelMatrix: Cesium.Matrix4.multiplyByTranslation( Cesium.Transforms.eastNorthUpToFixedFrame( Cesium.Cartesian3.fromDegrees(-105.0, 45.0) ), new Cesium.Cartesian3(0.0, 0.0, 250000), new Cesium.Matrix4() ), id: \"boxid\", attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.RED.withAlpha(0.5) ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(&#123; closed: true, &#125;), &#125;));// 圆 circlethis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.CircleGeometry(&#123; center: Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883), radius: 200000.0, // height: 300000, // extrudedHeight: 0 &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.PINK ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 走廊 corridorthis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.CorridorGeometry(&#123; positions: Cesium.Cartesian3.fromDegreesArray([ -90.0, 40.0, -70.0, 35.0, -70.0, 30.0, ]), width: 60000, &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.RED.withAlpha(0.5) ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 共面多边几何 Coplanarthis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.CoplanarPolygonGeometry(&#123; polygonHierarchy: new Cesium.PolygonHierarchy( Cesium.Cartesian3.fromDegreesArrayHeights([ -110.0, 65.0, 100000, -100.0, 65.0, 100000, -100.0, 70.0, 100000, -110.0, 70.0, 300000, ]) ), &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.GREEN ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 圆柱 Cylinderthis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.CylinderGeometry(&#123; length: 400000, topRadius: 200000, bottomRadius: 200000, &#125;), modelMatrix: Cesium.Matrix4.multiplyByTranslation( Cesium.Transforms.eastNorthUpToFixedFrame( Cesium.Cartesian3.fromDegrees(-100, 60) ), new Cesium.Cartesian3(0.0, 0.0, 100000.0), new Cesium.Matrix4() ), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.GREEN ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 椭圆 ellipsethis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.EllipseGeometry(&#123; center: Cesium.Cartesian3.fromDegrees(-100.0, 20.0), semiMinorAxis: 200000.0, semiMajorAxis: 300000.0, // 回转 rotation: Cesium.Math.PI_OVER_FOUR, vertexFormat: Cesium.VertexFormat.POSITION_AND_ST, height: 300000, extrudedHeight: 0, &#125;), &#125;), appearance: new Cesium.EllipsoidSurfaceAppearance(&#123; material: Cesium.Material.fromType(\"Checkerboard\"), &#125;), &#125;));// 椭球 ellipsoidthis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.EllipsoidGeometry(&#123; radii: new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0), vertexFormat: Cesium.VertexFormat.POSITION_AND_NORMAL, &#125;), modelMatrix: Cesium.Matrix4.multiplyByTranslation( Cesium.Transforms.eastNorthUpToFixedFrame( Cesium.Cartesian3.fromDegrees(-95, 35) ), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4() ), id: \"ellipsoid\", attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.AQUA ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 多边形 polygon 三角形this.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.PolygonGeometry(&#123; polygonHierarchy: &#123; positions: Cesium.Cartesian3.fromDegreesArray([ -80.0, 45.0, -80.0, 40.0, -85.0, 40.0, ]), &#125;, height: 300000, vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT, &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.PURPLE.withAlpha(0.5) ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 矩形 rectanglethis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.RectangleGeometry(&#123; rectangle: Cesium.Rectangle.fromDegrees( -140.0, 30.0, -110.0, 40.0 ), vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT, &#125;), id: \"rectangle\", attributes: &#123; color: new Cesium.ColorGeometryInstanceAttribute( 0.0, 1.0, 1.0, 0.5 ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 球体 Sphere(can't shown)this.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.SphereGeometry(&#123; radius: 10000.0, // vertexFormat : Cesium.VertexFormat.POSITION_ONLY &#125;), modelMatrix: Cesium.Matrix4.multiplyByTranslation( Cesium.Transforms.eastNorthUpToFixedFrame( Cesium.Cartesian3.fromDegrees(-140, 40) ), new Cesium.Cartesian3(0.0, 0.0, 100000.0), new Cesium.Matrix4() ), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.YELLOW.withAlpha(0.5) ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 墙体 Wallthis.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.WallGeometry(&#123; positions: Cesium.Cartesian3.fromDegreesArrayHeights([ -115.0, 45.0, 300000.0, -115.0, 50.0, 300000.0, -120.0, 50.0, 300000.0, -120.0, 45.0, 300000.0, -115.0, 45.0, 300000.0, ]), &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.BLUE.withAlpha(0.5) ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;));// 多边形实现箭头this.$viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.PolygonGeometry(&#123; polygonHierarchy: new Cesium.PolygonHierarchy( Cesium.Cartesian3.fromDegreesArray([ -105, 55, -110, 60, -115, 55, -113, 55, -113, 50, -107, 50, -107, 55, ]) ), height: 300000.0, // perPositionHeight: true, extrudedHeight: 10, &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.RED.withAlpha(0.5) ), &#125;, &#125;), appearance: new Cesium.PerInstanceColorAppearance(), &#125;)); Appearance primitive 的属性除了 Geometry，还有另一个关键属性就是 Appearance。它定义了 primitive 的纹理，即单个像素的颜色。primitive 可以有多个几何实例，但只能有一个外观。 外观定义了绘制 Primitive 时在GPU上执行的完整 GLSL 顶点和面片着色器。外观还定义了完整的渲染状态，它控制绘制 primitvie 时 GPU 的状态。 我们可以直接定义渲染状态，也可以使用更高级的属性，如“闭合(closed)”和“半透明(translucent)”，外观将转换为渲染状态。 1234let appearance = new Cesium.PerInstanceColorAppearance(&#123; translucent : false, closed : true&#125;); 粒子系统(Introduction to Particle Systems) 粒子系统是一种图形技术，可以模拟复杂的物理效果。粒子系统是小图像的集合，当它们一起观看时，会形成一个更复杂的“模糊”物体，如火、烟、天气或烟花等效果。 通过使用诸如初始位置、速度和生命周期等属性指定单个粒子的行为，可以控制这些复杂的效果。 Particle system basics 基础粒子效果 123456789101112131415161718let model = this.$viewer.entities.getById(\"Truck\");let particleSystem = this.$viewer.scene.primitives.add( new Cesium.ParticleSystem(&#123; image: \"images/smoke.png\", imageSize: new Cesium.Cartesian2(20, 20), startScale: 1.0, endScale: 4.0, particleLife: 1.0, speed: 5.0, emitter: new Cesium.CircleEmitter(0.5), emissionRate: 5.0, modelMatrix: model.computeModelMatrix( Cesium.JulianDate.now(), new Cesium.Matrix4() ), lifetime: 16.0, &#125;)); ParticleSystem 一个参数化的对象，用于控制单个粒子对象 Particle 随时间的外观和行为。粒子由粒子发射器产生，有一个位置和类型，存活一段时间，然后消亡。 其中一些属性是动态的，如 startScale 和 endScale、startColor和endColor。 对于具有最大和最小输入的每个变量，粒子上该变量的实际值将随机分配到最大和最小输入之间，并在粒子的整个生命周期内静态保持该值。允许像这样更改的属性包括imageSize、speed、life和particleLife。 Emitters 发射器 当粒子诞生时，其初始位置和速度矢量由 ParticleEmitter 控制。发射器将每秒生成一些粒子，由 emissionRate 参数指定，根据发射器类型用随机速度初始化。 BoxEmitter 盒形发射器 BoxEmitter 在一个盒子内随机取样的位置初始化粒子，并将它们从六个盒子表面中的一个引导出来。它接收 Cartesian3 参数，该参数指定框的宽度、高度和深度尺寸。 123456789let particleSystem = scene.primitives.add(new Cesium.ParticleSystem(&#123; image: \"images/smoke.png\", color: Cesium.Color.MAGENTA, emissionRate: 5.0, emitter: new Cesium.BoxEmitter(new Cesium.Cartesian3(5.0, 5.0, 5.0)), imageSize : new Cesium.Cartesian2(25.0, 25.0), modelMatrix : entity.computeModelMatrix(viewer.clock.startTime, new Cesium.Matrix4()), lifetime : 16.0&#125;)); CircleEmitter 圆形发射器 CircleEmitter 在发射器上轴线方向上的圆形内的随机采样位置初始化粒子。它接收一个指定圆半径的浮点参数。 123456789let particleSystem = scene.primitives.add(new Cesium.ParticleSystem(&#123; image : '../../SampleData/smoke.png', color: Cesium.Color.MAGENTA, emissionRate: 5.0, emitter: new Cesium.CircleEmitter(5.0), imageSize : new Cesium.Cartesian2(25.0, 25.0), modelMatrix : entity.computeModelMatrix(viewer.clock.startTime, new Cesium.Matrix4()), lifetime : 16.0&#125;)); ConeEmitter 锥形发射器 ConeEmitter 在圆锥体的顶端初始化粒子，并以随机的角度引导它们离开圆锥体。它使用一个指定圆锥体角度的浮点参数。圆锥体沿发射器的上轴定向。 123456789let particleSystem = scene.primitives.add(new Cesium.ParticleSystem(&#123; image : '../../SampleData/smoke.png', color: Cesium.Color.MAGENTA, emissionRate: 5.0, emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(30.0)), imageSize : new Cesium.Cartesian2(25.0, 25.0), modelMatrix : entity.computeModelMatrix(viewer.clock.startTime, new Cesium.Matrix4()), lifetime : 16.0&#125;)); SphereEmitter 球形发射器 SphereEmitter 在球体内随机取样的位置初始化粒子，并将它们从球体中心向外引导。它使用一个指定球体半径的浮点参数。 123456789let particleSystem = scene.primitives.add(new Cesium.ParticleSystem(&#123; image : '../../SampleData/smoke.png', color: Cesium.Color.MAGENTA, emissionRate: 5.0, emitter: new Cesium.SphereEmitter(5.0), imageSize : new Cesium.Cartesian2(25.0, 25.0), modelMatrix : entity.computeModelMatrix(viewer.clock.startTime, new Cesium.Matrix4()), lifetime : 16.0&#125;)); 配置粒子系统粒子发射率 emissionRate 控制每秒发射多少粒子，可以改变系统中粒子的密度。 指定一组 burst 在一定时间发射粒子，可以增加粒子系统的多样性或爆炸性。 12345bursts : [ new Cesium.ParticleBurst(&#123;time : 5.0, minimum : 300, maximum : 500&#125;), new Cesium.ParticleBurst(&#123;time : 10.0, minimum : 50, maximum : 100&#125;), new Cesium.ParticleBurst(&#123;time : 15.0, minimum : 200, maximum : 300&#125;)] 在给定的时间，粒子会在最大和最小之间进行发射。 粒子生命周期和系统生命周期默认情况下，粒子系统将永远运行。要使粒子系统以设定的持续时间运行，可以使用 lifetime 以秒为单位指定持续时间，并将 loop 设置为 false。 12lifetime : 16.0,loop: false 要随机化每个粒子的输出，可以使用变量 minimumParticleLife 和 maximumArticleLife。 12minimumParticleLife: 5.0,maximumParticleLife: 10.0 样式化粒子 颜色 粒子的样式是使用 image 和 color 指定的纹理，这些纹理可以在粒子的生命周期中更改以创建动态效果。 下面的代码使烟雾粒子从绿色过渡到白色。 12startColor : Cesium.Color.LIGHTSEAGREEN.withAlpha(0.7),endColor : Cesium.Color.WHITE.withAlpha(0.0), 大小 粒子的大小由 imageSize 控制。要随机化大小，可以使用minimumImageSize.x和maximumImageSize.x控制宽度（以像素为单位），并使用minimumImageSize.y和maximumImageSize.y控制高度（以像素为单位）。 12minimumImageSize : new Cesium.Cartesian2(30.0, 30.0),maximumImageSize : new Cesium.Cartesian2(60.0, 60.0) 粒子的大小可以通过 startScale 和 endscale 属性在其生命周期中进行调整，以使粒子随时间增长或收缩。 12startScale: 1.0,endScale: 4.0 速度 速度由 speed 或 minimumSpeed 和 maximumSpeed 控制。 12minimumSpeed: 5.0,maximumSpeed: 10.0 UpdateCallback 更新回调通过应用更新函数，可以进一步自定义粒子系统。对于重力、风或颜色更改等效果，它可以动态更新每个粒子。 一个让粒子对重力作出反应的例子： 12345678910let gravityVector = new Cesium.Cartesian3();let gravity = -(9.8 * 9.8);function applyGravity(p, dt) &#123; let position = p.position; Cesium.Cartesian3.normalize(position, gravityVector); Cesium.Cartesian3.multiplyByScalar(gravityVector, gravity * dt, gravityVector); p.velocity = Cesium.Cartesian3.add(p.velocity, gravityVector, p.velocity);&#125; 该函数计算重力矢量，并使用重力加速度来改变粒子的速度。 将重力设置为粒子系统的 updateFunction： 1updateCallback : applyGravity Positioning 定位使用两个Matrix4变换矩阵定位粒子系统： modelMatrix 将粒子系统从模型转换为世界坐标。 emitterModelMatrix 在粒子系统的局部坐标系中变换粒子系统发射器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let model = this.$viewer.entities.getById(\"Truck\");let particleSystem = this.$viewer.scene.primitives.add( new Cesium.ParticleSystem(&#123; image: \"images/smoke.png\", startColor: Cesium.Color.LIGHTSEAGREEN.withAlpha(0.7), endColor: Cesium.Color.WHITE.withAlpha(0.0), startScale: 1.0, endScale: 4.0, particleLife: 1.0, minimumSpeed: 1.0, maximumSpeed: 4.0, imageSize: new Cesium.Cartesian2(25, 25), emissionRate: 5.0, lifetime: 16.0, emitter: new Cesium.CircleEmitter(0.5), modelMatrix: model.computeModelMatrix( Cesium.JulianDate.now(), new Cesium.Matrix4() ), emitterModelMatrix: new Cesium.Matrix4.fromTranslationQuaternionRotationScale( new Cesium.Cartesian3(-4.0, 0.0, 2.0), new Cesium.Quaternion(0, 0, 0, 1), new Cesium.Cartesian3(7.0, 6.0, 5.0), new Cesium.Matrix4() ), bursts: [ new Cesium.ParticleBurst(&#123; time: 5.0, minimum: 10, maximum: 100, &#125;), new Cesium.ParticleBurst(&#123; time: 10.0, minimum: 50, maximum: 100, &#125;), new Cesium.ParticleBurst(&#123; time: 15.0, minimum: 200, maximum: 300, &#125;), ], &#125;)); 高级粒子系统效应(Advanced Particle System Effects) 一些动态更新粒子的行为，需要在 updateParticle 函数中定义粒子的移动行为和其他动态元素。 以雪粒子更新函数为例： 12345678910111213141516171819202122232425let snowUpdate = function (particle, dt) &#123; dt; Cesium.Cartesian3.normalize(particle.position, snowGravityVector); Cesium.Cartesian3.multiplyByScalar( snowGravityVector, Cesium.Math.randomBetween(-30.0, -300.0), snowGravityVector ); particle.velocity = Cesium.Cartesian3.add( particle.velocity, snowGravityVector, particle.velocity ); let distance = Cesium.Cartesian3.distance( vm.$viewer.scene.camera.position, particle.position ); if (distance &gt; snowRadius) &#123; particle.endColor.alpha = 0.0; &#125; else &#123; particle.endColor.alpha = snowSystem.endColor.alpha / (distance / snowRadius + 0.1); &#125;&#125;; 更新函数用于定义粒子的移动、排列和可视化。修改粒子的color颜色、imageSize图像大小和particleLife粒子生命周期。我们甚至可以基于到相机距离定义粒子、导入模型或到地球本身的距离等。 额外的天气效应 使用雾和大气效果来增强可视化效果，并匹配我们试图复制的天气类型。 hueshift沿着颜色光谱改变颜色，saturationShift改变了视觉实际需要的颜色与黑白的对比程度，brightnessShift改变了颜色的生动程度。 雾密度改变了地球上覆盖物与雾的颜色之间的不透明程度。雾的minimumBrightness用来使雾变暗。 1234567// snowscene.skyAtmosphere.hueShift = -0.8;scene.skyAtmosphere.saturationShift = -0.7;scene.skyAtmosphere.brightnessShift = -0.33;scene.fog.density = 0.001;scene.fog.minimumBrightness = 0.8; Snow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 雪景snow() &#123; let vm = this; this.$viewer.terrainProvider = Cesium.createWorldTerrain(); this.$viewer.scene.globe.depthTestAgainstTerrain = true; this.$viewer.scene.camera.setView(&#123; destination: new Cesium.Cartesian3( 277096.634865404, 5647834.481964232, 2985563.7039122293 ), orientation: &#123; heading: 4.731089976107251, pitch: -0.32003481981370063, &#125;, &#125;); let snowGravityVector = new Cesium.Cartesian3(); let snowUpdate = function (particle, dt) &#123; dt; Cesium.Cartesian3.normalize(particle.position, snowGravityVector); Cesium.Cartesian3.multiplyByScalar( snowGravityVector, Cesium.Math.randomBetween(-30.0, -300.0), snowGravityVector ); particle.velocity = Cesium.Cartesian3.add( particle.velocity, snowGravityVector, particle.velocity ); let distance = Cesium.Cartesian3.distance( vm.$viewer.scene.camera.position, particle.position ); if (distance &gt; snowRadius) &#123; particle.endColor.alpha = 0.0; &#125; else &#123; particle.endColor.alpha = snowSystem.endColor.alpha / (distance / snowRadius + 0.1); &#125; &#125;; // 雾与大气效果 this.$viewer.scene.skyAtmosphere.hueShift = -0.8; this.$viewer.scene.skyAtmosphere.saturationShift = -0.7; this.$viewer.scene.skyAtmosphere.brightnessShift = -0.33; this.$viewer.scene.fog.density = 0.001; this.$viewer.scene.fog.minimumBrightness = 0.8; let snowParticleSize = this.$viewer.scene.drawingBufferWidth / 100.0; let snowRadius = 100000.0; let snowSystem = new Cesium.ParticleSystem(&#123; modelMatrix: new Cesium.Matrix4.fromTranslation( this.$viewer.scene.camera.position ), minimumSpeed: -1.0, maximumSpeed: 0.0, lifetime: 15.0, emitter: new Cesium.SphereEmitter(snowRadius), startScale: 0.5, endScale: 1.0, image: \"images/snow.png\", emissionRate: 700.0, startColor: Cesium.Color.WHITE.withAlpha(0.0), endColor: Cesium.Color.WHITE.withAlpha(1.0), minimumImageSize: new Cesium.Cartesian2( snowParticleSize, snowParticleSize ), maximumImageSize: new Cesium.Cartesian2( snowParticleSize, snowParticleSize ), updateCallback: snowUpdate, &#125;); this.$viewer.scene.primitives.add(snowSystem);&#125;, Rain1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 雨景rain() &#123; let vm = this; this.$viewer.terrainProvider = Cesium.createWorldTerrain(); this.$viewer.scene.globe.depthTestAgainstTerrain = true; this.$viewer.scene.camera.setView(&#123; destination: new Cesium.Cartesian3( 277096.634865404, 5647834.481964232, 2985563.7039122293 ), orientation: &#123; heading: 4.731089976107251, pitch: -0.32003481981370063, &#125;, &#125;); // rain this.$viewer.scene.skyAtmosphere.hueShift = -0.97; this.$viewer.scene.skyAtmosphere.saturationShift = 0.25; this.$viewer.scene.skyAtmosphere.brightnessShift = -0.4; this.$viewer.scene.fog.density = 0.00025; this.$viewer.scene.fog.minimumBrightness = 0.01; let rainParticleSize = this.$viewer.scene.drawingBufferWidth / 100.0; let rainRadius = 100000.0; let rainGravityScratch = new Cesium.Cartesian3(); let rainUpdate = function (particle, dt) &#123; dt; rainGravityScratch = Cesium.Cartesian3.normalize( particle.position, rainGravityScratch ); rainGravityScratch = Cesium.Cartesian3.multiplyByScalar( rainGravityScratch, -1050.0, rainGravityScratch ); particle.position = Cesium.Cartesian3.add( particle.position, rainGravityScratch, particle.position ); let distance = Cesium.Cartesian3.distance( vm.$viewer.scene.camera.position, particle.position ); if (distance &gt; rainRadius) &#123; particle.endColor.alpha = 0.0; &#125; else &#123; particle.endColor.alpha = rainSystem.endColor.alpha / (distance / rainRadius + 0.1); &#125; &#125;; let rainSystem = new Cesium.ParticleSystem(&#123; modelMatrix: new Cesium.Matrix4.fromTranslation( this.$viewer.scene.camera.position ), speed: -1.0, lifetime: 15.0, emitter: new Cesium.SphereEmitter(rainRadius), startScale: 1.0, endScale: 0.0, image: \"images/rain.png\", emissionRate: 900.0, startColor: new Cesium.Color(0.27, 0.4, 0.6, 0.0), endColor: new Cesium.Color(0.27, 0.4, 0.6, 0.98), imageSize: new Cesium.Cartesian2( rainParticleSize, rainParticleSize * 2 ), updateCallback: rainUpdate, &#125;); this.$viewer.scene.primitives.add(rainSystem);&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"Cesium","slug":"Cesium","permalink":"http://akashigakki.github.io/tags/Cesium/"}]},{"title":"深入理解 Vue.js（一）","slug":"vuejs-repeat-1/repeat-vuejs","date":"2020-09-25T16:00:00.000Z","updated":"2020-10-06T11:19:45.393Z","comments":true,"path":"2020/09/26/vuejs-repeat-1/repeat-vuejs/","link":"","permalink":"http://akashigakki.github.io/2020/09/26/vuejs-repeat-1/repeat-vuejs/","excerpt":"深入理解 Vue.js（一） 重读文档，同时也是对自己的积累的又一次推倒重建。","text":"深入理解 Vue.js（一） 重读文档，同时也是对自己的积累的又一次推倒重建。 什么是 Vue.js Vue 是一个渐进式前端框架，其核心概念是数据的双向绑定、组件化、单向数据流、可复用等。既然是重新阅读官方文档，那我们从一个工程化项目开始。 Vue 工程化项目12345npm install -g @vue/clivue -Vvue create vue-democd vue-demonpm run serve 这时，我们得到了一个这样的文件结构： 首先我们来关注 src/main.js： 12345678import Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App),&#125;).$mount('#app') 可见，这里引入了 vue 与 App.vue 文件，同时 new 了一个 Vue 实例并做了节点渲染。 现在我们先封装一个组件 ComponentItem 并抛出。在 component 文件夹下新建 ComponentItem.vue 文件: 1234567891011&lt;template&gt; &lt;div&gt;这是一个Vue子组件&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\",&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 一个 vue 文件由模板 template、脚本 script 和样式 style三部分构成。 进入 App.vue 在 script 中导入(import) components 中被抛出的组件 ComponentItem 并在 components 中声明使用，最终在 template 中渲染到浏览器显示。 12345678910111213141516171819202122&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ComponentItem /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ComponentItem from './components/ComponentItem'export default &#123; name: 'App', components: &#123; ComponentItem &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; ...&#125;&lt;/style&gt; 注：这里删除掉自动生成的 HelloWorld.vue 文件以及引入的相关多余内容。 这时我们可以在浏览器看到子组件便被渲染到了页面上。 数据与方法 熟悉了基本的组件创建，我们先回顾一下 Vue 的数据与方法。 Vue 的初始数据声明在 data 中。当一个实例被创建时，它将 data 对象(组件中为data函数)中的所有属性(property)加入到 Vue 的响应式系统中，通过属性值的变化，自动绑定到视图，称为数据的双向绑定。 注意：在组件中，data 是一个函数而不是对象，这样每个实例便可以维护一份被返回对象的独立的拷贝。 比如在我们新建的 ComponentItem 组件中，我们这样使用 data: 123456export default &#123; name: \"ComponentItem\", data() &#123; return &#123;&#125; &#125;&#125;; 注意：只有当实例被创建时就已经存在于 data 中的属性(property)才是 响应式 的。所以如果我们在后续会需要一些属性，但是一开始它为空或不存在，那么需要在 data 中设置一些初始值。 Vue 以自身的 diff 算法遍历计算 Virtual DOM，找到最小差异 DOM 更新，避免了真实的 DOM 渲染引起的整个 DOM 树的重排重绘，减小浏览器消耗。 Vue 自定义实例属性带有 $ 前缀，与用户定义的 property 进行区分，如： 12345678910111213141516var data = &#123; a: 1&#125;var vm = new Vue(&#123; el: '#app', data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('app') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 更多 API 查找参照 官网文档 常用的如：vm.$data、vm.$el、vm.$props、vm.$options、vm.$refs、vm.$watch、vm.$set、vm.$on、vm.$emit、vm.$attrs 等。 钩子函数与生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程，如设置数据监听、编译模板、挂载实例到 DOM、数据变化更新 DOM 等。在整个过程中，会运行一些生命周期钩子的函数，允许用户在不同阶段添加自己的代码进行处理。 如： 1234created() &#123;&#125;,mounted() &#123;&#125;,updated() &#123;&#125;,destroyed() &#123;&#125; 注意：不要在选项 property 或回调上使用箭头函数，因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，会导致出现属性未定义、方法不存在的错误。 模板语法 在 Vue.js 的使用上，框架提供了基于 HTML 的 模板语法 和 渲染函数(render) &amp; JSX。 模板语法 允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。然后 Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 如果熟悉虚拟 DOM 并偏爱原生的 JavaScript，可使用 渲染函数(render)+JSX语法。 这里介绍模板语法的使用方法。 插值文本插值数据绑定最常见的形式就是使用双大括号进行文本插值： 12345678910111213141516&lt;template&gt; &lt;div class=\"container\"&gt; &lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; msg: \"This is a message\" &#125; &#125;&#125;;&lt;/script&gt; 原始 HTML双大括号会将数据解释为普通文本，而非 HTML 代码。使用 v-html 可以输出 HTML: 123456789101112131415161718&lt;template&gt; &lt;div class=\"container\"&gt; &lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; &lt;div v-html=\"html\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; msg: \"This is a message\", html: \"&lt;span style='color:red'&gt;This should bu red&lt;/span&gt;\" &#125; &#125;&#125;;&lt;/script&gt; 注意：动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 Attribute使用 v-bind 指令动态绑定到 HTML attribute 上： 12345678910111213141516&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div v-bind:id=\"id\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; id: 0 &#125; &#125;&#125;;&lt;/script&gt; 使用 JavaScript 表达式同时，所有的数据绑定 Vue.js 还提供了完全的 JavaScript 表达式支持: 12345678910111213141516&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; id: 0 &#125; &#125;&#125;;&lt;/script&gt; 指令 指令(Directives) 是带有 v- 前缀的特殊 attribute。 参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。如，v-bind 指令可以用于响应式地绑定更新 HTML attribute、v-on 指令可以用于绑定事件监听器： 12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"container\"&gt; &lt;a v-bind:href=\"url\"&gt;URL&lt;/a&gt; &lt;button v-on:click=\"handleClick\"&gt;Click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; url: \"https://akashi_sai.gitee.io\" &#125; &#125;, methods: &#123; handleClick() &#123; console.log(\"clicked!\") &#125; &#125;&#125;;&lt;/script&gt; 这里 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定，v-on 指令将该元素的 click 事件与 handleClick 方法进行绑定。 动态参数可以用方括号括起来的 JavaScript 表达式作为一个指令的参数，将上面的例子修改一下就可写为： 1234567891011121314151617&lt;template&gt; &lt;div class=\"container\"&gt; &lt;a v-bind:[href]=\"url\"&gt;URL&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; href: 'href', url: \"https://akashi_sai.gitee.io\" &#125; &#125;&#125;;&lt;/script&gt; 虽然效果上好像没有什么不同，但好处是这个参数可以是动态计算出来的，方便后续修改和提供了更多操作的可能。 对动态参数的值的约束 动态参数预期会求出一个 字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 语法上的约束，如空格和引号放在 HTML attribute 名里是无效的。 修饰符修饰符(modifier)是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 12&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 修饰符可以分类为事件修饰符、按键修饰符、系统修饰符和自定义修饰符。 简写简写是 Vue 提供的一种可选的合法字符，用于会频繁使用的两个特定的 attribute，v-bind 和 v-on。 v-bind 缩写12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=\"url\"&gt; ... &lt;/a&gt; v-on 缩写12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=\"doSomething\"&gt; ... &lt;/a&gt; 计算属性和侦听器计算属性(Computed) 用于解耦模板内的复杂逻辑，达到方便维护和简洁清晰的效果。 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=\"container\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; message: \"This is a message!\", &#125;; &#125;, computed: &#123; msg() &#123; return this.message .split(\"\") .reverse() .join(\"\"); &#125;, &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 计算属性缓存(computed) vs 方法(methods)我们发现调用方法也可以实现同样的效果，区别在于 计算属性 是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值。 而方法每当重新渲染时，都会再次执行函数。如果不希望一个值每次渲染都重新计算，那么使用方法在性能上是比较浪费的。 计算属性 vs 监听属性侦听属性是一个更通用的方式来观察和响应 vue 实例上的数据变动。但 Vue 官方建议，不要滥用 watch，通常更好的做法是使用计算属性。 计算属性的 setter计算属性默认只有 getter，不过在需要时也可以提供一个 setter： 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; let names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 侦听器(Watch)虽然计算属性在大多数情况下更合适，但有时也需要一个 自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行 异步 或 开销较大 的操作时，这个方式是最有用的。 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=\"container\"&gt; &lt;p&gt;FullName: &#123;&#123; fullName &#125;&#125;&lt;/p&gt; &lt;p&gt;FirstName: &lt;input type=\"text\" v-model=\"firstName\" /&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; firstName: \"Akashi\", lastName: \"Sai\", fullName: \"\" &#125;; &#125;, watch: &#123; firstName(newName, oldName) &#123; this.fullName = newName + ' ' + this.lastName; &#125; &#125;&#125;;&lt;/script&gt; handler 和 immediate以上是变化之后，wath 才执行，需要在最初时候 watch 就执行用到 ·、handler 和 immediate 属性。 12345678watch: &#123; firstName: &#123; handler(newName, oldName) &#123; this.fullName = newName + \" \" + this.lastName; &#125;, immediate: true &#125;,&#125; 深度监听 deep123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=\"container\"&gt; &lt;p&gt;&#123;&#123; obj.a &#125;&#125;&lt;/p&gt; &lt;p&gt;obj.a &lt;input type=\"text\" v-model=\"obj.a\" /&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ComponentItem\", data() &#123; return &#123; obj: &#123; a: \"123\" &#125; &#125;; &#125;, watch: &#123; obj: &#123; handler(val) &#123; console.log('obj.a', val); &#125;, deep: true &#125;, &#125;&#125;;&lt;/script&gt; 同时，官网也给出了监听不同层级的对应方法，效果与上述相同： 1234567watch: &#123; 'obj.a': &#123; handler(val) &#123; console.log('obj.a', val); &#125; &#125;&#125; 监听同时也可以通过方法的形式写在 methods 中： 12345678watch: &#123; \"obj.a\": \"watchMethods\" // 方法名&#125;,methods: &#123; watchMethods(val) &#123; console.log('val', val); &#125;&#125;, Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。一般操作是通过 v-bind 绑定后处理。 而将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定 HTML Class对象语法1&lt;div :class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 12345data() &#123; return &#123; isActive: true &#125;;&#125; 渲染后： 1&lt;div class=\"active\"&gt;&lt;/div&gt; 同时，也可以绑定在一个返回的计算属性中： 1&lt;div :class=\"classObject\"&gt;&lt;/div&gt; 123456789101112data() &#123; return &#123; isActive: true &#125;&#125;computed: &#123; classObject() &#123; return &#123; active: this.isActive &#125; &#125;&#125; 以上效果是相同的。 数组语法1&lt;div :class=\"classObject\"&gt;&lt;/div&gt; 12345data() &#123; return &#123; classObject: ['active', 'text'] &#125;;&#125; 渲染后： 1&lt;div class=\"active text\"&gt;&lt;/div&gt; 绑定内联样式对象语法1&lt;div :style=\"styles\"&gt;Akashi&lt;/div&gt; 12345678data() &#123; return &#123; styles: &#123; color: 'red', fontSize: '13px' &#125; &#125;;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。 数组语法1&lt;div :style=\"[baseStyles, overridingStyles]\"&gt;Akashi&lt;/div&gt; 123456789101112data() &#123; return &#123; baseStyles: &#123; color: 'red' &#125;, overridingStyles: &#123; fontSize: '13px' &#125;, // 亲测这样声明并不会生效，数组必须直接声明在内联样式中 // styles: [this.baseStyles, this.overridingStyles] &#125;;&#125; 条件渲染 v-if 指令用于条件性地渲染一块内容。当返回的值为真的时候被渲染。 v-if12345&lt;div class=\"container\"&gt; &lt;div v-if=\"type === 'a'\"&gt;A&lt;/div&gt; &lt;div v-else-if=\"type === 'b'\"&gt;B&lt;/div&gt; &lt;div v-else&gt;Not A/B&lt;/div&gt;&lt;/div&gt; 12345data() &#123; return &#123; type: 'c' &#125;;&#125; 渲染结果： 123&lt;div class=\"container\"&gt; &lt;div&gt;Not A/B&lt;/div&gt;&lt;/div&gt; 用 key 管理可复用元素默认 Vue 元素是复用的，这样可以高效的渲染元素，例如： 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; 上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder。 当需求是不需要复用，使用完全独立的两个元素时，可以添加具有唯一值的 key 属性。 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; v-show 与 v-if 相似，根据条件展示元素。 1&lt;div v-show=\"true\"&gt;Show&lt;/div&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。 v-if vs v-showv-if 会动态的渲染和重建节点元素，是属于真正的条件渲染，同时它也是惰性的，只有条件为真时才会渲染。 v-show 无论条件真假都会渲染，只是动态对 CSS 进行切换进而实现显隐。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 同时，不推荐同时使用 v-if 和 v-for。当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，即在每次重新渲染的时候都会遍历整个列表，即使 v-if 为 false。 列表渲染 v-for 指令基于一个数组来渲染一个列表。 v-for1234567&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in items\" :key=\"item\"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345data() &#123; return &#123; items: [\"akashi\", \"asuka\", \"agkki\"] &#125;&#125; 注意参数顺序，第一个参数为值，第二个参数为当前项的索引（可省略）。 为了 Vue 能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一的 key 属性。 使用对象同时 v-for 也支持使用对象进行迭代： 1234567&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key, index) of items\" :key=\"index\"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678data() &#123; return &#123; items: &#123; name: \"akashi\", age: 23 &#125; &#125;&#125; 注意：这时，参数顺序变为了键值、键名、索引。 同时，也可以用 of 替代 in 作为分隔符，它更接近 JavaScript 迭代器的语法。 而我们在实际中的开发中，更多的是使用数组对象的情况： 1234567&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in items\" :key=\"item.name\"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.name &#125;&#125; - &#123;&#123; item.age &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718data() &#123; return &#123; items: [ &#123; name: \"akashi\", age: 23, &#125;, &#123; name: \"asuka\", age: 22, &#125;, &#123; name: \"gakki\", age: 31, &#125;, ] &#125;&#125; 数组更新检测Vue 将 JS 的数组方法进行了侦听，数组方法的触发也会动态的更新到视图。 其中包括： 变更方法 push() pop() shift() unshift() splice() sort() reverse() join() 注：此类方法对原数组进行了修改。 替换数组 filter() concat() slice() map() 注：此类方法会返回一个新的数组，而不会改变原始数组。 事件处理监听事件及处理方法可以用 v-on 指令监听 DOM 事件（简写为 @），并在触发时运行一些 JavaScript 代码。 1234&lt;div class=\"container\"&gt; &lt;button @click=\"handleClick\"&gt;click&lt;/button&gt; &lt;p&gt;Counter: &#123;&#123; counter &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910data() &#123; return &#123; counter: 0, &#125;;&#125;,methods: &#123; handleClick() &#123; this.counter += 1; &#125;,&#125;, 访问原始的 DOM 事件。可以使用特殊变量 $event，将其传入方法： 1&lt;button @click=\"handleClick($event)\"&gt;click&lt;/button&gt; 123handleClick(e) &#123; console.log('$event', e);&#125; 注：如果函数不需要多余参数值，默认定义的参数同样可以获取 DOM 事件。 1&lt;button @click=\"handleClick\"&gt;click&lt;/button&gt; 123handleClick(e) &#123; console.log('$event', e);&#125; 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为此，Vue.js 为 v-on 提供了事件修饰符： .stop .prevent .capture .self .once .passive 123456789101112131415161718192021222324252627&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 按键修饰符123&lt;div class=\"container\"&gt; &lt;input @keyup.enter=\"onEnter\"&gt;&lt;/div&gt; 123onEnter(e) &#123; console.log(e.target.value);&#125; 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 还可以通过全局 config.keyCodes 对象自定义按键修饰符别名： 12// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 系统修饰符可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。 12&lt;!-- Alt + C --&gt;&lt;input v-on:keyup.alt.67=\"clear\"&gt; .exact 修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact=\"onClick\"&gt;A&lt;/button&gt; 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 表单输入绑定 使用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件 基础用法文本1234&lt;div class=\"container\"&gt; &lt;input v-model=\"message\" /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345data() &#123; return &#123; message: \"\", &#125;;&#125;, 多行文本1234&lt;div class=\"container\"&gt; &lt;textarea v-model=\"message\" placeholder=\"edit...\" /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345data() &#123; return &#123; message: \"\", &#125;;&#125; 复选框1234&lt;div class=\"container\"&gt; &lt;input type=\"checkbox\" v-model=\"checked\" /&gt; &lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;&lt;/div&gt; 12345data() &#123; return &#123; checked: false, &#125;;&#125;, 多个复选框： 123456789101112131415161718192021222324252627282930&lt;div class=\"container\"&gt; &lt;div&gt; &lt;label for=\"akashi\"&gt;Akashi&lt;/label&gt; &lt;input type=\"checkbox\" id=\"akashi\" value=\"akashi\" v-model=\"checkedNames\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"asuka\"&gt;Asuka&lt;/label&gt; &lt;input type=\"checkbox\" id=\"asuka\" value=\"asuka\" v-model=\"checkedNames\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"gakki\"&gt;Gakki&lt;/label&gt; &lt;input type=\"checkbox\" id=\"gakki\" value=\"gakki\" v-model=\"checkedNames\" /&gt; &lt;div&gt;CheckedNames: &#123;&#123; checkedNames &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345data() &#123; return &#123; checkedNames: [], &#125;;&#125; 单选框123456789101112131415&lt;div class=\"container\"&gt; &lt;div&gt; &lt;label for=\"akashi\"&gt;Akashi&lt;/label&gt; &lt;input type=\"radio\" id=\"akashi\" value=\"akashi\" v-model=\"picked\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"asuka\"&gt;Asuka&lt;/label&gt; &lt;input type=\"radio\" id=\"asuka\" value=\"asuka\" v-model=\"picked\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"gakki\"&gt;Gakki&lt;/label&gt; &lt;input type=\"radio\" id=\"gakki\" value=\"gakki\" v-model=\"picked\" /&gt; &lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345data() &#123; return &#123; picked: \"\", &#125;;&#125; 选择框12345678&lt;div class=\"container\"&gt; &lt;select v-model=\"selected\" style=\"width:60px\"&gt; &lt;option value=\"akashi\"&gt;Akashi&lt;/option&gt; &lt;option value=\"asuka\"&gt;Asuka&lt;/option&gt; &lt;option value=\"gakki\"&gt;Gakki&lt;/option&gt; &lt;/select&gt; &lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;/div&gt; 12345data() &#123; return &#123; selected: \"\", &#125;;&#125; 绑定值即单选框、复选框、选择框的 value 的绑定。各组件 v-model 绑定状态下会修改 vlue 的值。 修饰符 .lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步。通过添加 lazy 修饰符，从而转为在 change 事件 之后 进行同步。 .number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符。 .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符。 组件基础基本使用： ButtonCounter.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button @click=\"onClick\"&gt;clicked &#123;&#123; count &#125;&#125; times&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ButtonCounter\", data() &#123; return &#123; count: 0, &#125;; &#125;, methods: &#123; onClick() &#123; this.count++; &#125;, &#125;,&#125;;&lt;/script&gt; App.vue 12345678910111213141516&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ButtonCounter /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ButtonCounter from \"./components/ButtonCounter\"export default &#123; name: \"App\", components: &#123; ButtonCounter &#125;,&#125;;&lt;/script&gt; 复用 组件可以被多次复用，但每个组件都会维护一个独立的 data。 一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。 App.vue 123456789101112131415161718&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ButtonCounter /&gt; &lt;ButtonCounter /&gt; &lt;ButtonCounter /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ButtonCounter from \"./components/ButtonCounter\"export default &#123; name: \"App\", components: &#123; ButtonCounter &#125;,&#125;;&lt;/script&gt; Prop 向子组件传递数据 Prop 允许我们在组件上注册一些自定义属性，子组件 prop 属性通过接收父组件传递过来的值实现数据传递。 123456789101112131415161718192021&lt;template&gt; &lt;div id=\"app\"&gt; &lt;BlogPost :title=\"title\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BlogPost from \"./components/BolgPost\";export default &#123; name: \"App\", components: &#123; BlogPost, &#125;, data() &#123; return &#123; title: \"Blog\", &#125;; &#125;,&#125;;&lt;/script&gt; BlogPost.vue 12345678910&lt;template&gt; &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"BlogPost\", props: [\"title\"],&#125;;&lt;/script&gt; 单个根元素 值得注意的是，每个组件必须只有一个 根元素。在开发时，可以使用一个父元素统一将模板内容包裹。prop 太多也需要对数据进行重构，以保证内容的清晰和易维护。 一个好的例子： BlogPost.vue 12345678910111213141516171819&lt;template&gt; &lt;div class=\"blog-container\"&gt; &lt;h3&gt;&#123;&#123; params.title &#125;&#125;&lt;/h3&gt; &lt;div&gt;&#123;&#123; params.author &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"BlogPost\", props: &#123; params: &#123; type: Object, required: true, default: () =&gt; (&#123;&#125;), &#125;, &#125;,&#125;;&lt;/script&gt; App.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=\"app\"&gt; &lt;BlogPost :params=\"paramsData\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BlogPost from \"./components/BolgPost\";export default &#123; name: \"App\", components: &#123; BlogPost, &#125;, data() &#123; return &#123; paramsData: &#123; title: \"Blog\", author: \"Akashi\", &#125;, &#125;; &#125;,&#125;;&lt;/script&gt; 监听子组件事件 在开发中，不仅仅需要自上而下从父组件向子组件传递数据，同时也会有子组件向父组件进行沟通的需求。 为保证单向数据流，自然是不允许子组件直接修改父组件的数据，造成数据的维护困难。这里就要引出自定义事件对子组件进行监听： 父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件： App.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=\"app\"&gt; &lt;BlogPost :params=\"paramsData\" @enlarge-text=\"enlargeText\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BlogPost from \"./components/BolgPost\";export default &#123; name: \"App\", components: &#123; BlogPost, &#125;, data() &#123; return &#123; paramsData: &#123; title: \"Blog\", author: \"Akashi\", style: &#123; fontSize: 1, &#125;, &#125;, &#125;; &#125;, methods: &#123; enlargeText() &#123; this.paramsData.style.fontSize += 0.1; &#125;, &#125;,&#125;;&lt;/script&gt; 同时子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件： BlogPost.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div :style=\"styles\"&gt; &lt;h3&gt;&#123;&#123; params.title &#125;&#125;&lt;/h3&gt; &lt;div&gt;&#123;&#123; params.author &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt;Enlarge text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"BlogPost\", props: &#123; params: &#123; type: Object, required: true, default: () =&gt; (&#123;&#125;), &#125;, &#125;, computed: &#123; styles() &#123; return &#123; fontSize: this.params.style.fontSize + \"em\", &#125;; &#125;, &#125;, methods: &#123; onClick() &#123; this.$emit(\"enlarge-text\"); &#125;, &#125;,&#125;;&lt;/script&gt; 使用事件抛出一个值有时候需要向上传递一个特殊的值，这时可以使用 $emit 的第二个参数来提供这个值： BlogPost.vue 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div :style=\"styles\"&gt; &lt;h3&gt;&#123;&#123; params.title &#125;&#125;&lt;/h3&gt; &lt;div&gt;&#123;&#123; params.author &#125;&#125;&lt;/div&gt; &lt;button @click=\"onClick\"&gt;Enlarge text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"BlogPost\", props: &#123; params: &#123; type: Object, required: true, default: () =&gt; (&#123;&#125;), &#125;, &#125;, computed: &#123; styles() &#123; return &#123; fontSize: this.params.style.fontSize + \"em\", &#125;; &#125;, &#125;, data() &#123; return &#123; count: 0.1 &#125; &#125;, methods: &#123; onClick() &#123; this.$emit(\"enlarge-text\", this.count++); &#125;, &#125;,&#125;;&lt;/script&gt; 这时，父组件在监听这个事件的时候，可以通过 $event 访问到被抛出的这个值： App.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=\"app\"&gt; &lt;BlogPost :params=\"paramsData\" @enlarge-text=\"enlargeText\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BlogPost from \"./components/BolgPost\";export default &#123; name: \"App\", components: &#123; BlogPost, &#125;, data() &#123; return &#123; paramsData: &#123; title: \"Blog\", author: \"Akashi\", style: &#123; fontSize: 1, &#125;, &#125;, &#125;; &#125;, methods: &#123; enlargeText(e) &#123; this.paramsData.style.fontSize += e; &#125;, &#125;,&#125;;&lt;/script&gt; 在组件上使用 v-model 自定义事件也可以用于创建支持 v-model 的自定义输入组件。 123456789101112131415161718&lt;template&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"text\"&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"App\", data() &#123; return &#123; text: \"\", &#125;; &#125;,&#125;;&lt;/script&gt; 等价于： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" :value=\"text\" @input=\"onInput\" &gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"App\", data() &#123; return &#123; text: \"\", &#125;; &#125;, methods: &#123; onInput(e) &#123; this.text = e.target.value; &#125;, &#125;,&#125;;&lt;/script&gt; 为了让组件正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value attribute 绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;input type=\"text\" :value=\"value\" @input=\"onInput($event)\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"CustomInput\", props: &#123; value: &#123; default: \"\" &#125; &#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123; onInput(e) &#123; this.$emit(\"input\", e.target.value); &#125;, &#125;,&#125;;&lt;/script&gt; 这样就可以在组件上使用 v-model。 12345678910111213141516171819202122&lt;template&gt; &lt;div id=\"app\"&gt; &lt;CustomInput v-model=\"text\" /&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CustomInput from \"./components/CustomInput\"export default &#123; name: \"App\", components: &#123; CustomInput, &#125;, data() &#123; return &#123; text: \"\", &#125;; &#125;,&#125;;&lt;/script&gt; 通过插槽分发内容有时父组件需要动态的向一个子组件传递内容。 这时可以使用 slot 插槽在子组件中进行占位： ContextBox.vue 123456789101112&lt;template&gt; &lt;div&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"ContextBox\",&#125;;&lt;/script&gt; 然后在父组件中可以直接将节点内容传递过去： App.vue 12345678910111213141516&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ContextBox&gt;Something bad happened.&lt;/ContextBox&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ContextBox from \"./components/ContextBox\";export default &#123; name: \"App\", components: &#123; ContextBox, &#125;,&#125;;&lt;/script&gt; 实际上插槽还有具名插槽和作用域插槽等，这里暂时先只介绍一般插槽的使用。 动态组件在一个需求中，需要在不同的组件之间动态的进行切换，这时可以通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is attribute 来实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=\"app\"&gt; &lt;button v-for=\"tab in tabs\" :key=\"tab.name\" @click=\"onClick(tab.component)\" &gt;&#123;&#123; tab.name &#125;&#125;&lt;/button&gt; &lt;component :is=\"currentTab\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Home from \"./components/Home\";import About from \"./components/About\";export default &#123; name: \"App\", components: &#123; Home, About, &#125;, data() &#123; return &#123; tabs: [ &#123; name: \"Home\", component: Home, &#125;, &#123; name: \"About\", component: About, &#125;, ], currentTab: \"Home\", &#125;; &#125;, methods: &#123; onClick(tab) &#123; this.currentTab = tab; &#125;, &#125;,&#125;;&lt;/script&gt; is 属性指明了被绑定的组件，这个 attribute 可以用于常规 HTML 元素，但这些元素也将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。 以上就是 Vue 官方文档中使用 vue 的基础介绍梳理。在重看整理的同时也加入了一些笔者常用内容的记录、对官方的例子进行了具体实现。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"}]},{"title":"Cesium 上手不完全指北","slug":"cesium/cesium","date":"2020-07-31T16:00:00.000Z","updated":"2020-10-06T11:18:57.446Z","comments":true,"path":"2020/08/01/cesium/cesium/","link":"","permalink":"http://akashigakki.github.io/2020/08/01/cesium/cesium/","excerpt":"Cesium 上手不完全指北 将最近学习的 CesiumJS 做一个系统梳理，从项目配置开始，记录常用 API 的使用。","text":"Cesium 上手不完全指北 将最近学习的 CesiumJS 做一个系统梳理，从项目配置开始，记录常用 API 的使用。 环境搭建与安装首先，什么是 Cesium，Cesium 是一款开源的基于 JavaScript 的 3D 地图框架，即地图可视化框架。产品基于 WebGL 技术，我们可以使用 CesiumJS 创建虚拟场景的 3D 地理信息平台。其目标是用于创建以基于 Web 的地图动态数据可视化。在提升平台的性能、准确率、虚拟化能力、易用性方面提供各种支持。 更多介绍和信息可通过官网进行学习。 注册Cesium ion 是一个提供瓦片图和 3D 地理空间数据的平台，Cesium ion 支持把数据添加到用户自己的 CesiumJS 应用中。使用二三维贴图和世界地形都需要 ion 的支持，如果没有自己的数据源需要 cesium 提供的数据源就需要申请 ion 的 token，具体可以通过以下链接申请 access token。 在创建 Cesium Viewer 的时候，将 access token 填为自己的 access token 即可。 1Cesium.Ion.defaultAccessToken = '&lt;YOUR ACCESS TOKEN HERE&gt;'; 项目搭建进入项目搭建过程，项目选择在 Vue 平台上进行实现，首先创建项目安装 cesium 库： 123vue create cesium-vuecd cesium-vuenpm i cesium@1.61 --save 注意：目前使用 webpack 进行配置引用最新版本(1.71) cesium 暂时不能导入，实测 `cesium@1.61版本可以进行import` 导入。 项目配置根目录下新建 vue.config.js 配置文件，对项目进行基本配置： 12345678910111213141516171819202122232425262728293031323334353637const CopyWebpackPlugin = require('copy-webpack-plugin')const webpack = require('webpack')const path = require('path')const debug = process.env.NODE_ENV !== 'production'let cesiumSource = './node_modules/cesium/Source'let cesiumWorkers = '../Build/Cesium/Workers'module.exports = &#123; publicPath: '', devServer: &#123; port: 9999 &#125;, configureWebpack: &#123; output: &#123; sourcePrefix: ' ' &#125;, amd: &#123; toUrlUndefined: true &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': path.resolve('src'), 'cesium': path.resolve(__dirname, cesiumSource) &#125; &#125;, plugins: [ new CopyWebpackPlugin([&#123; from: path.join(cesiumSource, cesiumWorkers), to: 'Workers'&#125;]), new CopyWebpackPlugin([&#123; from: path.join(cesiumSource, 'Assets'), to: 'Assets'&#125;]), new CopyWebpackPlugin([&#123; from: path.join(cesiumSource, 'Widgets'), to: 'Widgets'&#125;]), new CopyWebpackPlugin([&#123; from: path.join(cesiumSource, 'ThirdParty/Workers'), to: 'ThirdParty/Workers'&#125;]), new webpack.DefinePlugin(&#123; CESIUM_BASE_URL: JSON.stringify('./') &#125;), new CopyWebpackPlugin([&#123; from: path.join('./static', 'model'), to: 'model3D' &#125;]), new CopyWebpackPlugin([&#123; from: path.join('./static', 'images'), to: 'images' &#125;]) ] &#125;&#125; 在根目录下创建 static 文件夹用于后续 model 和 images 的存放。 组件实现在 src/components/ 下新建 CesiumViewer.vue 进行组件实现： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Cesium from 'cesium/Cesium'import 'cesium/Widgets/widgets.css'export default &#123; name: 'CesiumViewer', mounted () &#123; // token Cesium.Ion.defaultAccessToken = 'your token'; let viewer = new Cesium.Viewer('cesiumContainer'); &#125;, methods: &#123;&#125;&#125;&lt;/script&gt;&lt;style&gt;#cesiumContainer &#123; display: block; position: absolute; top: 0; left: 0; border: none; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 可以看到地图在调用 Cesium 的 Viewer 时开始构建。Viewer 是 Cesium API 的起点，new Viewer 后便可以看见地球对象。 组件声明在 App.vue 中引用组件： 123456789101112131415&lt;template&gt; &lt;div id=\"app\"&gt; &lt;CesiumViewer&gt;&lt;/CesiumViewer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CesiumViewer from './components/CesiumViewer'export default &#123; name: 'App', components: &#123; CesiumViewer &#125;&#125;&lt;/script&gt; 运行查看效果： 1npm run serve 此时，已经可以看见最开始的地球🌏效果，我们进行一些简单配置和调整： 123456789101112131415161718192021222324252627282930313233&lt;script&gt;import Cesium from 'cesium/Cesium'import 'cesium/Widgets/widgets.css'export default &#123; name: 'CesiumViewer', mounted () &#123; this.init(); &#125;, methods: &#123; init () &#123; let viewerOption = &#123; geocoder: false, // 地理位置搜索控件 homeButton: false, // 首页跳转控件 sceneModePicker: false, // 2D,3D和Columbus View切换控件 baseLayerPicker: false, // 三维地图底图切换控件 navigationHelpButton: false, // 帮助提示控件 animation: false, // 视图动画播放速度控件 timeline: false, // 时间轴控件 fullscreenButton: false, // 全屏控件 infoBox: false, // 点击显示窗口控件 selectionIndicator: false, // 实体对象选择框控件 scene3DOnly: true // 仅3D渲染，节省GPU内存 &#125; // token Cesium.Ion.defaultAccessToken = 'your token'; let viewer = new Cesium.Viewer('cesiumContainer', viewerOption); // 隐藏Logo viewer.cesiumWidget.creditContainer.style.display = \"none\"; &#125; &#125;&#125;&lt;/script&gt; 1npm run serve 最终效果如下： 至此，最开始的构建运行就已经完成了，下面对具体 API 进行学习。 Imagery 图层开始 API 学习之前，为了方便方法实现，使用 ref 在元素上注册一个引用信息，方便通过 ID 直接访问一个子组件实例。 修改如下，引用信息将会注册在父组件的 $refs 对象上，子组件通过 this.$viewer 进行访问。 这里引入图层的概念(Imagery)，瓦片图集合根据不同的投影方式映射到虚拟的三维数字地球表面。依赖于相机指向地表的方向和距离，Cesium 会去请求和渲染不同层级的图层详细信息。 详细代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div id=\"cesiumContainer\" ref=\"viewer\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Cesium from 'cesium/Cesium'import 'cesium/Widgets/widgets.css'export default &#123; name: 'CesiumViewer', mounted () &#123; // 初始化 this.init(); // 添加图层 this.addLayers(); &#125;, methods: &#123; // 初始化 init () &#123; let viewerOption = &#123;...&#125; // token Cesium.Ion.defaultAccessToken = 'your token'; this.$viewer = new Cesium.Viewer(this.$refs.viewer, viewerOption); this.$viewer.cesiumWidget.creditContainer.style.display = \"none\"; &#125;, // 添加 `Imagery` (图层) addLayers () &#123; // Remove default base layer // this.$viewer.imageryLayers.remove(this.$viewer.imageryLayers.get(0)); // Add grid imagery this.$viewer.imageryLayers.addImageryProvider(new Cesium.GridImageryProvider()); &#125; &#125;&#125;&lt;/script&gt; 原理上和 PS 的图层一致，多个图层可以添加、移除和排序，渲染并适应到 Cesium 中。 Terrain 地形Cesium 的地形图层支持渐进式加载和渲染全球高精度地图，并且包括地形地势、水形数据，包括海洋、湖泊、河流、山峰、峡谷等效果。 为了添加地形数据，我们需要创建一个 CesiumTerrainProvider，通过 createWorldTerrain 函数创建一个由 Cesium ion 提供服务的 Cesium WorldTerrian，同时可提供配置项，请求额外的水和光数据，最终我们通过 camera 下的函数定位到创建的位置进行查看： 123456789101112131415161718192021222324252627282930313233343536373839404142export default &#123; name: \"CesiumViewer\", mounted() &#123; // 初始化 this.init(); // 添加图层 // this.addLayers(); // 添加地形 this.addTerrain(); &#125;, methods: &#123; // 初始化 init() &#123;...&#125;, // 添加图层 addLayers() &#123;...&#125;, // 添加地形 addTerrain() &#123; this.$viewer.terrainProvider = Cesium.createWorldTerrain(&#123; requestWaterMask: true, // required for water effects requestVertexNormals: true, // required for terrain lighting &#125;); // Enable depth testing so things behind the terrain disappear. this.$viewer.scene.globe.depthTestAgainstTerrain = true; this.$viewer.scene.camera.flyTo(&#123; destination: Cesium.Cartesian3.fromRadians( -2.6399828792482234, 1.0993550795541742, 5795 ), orientation: &#123; heading: 3.8455, pitch: -0.4535, roll: 0.0, &#125;, &#125;); &#125;, &#125;&#125; Viewer 控件回到最开始的调整配置上，我们在 viewerOption 中对 Viewer 声明的一系列基本小控件做了移除和优化操作，具体 API 官方给出了如下描述： Geocoder : A location search tool that flies the camera to queried location. Uses Bing Maps data by default. HomeButton : Flies the viewer back to a default view. SceneModePicker : Switches between 3D, 2D and Columbus View (CV) modes. BaseLayerPicker : Chooses the imagery and terrain to display on the globe. NavigationHelpButton : Displays the default camera controls. Animation : Controls the play speed for view animation. CreditsDisplay : Displays data attributions. Almost always required! Timeline : Indicates current time and allows users to jump to a specific time using the scrubber. FullscreenButton : Makes the Viewer fullscreen. 我们可以根据自身需求选择是否启用。 官方描述地址 同时我们还可以对视窗进行配置，到达自己期望的效果，如开启根据动态时间激活太阳位置的光照，对真实地球进行模拟： 12345678910111213141516171819202122232425export default &#123; name: \"CesiumViewer\", mounted() &#123; // 初始化 this.init(); // 添加图层 // this.addLayers(); // 添加地形 // this.addTerrain(); // 配置视窗 this.configScene(); &#125;, methods: &#123; // 初始化 init() &#123;...&#125;, // 配置视窗 configScene() &#123; // Enable lighting based on sun/moon positions(激活基于太阳位置的光照) this.$viewer.scene.globe.enableLighting = true; &#125;, &#125;&#125; 更近一步，可以利用上一小节使用的 camera 实现主视窗的定位： 123456789101112131415161718192021222324252627// 配置视窗configScene() &#123; // Enable lighting based on sun/moon positions(激活基于太阳位置的光照) this.$viewer.scene.globe.enableLighting = true; // Create an initial camera view let initialPosition = new Cesium.Cartesian3.fromDegrees( -73.998114468289017509, 40.674512895646692812, 2631.082799425431 ); let initialOrientation = new Cesium.HeadingPitchRoll.fromDegrees( 7.1077496389876024807, -31.987223091598949054, 0.025883251314954971306 ); let homeCameraView = &#123; destination: initialPosition, orientation: &#123; heading: initialOrientation.heading, pitch: initialOrientation.pitch, roll: initialOrientation.roll, &#125;, &#125;; // Set the initial view this.$viewer.scene.camera.setView(homeCameraView);&#125;, 这里需要介绍的是 Scene 的概念，Scence 虚拟场景是所有3D 图形对象和状态的容器，通常不是由开发者直接创建，而是在 Viewer 或者 CesiumWidget 内部隐式创建的。 通过 Scene 场景，我们可以控制 Globe 地球(包括地形和图层)、Camera 相机、Primitives (默认矢量数据层)和 PostProcessStage (后期处理效果)等。 除了以上配置，现在我们需要了解的有以下 Cesium 基本类型的 API: Cartesian3 : 一个三维笛卡尔坐标——当它被用作相对于地球中心的位置时，使用地球固定框架（ECEF）。 Cartographic : 由经度、纬度（弧度）和 WGS84 椭球面高度确定的位置。 HeadingPitchRoll : 在东北向上的框架中关于局部轴的旋转（弧度）。航向是围绕负 Z 轴的旋转。俯仰是围绕负 Y 轴的旋转。滚动是关于正 X 轴的旋转。 Quaternion :以 4D 坐标表示的 3D 旋转。 Camera 相机Camera 是 Cesium 中常用的 API，属于 viewer.scene 中的属性，用来控制当前可见的域。可以控制场景的观察视角，例如旋转、缩放、平移以及飞行定位。 一些最常用的方法如下： Camera.setView(options): 在特定位置和方向立即设置相机。 Camera.zoomIn(amount): 沿着视角矢量移动摄像机。 Camera.zoomOut(amount): 沿视角矢量向后移动摄像机。 Camera.flyTo(options): 创建从当前相机位置到新位置的动画相机飞行。 Camera.lookAt(target, offset): 定位并定位摄像机以给定偏移量瞄准目标点。 Camera.move(direction, amount): 朝任何方向移动摄像机。 Camera.rotate(axis, angle): 绕任意轴旋转相机。 例子参考上一小节的视窗定位。 Clock 时钟使用 viewer 的 Clock 和 Timline 可以控制 scene 的时间进度。 下面通过修改 init 函数实现一个日夜交替效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export default &#123; name: \"CesiumViewer\", mounted() &#123; // 初始化 this.init(); &#125;, methods: &#123; // 初始化 init() &#123; let clock = new Cesium.Clock(&#123; startTime: Cesium.JulianDate.now(), currentTime: Cesium.JulianDate.now(), stopTime: Cesium.JulianDate.addDays(Cesium.JulianDate.now(), 1, new Cesium.JulianDate()), clockRange: Cesium.ClockRange.LOOP_STOP, clockStep: Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER, multiplier: 9000, shouldAnimate: true &#125;); let viewerOption = &#123; geocoder: false, homeButton: false, sceneModePicker: false, baseLayerPicker: false, navigationHelpButton: false, animation: false, timeline: false, fullscreenButton: false, infoBox: false, selectionIndicator: false, scene3DOnly: true, shadows: true, shouldAnimate: true, clockViewModel: new Cesium.ClockViewModel(clock) &#125;; // your token Cesium.Ion.defaultAccessToken = \"token\"; this.$viewer = new Cesium.Viewer(this.$refs.viewer, viewerOption); // 隐藏Logo this.$viewer.cesiumWidget.creditContainer.style.display = \"none\"; this.$viewer.scene.globe.enableLighting = true; &#125;, &#125;&#125; 通过定义 clock，设置起始时间、速率和循环等配置，使用 clockViewModel 在实例中添加时钟视图模型，然后启用光照，实现效果。 注：此效果为演示，init 函数后续恢复为开始的创建实例状态，方便之后的例子使用。 Entity 实体Cesium 中的所有空间数据都使用 Entity API来表示。Entity API 以一种有效提供灵活的可视化的方式，以便对 Cesium 进行渲染。Cesium Entity 是可以与样式化图形表示配对并定位在空间和时间上的数据对象。 在 Cesium 中，加载点线面矢量有两种方式： Entity API 是数据驱动的一组高级对象，具有接口一致，容易使用的特点，但性能略低。 Primitive API 是面向三维图形开发，更为底层，具有灵活，性能高的特点，但使用复杂。 其中，Entity API 的使用通过 viewer.entities.add() 方法添加矢量数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export default &#123; name: \"CesiumViewer\", mounted() &#123; // 初始化 this.init(); // 加载实体 this.loadEntities(); &#125;, methods: &#123; // 初始化 init() &#123;...&#125;, loadEntities() &#123; let polygon = this.$viewer.entities.add(&#123; name: \"正方形\", id: \"square\", polygon: &#123; hierarchy: Cesium.Cartesian3.fromDegreesArray([ -109.080842, 45.002073, -105.91517, 45.002073, -104.058488, 44.996596, -104.053011, 43.002989, -104.053011, 41.003906, -105.728954, 40.998429, -107.919731, 41.003906, -109.04798, 40.998429, -111.047063, 40.998429, -111.047063, 42.000709, -111.047063, 44.476286, -111.05254, 45.002073, ]), height: 0, material: Cesium.Color.RED.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.BLACK, &#125;, &#125;); this.$viewer.zoomTo(polygon); // polygon.show = false; &#125; &#125;&#125; 效果如下： 除了绘制实体，还可以通过外部加载的方式进行模型导入。 这里我们在 static 文件夹下放入 J15.glb 文件进行导入： 123456789101112131415161718192021222324252627export default &#123; name: \"CesiumViewer\", mounted() &#123; // 初始化 this.init(); // 添加模型 this.addEntities(); &#125;, methods: &#123; // 初始化 init() &#123;...&#125;, addEntities() &#123; let fighter = this.$viewer.entities.add(&#123; name: \"fighter\", id: \"J15\", model: &#123; uri: \"model3D/J15.glb\", minimumPixelSize: 100, maximumScale: 1000, &#125;, position: Cesium.Cartesian3.fromDegrees(-110.345, 30, 70000), &#125;); // this.$viewer.trackedEntity = fighter; this.$viewer.zoomTo(fighter, new Cesium.HeadingPitchRange(-1, -0.3, 35)); &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"Cesium","slug":"Cesium","permalink":"http://akashigakki.github.io/tags/Cesium/"}]},{"title":"Django 项目 Linux 远程部署记录","slug":"django-deploy/deploy-django","date":"2020-05-30T16:00:00.000Z","updated":"2020-10-06T11:19:33.003Z","comments":true,"path":"2020/05/31/django-deploy/deploy-django/","link":"","permalink":"http://akashigakki.github.io/2020/05/31/django-deploy/deploy-django/","excerpt":"Django 项目 Linux 远程部署记录 Django 项目部署。该项目名称为 shop-search，配置端口号为 9000，以下为配置过程记录。","text":"Django 项目 Linux 远程部署记录 Django 项目部署。该项目名称为 shop-search，配置端口号为 9000，以下为配置过程记录。 远程拷贝项目文件1scp -r ~/Source/Project/Python/shop-search root@122.51.xx.xx:/source/python/deployment/ 远程账号登录1ssh akashi@122.51.xx.xx 注意：项目最终部署时最好不要使用 root 用户部署。root 权限过高，直接部署项目存在安全隐患。 注意：IP 地址已隐去部分：xx.xx，参考时填写自己对应地址，以下相应隐去内容不再做提示。 远程虚拟环境启动在对应项目下启动虚拟环境： 12pipenv shellpipenv install 同步、迁移数据表项目数据库之前已经在远程创建完成，这里不再介绍，可使用 mysqldump 对数据进行快速导入导出操作。 基本数据库操作命令： 12345678910111213141516171819202122# 登录mysql -uroot -pxxx# 显示数据库列表show databases;# 选择并打开库use xxx;# 显示表show tables;# 建库create database 库名;# 建表：use 库名；create table 表名 (字段设定列表)；# 删库和删表:drop database 库名;drop table 表名； 一些参考： mysqldump mongodb迁移mysql Django连接mysql 使用 Django 命令同步和迁移数据库。 在迁移过程中如果出现报错 django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.13 or newer is required; you have 0.9.3. 是因为 2.x以后 Django 版本兼容性导致。 原因参考文档. 目前比较好的解决方案就是做一个版本欺骗，简单高效。在 apps 下对应作用目录中的 __init__.py 中添加： 123import pymysqlpymysql.version_info = (1, 3, 13, \"final\", 0)pymysql.install_as_MySQLdb() 同时安装对应依赖： 1pipenv install pymysql 进行同步迁移数据表： 12python manage.py makemigrationspython manage.py migrate uwsgi 项目启动使用 uwsgi 对项目进行启动： 1uwsgi --http-socket :9000 --plugin python --module shop-search.wsgi 若无报错，结束启动状态。配置后台启动文件。 ini 文件配置在项目根目录下新建配置文件 shop-search-uwsgi.ini 进行配置： 12touch shop-search-uwsgi.inisudo vim shop-search-uwsgi.ini 配置如下： 1234567891011121314151617181920212223# 配置域[uwsgi]# 工作目录chdir = /source/python/deployment/shop-search# 模块module = shop-search.wsgi# 请求端口http-socket = :9000# mastermaster = True# 进程processes = 4# 线程threads = 1# 是否退出是清理相关内容vacuum = true 配置 log 和 pid新建日志文件和 pid 存储位置： 1mkdir log &amp;&amp; mkdir pid 在 shop-search-uwsgi.ini 中添加对应配置，用于后台启动和停止。 1234# backend run uwsgidaemonize = %(chdir)/log/uwsgi-9000.loglog-maxsize = 1024*1024*1024pidfile = %(chdir)/pid/uwsgi-9000.pid 启动1sudo uwsgi --ini shop-search.ini 启动后可对后台运行进程进行查看： 1ps -aux | grep shop-search 注意：本项目依赖虚拟环境，需在虚拟环境中启动才能启动成功，注意查看虚拟环境是否开启，如果是使用远程主机本地环境，则可以忽略。 启动完成后退出虚拟环境： 1exit 配置 Nginx启动 nginx 1sudo nginx 在对应 nginx 安装目录下修改配置文件 nginx.conf 以下是我的路径参考： 12cd /etc/nginxsudo vim nginx.conf 在 http 下添加配置： 注意：在 60 多行左右，可以在 vim 下输入 :set nu 显示行数。 123456789101112131415161718# Shop-Search Site Configupstream shop-search &#123; server 122.51.xx.xx:9000;&#125;server &#123; listen 80; server_name search.akashi.xx; charset utf-8; access_log /var/log/nginx/nginx.log; location / &#123; proxy_pass http://shop-search; &#125; location /static &#123; alias /source/python/deployment/shop-search/static; &#125;&#125; 配置完成，重启 nginx： 1sudo nginx -s reload 更多 nginx 配置，如加密部署、部署高可用服务等可参考我的另一篇文章：Python 应用 uWSGI + Nginx 部署. 至此，项目远程部署完成。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Nginx","slug":"Nginx","permalink":"http://akashigakki.github.io/tags/Nginx/"}]},{"title":"Vue.js 阅读笔记（四）","slug":"vue-webpack/webpack-vue","date":"2020-01-13T16:00:00.000Z","updated":"2020-10-06T11:15:40.925Z","comments":true,"path":"2020/01/14/vue-webpack/webpack-vue/","link":"","permalink":"http://akashigakki.github.io/2020/01/14/vue-webpack/webpack-vue/","excerpt":"Vue.js 阅读笔记（四） 系统、框架性的认识 Vue。webpack、vue-router、vuex 和工程化。","text":"Vue.js 阅读笔记（四） 系统、框架性的认识 Vue。webpack、vue-router、vuex 和工程化。 高效开发离不开基础工程的搭建，开始之前需要提前安装 Node.js 和 NPM，如果不熟悉它们，可以先查阅相关资料，完成安装并了解 npm 最基本的用法。 前端工程化和 webpack近几年来，前端领域发展迅速，前端的工作早已不再是切几张图那么简单，项目比较大时，可能会多人协同开发。模块化、组件化、CSS 预编译等概念也成了经常讨论的话题。 webpack通常，前端工程化项目需要解决以下问题： JavaScript、CSS 代码的合并和压缩。 CSS 预处理：Less、Sass、Stylus 的编译。 生成雪碧图 (CSS Sprite) ES6 转 ES5 模块化 .... 这些问题，我们都可以通过前端模块打包提供一个解决方案，也就是 webpack。打包后的代码已经不是你写的代码，其中夹杂了很多 webpack 自身的模块处理代码，需要理解 编译 的概念。 在左边的是业务中写的各种格式的文件，比如 typescript、less、jpg、vue 等，这些格式的文件通过特定的加载器(Loader)编译以后，最终统一生成为 .js、.css、.png 等静态资源文件。 在 webpack 中，一张图片，一个 css甚至一个字体，都称为模块(Module)，彼此存在依赖关系，webpack 就是来处理模块间的依赖关系的，并把它们进行打包。 在 webpack 中加载文件，是在 .js 文件中导入，如： 1import 'src/styles/index.css'; import 是在 ES 2015 中的使用，这里也可以写成： 1require('src/styles/index.css') 在打包时，index.css 会被打包进一个 .js 文件中，通过动态创建 &lt;style&gt; 的形式来加载，当然，也可以进一步配置，在打包编译时，把所有的 css 文件提取出来，生成一个 css 的文件。 SPAwebpack 的主要适用场景是单页面应用(SPA)，SPA 通常是由一个 html 文件和一堆按需加载的 js 文件组成，它的 html 结构非常简单，比如： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;webpack app&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"dist/main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"dist/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 只有一个 &lt;div&gt; 节点，所有的代码都集成在了 main.js 中，理论上它可以实现知乎、淘宝这样的大型项目。 export 和 import这两个语法是在编写模块化项目中大量使用的，是 ES6 中的语法，需要做一些简单的了解。 export 和 import 是用来导出和导入模块的，一个模块就是一个 js 文件，它拥有独立的作用域，里面定义的变量外部是无法获取的。 比如将一个配置文件作为模块导出： 12345678// config.jsvar Config = &#123; version: '1.0.0'&#125;;export &#123; Config&#125;; 或 1234// config.jsexport var Config = &#123; version: '1.0.0'&#125;; 其中，无论是 变量，函数，数组，常量 都可以导出。 导出模块后，在需要使用模块的文件使用 import 再导入，就可以在这个文件内使用这些模块了。 1234// main.jsimport &#123; Config &#125; from './config.js';console.log(Config) // &#123; version: '1.0.0' &#125; 在以上几个例子中，导入的模块都是在 export 文件中设置的，也就是说用户必须预先知道这个名称叫什么，比如 Config。而有时候用户不想去了解名称是什么，只是把模块的功能拿来使用，或者想自己自定义名称，这时可以使用 export default 来输出默认的模块。 1234// config.jsexport default &#123; version: '1.0.0'&#125;; 1234// main.jsimport conf from './config.js';console.log(conf); // &#123; version: '1.0.0' &#125; 当然，你也可以规定默认模块的名称： 123456// config.jsvar config = &#123; version: '1.0.0'&#125;;module.exports = config; 这里的 module.exports = config; 相当于 export default config;。 Vue CLI Vue CLI 是一个基于 Vue.js 进行快速开发的项目脚手架，基于 webpack 构建。 安装1npm install -g @vue/cli 安装完成之后，就可以在命令行中访问 vue 命令，比如可以用来检查版本验证是否安装成功： 1vue --version 快速原型开发可以使用 vue serve 和 vue build 命令对单个 *.vue 文件进行快速原型开发，不过这需要先额外安装一个全局的扩展： 1npm install -g @vue/cli-service-global 注意，这仅仅用于简单的快速测试，实际开发中并不推荐。 使用 Vue CLI 手脚架快速搭建一个工程化项目 创建一个新项目 1vue create demo 开始创建，提示选取一个预设，可以使用默认的预设，这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。 等待创建完成之后，就可以根据提示，进入项目，启动服务： 12cd demonpm run serve 这样，一个新建的工程化项目就在对应的端口下启动了，可以根据提示在浏览器查看启动的项目。 前端路由与 vue-router前端路由前端路由，即前端来维护一个路由规则。 实现有两种，一种是利用 url 的 hash，就是常说的锚点(#)，JavaScript 通过 hashChange 事件来监听 url 的改变，IE7 以下需要轮询； 另一种就是 HTML5 的 History 模式。它使 url 看起来像普通网站那样，以 / 分隔，但页面并没有跳转，不过使用这种模式需要服务端支持，服务端在接收到所有的请求后，都将指向同一个 html 不然会出现 404。因此，SPA 只有一个 html，整个网站的所有内容都在一个 html 里，通过 JavaScript 来处理。 前端路由可以带来页面的持久性、前后端彻底分离等优势，下面结合具体的框架 vue-router 进行介绍。 vue-router 安装1npm install --save vue-router 如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能： 1234import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter) 基本使用每个页面对应一个组件，也就是对应一个 .vue 文件。在 src 目录下创建 views 目录，用于存放所有的页面，然后在 views 下创建 index.vue 和 about.vue 两个文件。 1234567891011121314&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt;Index&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index'&#125;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt; 1234567891011121314&lt;!-- about.vue --&gt;&lt;template&gt; &lt;div&gt;About&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'about'&#125;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt; 回到 main.js 中进行配置，创建一个数组来制定路由匹配列表，每一个路由映射一个组件： 12345678910111213141516171819202122232425262728293031// main.jsimport Vue from 'vue'import App from './App.vue'import VueRouter from 'vue-router'Vue.use(VueRouter);Vue.config.productionTip = falseconst Routers = [&#123; path: '/index', name: 'index', component: (resolve) =&gt; require(['./views/index.vue'], resolve) // component: () =&gt; import('./views/index.vue') &#125;, &#123; path: '/about', name: 'about', component: (resolve) =&gt; require(['./views/about.vue'], resolve) &#125;];const router = new VueRouter(&#123; mode: 'history', routes: Routers&#125;);new Vue(&#123; router: router, render: h =&gt; h(App),&#125;).$mount('#app') Routers 里每一项的 path 属性就是指定的当前匹配的路径，component 是映射的组件。 webpack 会把每一个路由打包成一个 js 文件，在请求到该页面时，才会去加载这个页面的 js，也就是异步实现的懒加载(按需加载) 这样做的好处是不需要在打开首页的时候就把所有的页面内容全部加载进来，只在访问时才加载。 如果非要一次性加载，可以写为： 1234&#123; path: '/index', component: require('./views/index.vue')&#125; 最后，在根实例 app.vue 中添加一个路由视图 &lt;router-view&gt; 来挂载所有的路由组件： 1234567891011&lt;!-- app.vue --&gt;&lt;template&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app',&#125;&lt;/script&gt; &lt;router-view&gt; 会根据当前路由动态渲染不同的页面组件。网页中一些公共的部分，比如顶部的导航栏、侧边导航栏、底部的版权信息，这些可以直接写在 app.vue 里面，与 &lt;router-view&gt; 同级，路由切换时，切换的是 &lt;router-view&gt; 挂载的组件，其他内容不会发生变化。 npm run serve 启动服务，就可以通过 127.0.0.1:8080/index 和 127.0.0.1:8080/about 访问页面了。 结构梳理现在新建一个 router 目录，用于路由配置。 router 下新建 index.js 将路由部分从 main.js 中提出： 1234567891011121314151617181920212223242526// router/index.jsimport Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter);const Routers = [&#123; path: '*', redirect: '/index' &#125;, &#123; path: '/index', name: 'index', component: (resolve) =&gt; require(['../views/index.vue'], resolve) &#125;, &#123; path: '/about', name: 'about', component: (resolve) =&gt; require(['../views/about.vue'], resolve) &#125;];const router = new VueRouter(&#123; mode: 'history', routes: Routers&#125;);export default router 在路由列表中添加一项，用于访问路径不存在时，重定向到首页： 1234&#123; path: '*', redirect: '/index'&#125; 精简后的 main.js 1234567891011// main.jsimport Vue from 'vue'import App from './App.vue'import router from './router/index'Vue.config.productionTip = falsenew Vue(&#123; router, render: h =&gt; h(App),&#125;).$mount('#app') 路由列表的 path 也可以带参数，比如个人主页的场景，一部分路由是动态的 /user/12345，其中 id 是动态的，但是它们都路由到同一个页面，这个页面里面期望获取这个 id，然后请求相关数据。 具体路由参数配置： 12345// main.jsconst Routers = [&#123; path: '/user/:id', component: (resolve) =&gt; require(['../views/user.vue'], resolve)&#125;]; 在 views 下新建 user.vue 文件 12345678910&lt;!-- user.vue --&gt;&lt;template&gt; &lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'user'&#125;&lt;/script&gt; 使用 this.$route 可以访问到当前路由的很多信息，开发中会经常用到里面的数据。 跳转vue-router 有两种跳转页面的方法，第一种是使用内置的 &lt;router-link&gt; 组件，它会被渲染为一个 &lt;a&gt; 标签： 12345678910111213 &lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Index&lt;/div&gt; &lt;router-link to=\"/about\"&gt;about&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index'&#125;&lt;/script&gt; 它的用法和一般组件一样，to 是一个 prop，需要指定跳转的路径，也可以使用 v-bind 动态设置。使用 &lt;router-link&gt;，在 HTML5 的 History 模式下会拦截点击，避免浏览器重新加载页面。 &lt;router-link&gt; 常用 prop: tag 可以指定渲染成什么标签 1&lt;router-link to=\"/about\" tag=\"li\"&gt; replace 使用 replace 不会留下 History 记录，所以不能使用后退键和返回上一个页面 1&lt;router-link to=\"/about\" replace&gt; active-class 对应的路由匹配成功后，会自动给当前元素设置一个名为 router-link-active 的 class，设置 prop: active-class 可以修改默认名称 另一种方法是通过 Javascript 进行设置，类似于 window.location.href，使用 router 实例的方法，通过点击事件进行跳转： 123456789101112131415161718&lt;!-- about.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;About&lt;/div&gt; &lt;button @click=\"handleRouter\"&gt;go to user&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'about', methods: &#123; handleRouter () &#123; this.$router.push('/user/123'); &#125; &#125;&#125;&lt;/script&gt; $router 的其他方法： replace 类似于 &lt;router-link&gt; 的 replace 功能，它不会向 history 添加新记录，而是替换掉当前的 history 记录，如：this.$router.replace(&#39;/user/123&#39;) go 类似于 window.history.go()，在 history 记录中向前或者后退多少步，参数是整数。 12this.$router.go(-1);this.$router.go(2) 高级用法 在 SPA 项目中修改网页标题。 网页标题是通过 &lt;title&gt;&lt;/title&gt; 来显示的，但是 SPA 只有一个固定的 html，切换到不同页面时，标题并不会发生改变，那么该如何修改标题呢？ 比较理想的一个思路是，在页面发生路由变化时，统一设置。vue-router 提供了导航钩子 beforeEach 和 afterEach，它们会在路由即将改变前和改变后触发，所以设置标题可以在 beforeEach 钩子完成。 1234567891011121314151617181920212223242526272829303132333435363738// router/index.jsconst Rourters = [&#123; path: '/index', name: 'index', meta: &#123; title: '首页' &#125;, component: (resolve) =&gt; require(['../views/index.vue'], resolve)&#125;,&#123; path: '/about', name: 'about', meta: &#123; title: '关于' &#125;, component: (resolve) =&gt; require(['../views/about.vue'], resolve)&#125;,&#123; path: '/user:id', name: 'user', meta: &#123; title: '个人主页' &#125;, component: (resolve) =&gt; require(['../views/user.vue'], resolve)&#125;, &#123; path: '*', redirect: '/index'&#125;];const router = new VueRouter(&#123; mode: 'history', routes: Routers&#125;);router.beforeEach((to, from, next) =&gt; &#123; window.document.title = to.meta.title; next();&#125;);export default router 导航钩子有 3 个参数： to 即将要进入的目标的路由对象 from 当前导航即将要离开的路由对象 next 调用该方法后，才能进入下一个钩子 路由列表的 meta 字段可以自定义一些信息，比如将每个页面的 title 写入 meta 来统一维护，beforeEach 钩子可以ongoing路由对象 to 里获取 meta 信息，从而改变标题。 状态管理与 Vuex状态管理与使用场景一个组件可以分为数据(model)和视图(view)，数据更新时，视图也会自动更新。在视图中又可以绑定一些事件，它们触发 methods 里的指定方法，从而可以改变数据、更新视图，这时一个组件基本的运行模式。 但在实际的业务开发中，经常有跨组件共享数据的需求，Vuex 就是用来统一管理组件状态的，它定义的一系列规范来使用和操作数据，使组件应用更加高效。 使用 Vuex 有一定的门槛和复杂性，它的主要使用场景是大型单页应用，更适合多人协同开发。如果项目不是很复杂，或者希望短期内见效，需要考虑是否真的有必要使用 Vuex，一个简单的 store模式 就满足需求了。 Vuex 安装1npm install vuex --save 在一个模块化的打包系统中，必须显式地通过 Vue.use() 来安装 Vuex： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) Vuex 基本使用现在我们从一开始就考虑高效的结构，先新建一个 store 目录，在下面新建 index.js 做状态管理配置： 123456789101112// store/index.jsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; &#125;, mutations: &#123; &#125;,&#125;); 然后在 main.js 里面引入并声明： 12345678910111213// main.jsimport Vue from 'vue'import App from './App.vue'import router from './router/index'import store from './store/index'Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App),&#125;).$mount('#app') 这样，一个基本的 Vuex 框架就构建好了，仓库 store (指 store/index.js) 包含了应用的数据（状态）和操作过程。Vuex 里的数据都是响应式的，任何组件使用同一 store 的数据时，只要 store 的数据发生变化，对应的组件也会立即更新。 数据保存在 Vuex 选项的 state 字段内，想要更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，通过这两个方法，就可以完成大部分数据状态管理的操作，下面通过一个计数器的例子了解 Vuex 的使用。 首先，定义一个数据 count，初始值为 0，在其他组件通过 $store.state.count 读取值： 12345678// store/index.jsexport default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; &#125;,&#125;) 获取数据，这里我们使用一个计算属性接收数据： 12345678910111213141516171819 &lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Index&lt;/div&gt; &lt;router-link to=\"/about\"&gt;about&lt;/router-link&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index', computed: &#123; count () &#123; return this.$store.state.count; &#125; &#125;&#125;&lt;/script&gt; 在组件内通过显式的提交 mutations 可以改变 state 中的数据： 1234567891011121314// store/index.jsexport default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count ++; &#125;, decrease (state) &#123; state.count --; &#125; &#125;,&#125;) 在组件中，通过 this.$store.commit 方法来执行 mutations。在 index.vue 中添加两个按钮用于加减： 1234567891011121314151617181920212223242526272829&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Index&lt;/div&gt; &lt;router-link to=\"/about\"&gt;about&lt;/router-link&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"handleIncrement\"&gt;+1&lt;/button&gt; &lt;button @click=\"handleDecrease\"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index', computed: &#123; count () &#123; return this.$store.state.count; &#125; &#125;, methods: &#123; handleIncrement () &#123; this.$store.commit('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125; &#125;&#125;&lt;/script&gt; 这看起来像 JavaScript 的观察者模式，组件只负责提交一个事件名，Vuex 对应的 mutations 来完成对应的业务逻辑。 mutations 还可以接受第二个参数，可以是数字、字符串或者对象等类型，比如我们传入一个默认参数，指定增加的值： 123456789101112131415// store/index.jsexport default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state, n) &#123; n = n || 1; state.count += n; &#125;, decrease (state) &#123; state.count --; &#125; &#125;,&#125;) 123456789101112131415161718192021222324252627282930313233&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Index&lt;/div&gt; &lt;router-link to=\"/about\"&gt;about&lt;/router-link&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"handleIncrement\"&gt;+1&lt;/button&gt; &lt;button @click=\"handleDecrease\"&gt;-1&lt;/button&gt; &lt;button @click=\"handleIncrementMore\"&gt;+5&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index', computed: &#123; count () &#123; return this.$store.state.count; &#125; &#125;, methods: &#123; handleIncrement () &#123; this.$store.commit('increment'); &#125;, handleDecrease () &#123; this.$store.commit('decrease'); &#125;, handleIncrementMore () &#123; this.$store.commit('increment', 5); &#125; &#125;&#125;&lt;/script&gt; 如果一个参数不够，可以传入一个对象： 123456// store/index.jsmutations: &#123; increment (state, params) &#123; state.count += params.count; &#125;&#125; 123456789// index.vuemethods: &#123; handleIncrement () &#123; this.$store.commit(&#123; type: 'increment', count: 10 &#125;); &#125;&#125; 高级用法Vuex 还有 3 个选项可以使用：getters、actins、modules。 getters 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 123456// stre/index.jsconst store = new Vuex.Store(&#123; state: &#123; list: [1, 3, 5, 6, 9, 13, 17] &#125;&#125;); 123456// index.vuecomputed: &#123; list () &#123; return this.$store.state.list.filter(item =&gt; item &lt; 10); &#125;&#125; 这样写完全没有问题，但是有时候其他组件也需要过滤后的数据，这样就需要把同样的方法在写一遍，为了避免这种重复，就可以使用 getters 了。 getters 可以看做是 store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 1234567891011// stre/index.jsconst store = new Vuex.Store(&#123; state: &#123; list: [1, 3, 5, 6, 9, 13, 17] &#125;, getters: &#123; filteredList: state =&gt; &#123; return state.list.filter(item =&gt; item &lt; 10); &#125; &#125;&#125;); 12345678// index.vueexport default &#123; computed: &#123; list () &#123; return this.$store.getters.filteredList; &#125; &#125;&#125; actions mutations 里面不应该异步操作数据，所以有了 actions 选项，actions 与 mutations 很像，不同的是 action 里面提交的是 mutation，并且可以异步操作业务逻辑。 action 在组件内通过 $store.dispatch 触发。我们用一个 Promise 在 1 秒钟后提交 mutations: 123456789101112131415161718192021222324export default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state, n) &#123; n = n || 1; state.count += n; &#125;, decrease (state) &#123; state.count --; &#125; &#125;, actions: &#123; asyncIncrement (context) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; context.commit('increment'); resolve(); &#125;, 1000) &#125;); &#125; &#125;&#125;) 12345678910111213141516171819202122232425262728&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Index&lt;/div&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;button @click=\"handleIncrement\"&gt;+1&lt;/button&gt; &lt;button @click=\"handleActionIncrement\"&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index', computed: &#123; count () &#123; return this.$store.state.count; &#125; &#125;, methods: &#123; handleIncrement () &#123; this.$store.commit('increment'); &#125;, handleActionIncrement () &#123; this.$store.dispatch('asyncIncrement'); &#125; &#125;&#125;&lt;/script&gt; Promise 是一种异步方案，异步 action 同时当然也可以用普通的回调来实现： 123456789// store/index.jsactions: &#123; asyncIncrement (context, callback) &#123; setTimeout (() =&gt; &#123; context.commit('increment'); callback(); &#125;, 1000); &#125;&#125; mutations 和 actions 看起来很像，但 Vuex 很像是一种与开发者的约定，涉及改变数据的，就使用 mutations，存在业务逻辑的，就用 actions。 modules 它用来将 store 分割到不同的模块。 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // moduleA 的状态store.state.b // moduleB 的状态 不同模块下的数据状态管理，添加命名空间 namespaced: 123456789101112131415161718192021222324252627282930313233343536// store/index.jsconst moduleA = &#123; namespaced: true, state: &#123; count: 1, &#125;, mutations: &#123; add (state) &#123; state.count += 2; &#125; &#125;, actions: &#123;&#125;, getters: &#123;&#125;&#125;const moduleB = &#123; namespaced: true, state: &#123; count: 0, &#125;, mutations: &#123; add (state) &#123; state.count ++; &#125; &#125;, actions: &#123;&#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)export default store; 使用 namespaced 后，提交时在前面加上模块名： 例如：this.$store.commit(&#39;a/add&#39;) 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;div&gt;A: &#123;&#123; countA &#125;&#125;&lt;/div&gt; &lt;div&gt;B: &#123;&#123; countB &#125;&#125;&lt;/div&gt; &lt;button @click=\"handleAdda\"&gt;+2&lt;/button&gt; &lt;button @click=\"handleAddb\"&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'index', computed: &#123; countA () &#123; return this.$store.state.a.count; &#125;, countB () &#123; return this.$store.state.b.count; &#125; &#125;, methods: &#123; handleAdda () &#123; this.$store.commit('a/add'); &#125;, handleAddb () &#123; this.$store.commit('b/add'); &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"}]},{"title":"Vue.js 阅读笔记（三）","slug":"vue-comp/comp-vue","date":"2019-12-15T16:00:00.000Z","updated":"2020-10-06T11:15:40.924Z","comments":true,"path":"2019/12/16/vue-comp/comp-vue/","link":"","permalink":"http://akashigakki.github.io/2019/12/16/vue-comp/comp-vue/","excerpt":"Vue.js 阅读笔记（三） 系统、框架性的认识 Vue，组件详解。","text":"Vue.js 阅读笔记（三） 系统、框架性的认识 Vue，组件详解。 组件与复用 为什么使用组件？ 在实际业务中，我们可能需要重复使用到相同的组件，业务需求也会发生频繁的变动，这时，组件的复用就体现出优势了。 组件用法 在我们创建 Vue 的实例时，需要将实例注册并挂载到挂载点： 123var app = Vue(&#123; el: '#app',&#125;) 组件与之类似，需要注册后才可以使用。 注册有全局注册和局部注册两种方式，全局注册后，任何 Vue 的实例都可以使用。 全局注册： 123Vue.component('my-component', &#123; //...&#125;) my-component 是注册组件的自定义名称，推荐用小写加减号分割的形式命名。 子父实例中使用这个组件，必须要在实例创建前注册，之后就可以使用 &lt;my-component&gt;&lt;/my-component&gt; 的形式来使用组件了。 123456789101112&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;div&gt;这里是子组件内容&lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; 渲染后结果： 123&lt;div id=\"app\"&gt; &lt;div&gt;这里是子组件内容&lt;/div&gt;&lt;/div&gt; 局部组件： 在 Vue 的实例中，使用 components 选项可以局部注册组件，注册后的组件只有在该实例作用域下有效，组件下也可以嵌套组件。 123456789101112131415&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var Child = &#123; template: '&lt;div&gt;这里是子组件内容&lt;/div&gt;' &#125; var app = new Vue(&#123; el: '#app', components: &#123; 'my-component': Child &#125; &#125;)&lt;/script&gt; Vue 组件的模板在某些情况下会受到 HTML 的限制，如 &lt;table&gt; 内规定只允许是 &lt;tr&gt;、&lt;td&gt;、&lt;th&gt; 这些表格元素，所以在 &lt;table&gt; 内直接使用组件是无效的。这种情况下，可以使用特殊的 is 属性来挂载组件。 12345678910111213&lt;div id=\"app\"&gt; &lt;table&gt; &lt;tbody is=\"my-component\"&gt;&lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;div&gt;这里是子组件的内容&lt;/div&gt;' &#125;) var app = new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; &lt;tbody&gt; 在渲染时，会被替换为组件内容。常见的限制元素还有 &lt;ul&gt;、&lt;ol&gt;、&lt;select&gt;。 除了 template 之外，组件中还可以像 Vue 实例那样使用其他选项，如 data、computed、methods 等。 但是，使用 data 时，和实例稍微有点区别， data 必须是函数，然后将数据 return 出去。 123456789101112Vue.component('my-component', &#123; template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;', data: function() &#123; return &#123; message: '这里是子组件的内容' &#125; &#125;&#125;);var app = new Vue(&#123; el: '#app',&#125;); 可以简写为： 12345678Vue.component('my-component', &#123; template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;', data () &#123; return &#123; message: '这里是子组件的内容' &#125; &#125;&#125;); JavaScript 对象时引用关系，所以如果 return 出的对象引用了外部的一个对象，那么这个对象就是共享的，任何一方修改都会同步。 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var data = &#123; counter: 0 &#125;; Vue.component('my-component', &#123; template: '&lt;button @click=\"counter++\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data () &#123; return data; &#125; &#125;); var app = new Vue(&#123; el: '#app', &#125;);&lt;/script&gt; 组件使用了 3 次，但是点击任意一个按钮所有数字都会加 1，那是因为组件的 data 引用的是外部的对象，这不是我们期望的结果，所以给组件返回一个新的 data 对象来独立。 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;button @click=\"counter++\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data () &#123; return &#123; counter: 0 &#125;; &#125; &#125;); var app = new Vue(&#123; el: '#app', &#125;);&lt;/script&gt; 这样 3 个按钮就不互相影响了，完全达到了复用的目的。 使用 props 传递数据 组件不仅仅是要把模板的内容进行复用，更重要的是组件间要进行通信。 通常父组件的模板中包含子组件，父组件要正向的向子组件传递数据或参数，子组件接收到后根据参数的不同来渲染不同的内容或执行操作。 这个正向传递数据的过程就是通过 props 来实现的。 12345678910111213&lt;div id=\"app\"&gt; &lt;my-component message=\"来自父组件的数据\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; props: ['message'], template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app', &#125;);&lt;/script&gt; 渲染结果： 123&lt;div id=\"app\"&gt; &lt;div&gt;来自父组件的数据&lt;/div&gt;&lt;/div&gt; props 中声明的数据与组件 data 函数 reture 的数据的主要区别就是 props 的数据来自父级，而 data 中的是组件自己的数据，作用域是组件本身。 这两种数据都可以在模板 template 及计算属性 computed 和 方法 methods 中使用。 由于 HTML 特性不区分大小写，当使用 DOM 模板时，驼峰命名的 props 名称要转为短横分隔命名： 12345678910111213&lt;div id=\"app\"&gt; &lt;my-component warning-text=\"提示信息\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; props: ['warningText'], template: '&lt;div&gt;&#123;&#123; warningText &#125;&#125;&lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app', &#125;);&lt;/script&gt; 有时候，需要传递来自父组件的动态数据，使用 v-bind 来动态绑定 props 的值： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"msg\"&gt; &lt;my-component :message=\"msg\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; props: ['message'], template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app', data: &#123; msg: '' &#125; &#125;);&lt;/script&gt; 父组件传值给子组件，子组件获取值后可以进行使用。 单向数据流 通过 props 传递的数据是单向的，也就是说父组件数据变化时会传递给子组件，但是反过来不行。 在业务中，经常会遇到两种情况需要改变 props 的情况，一种是父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意的改变和修改： 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;my-component :init-count='count'&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; props: ['initCount'], template: '&lt;div&gt;&#123;&#123; compCount &#125;&#125;&lt;/div&gt;', data () &#123; return &#123; compCount: this.initCount &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; count: 1 &#125; &#125;);&lt;/script&gt; 另一种是 props 作为需要被转变的原始值传入，使用计算属性进行修改后使用： 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;my-component :width='width'&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-component', &#123; props: ['width'], template: '&lt;div :style=\"style\"&gt;子组件内容&lt;/div&gt;', computed: &#123; style: function() &#123; return &#123; width: this.width + 'px' &#125; &#125; &#125;, &#125;); var app = new Vue(&#123; el: '#app', data: &#123; width: 100 &#125; &#125;); &lt;/script&gt; 计算属性里面的函数还可以进一步使用简写方式： 1234567computed: &#123; style () &#123; return &#123; width: this.width + 'px' &#125; &#125;&#125;, 最终渲染结果： 123&lt;div id=\"app\"&gt; &lt;div style=\"width: 100px;\"&gt;子组件内容&lt;/div&gt;&lt;/div&gt; 数据验证 上面所介绍的 props 选项的值都是一个数组，当然，除了数组之外，还可以是对象，当 props 需要验证时，就需要对象的写法： 一般当自己的组件需要提供给别人使用时，推荐都进行数据验证，比如某个数据必须是数字，如果传入字符串，就会在控制台弹出警告。 123456789101112131415161718192021222324252627282930313233343536Vue.component('my-component', &#123; props: &#123; // 必须是数字类型 propA: Number, // 必须是字符串或者数字类型 propB: [String, Number], // 布尔值，如果没有定义，默认为 true propC: &#123; type: Boolean, default: true &#125;, // 数字，而且必传 propD: &#123; type: Number, required: true &#125;, // 如果是数组或对象，默认值必须是一个函数来返回 propE: &#123; type: Array, default: function() &#123; return []; &#125; &#125;, // 自定义一个验证器 propF: &#123; validator: function() &#123; return value &gt; 20; &#125; &#125; &#125;&#125;); 验证的 type 类型可以是： String Number Boolean Object Array Function type 也是一个自定义构造器，使用 instanceof 检测。 组件通信 从父组件向子组件通信，通过 props 传递数据就可以了，但是 Vue 的通信场景不止一种，组件关系可以分为父子组件通信、兄弟组件通信、跨级组件通信。 自定义事件 当子组件需要像父组件传递数据，就需要使用到自定义事件。类似有 JS 设计模式中的观察者模式，子组件用 $emit() 来触发事件，父组件用 $on() 来监听子组件的事件。 父组件也可以直接在子组件的自定义标签上使用 v-on 来监听子组件触发的自定义事件。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"app\"&gt; &lt;p&gt;总数：&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;my-component @increase=\"handleGetTotal\" @reduce=\"handleGetTotal\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '\\ &lt;div&gt;\\ &lt;button @click=\"handleIncrease\"&gt;+1&lt;/button&gt;\\ &lt;button @click=\"handleReduce\"&gt;-1&lt;/button&gt;\\ &lt;/div&gt;', data() &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; handleIncrease() &#123; this.counter++; this.$emit('increase', this.counter); &#125;, handleReduce() &#123; this.counter--; this.$emit('reduce', this.counter); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; total: 0 &#125;, methods: &#123; handleGetTotal(total) &#123; this.total = total; &#125; &#125; &#125;);&lt;/script&gt; 使用 v-model 其实也是通过事件的方式实现，但语法糖可以一定量上简化代码。 123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;p&gt;总数：&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;my-component v-model=\"total\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '&lt;button @click=\"handleClick\"&gt;+1&lt;/button&gt;', data() &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; handleClick() &#123; this.counter++; this.$emit('input', this.counter); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; total: 0 &#125;, &#125;);&lt;/script&gt; 当然，也可以完全还原第一个例子： 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;p&gt;总数：&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;my-component v-model=\"total\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '\\ &lt;div&gt;\\ &lt;button @click=\"handleIncrease\"&gt;+1&lt;/button&gt;\\ &lt;button @click=\"handleReduce\"&gt;-1&lt;/button&gt;\\ &lt;/div&gt;', data() &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; handleIncrease() &#123; this.counter++; this.$emit('input', this.counter); &#125;, handleReduce() &#123; this.counter--; this.$emit('input', this.counter); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; total: 0 &#125;, &#125;);&lt;/script&gt; v-model 还可以用来创建自定义的表单输入组件，进行数据的双向绑定： 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"app\"&gt; &lt;p&gt;总数：&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;my-component v-model=\"total\"&gt;&lt;/my-component&gt; &lt;button @click='handleIncrease'&gt;+1&lt;/button&gt; &lt;button @click=\"handleReduce\"&gt;-1&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; props: ['value'], template: '&lt;input :value=\"value\" @input=\"updateValue\"&gt;', data() &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; updateValue() &#123; this.$emit('input', event.target.value); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; total: 0 &#125;, methods: &#123; handleIncrease() &#123; this.total++; &#125;, handleReduce() &#123; this.total--; &#125; &#125; &#125;);&lt;/script&gt; 控件接收一个 value 属性，在有新的 value 时触发 input 事件。 非父子间通信 兄弟组件和跨多级组件之间的通信，在 Vue.js 2.x 中，推荐使用一个空的 Vue 实例作为中央事件总线(bus)，也就是一个中介。 123456789101112131415161718192021222324252627282930&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;component-a&gt;&lt;/component-a&gt;&lt;/div&gt;&lt;script&gt; var bus = new Vue(); Vue.component('component-a', &#123; template: '&lt;button @click=\"handleEvent\"&gt;传递事件&lt;/button&gt;', methods: &#123; handleEvent() &#123; bus.$emit('on-message', '来自组件 component-a 的内容'); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; message: '' &#125;, mounted () &#123; var _this = this; // 在实例初始化时，监听来自 bus 的事件 bus.$on('on-message', function(msg) &#123; _this.message = msg; &#125;) &#125; &#125;);&lt;/script&gt; 除了中央事件总线 bus 外，还有两种方法可以实现组件间的通信：父链和子组件索引。 父链 在子组件中，使用 this.$parent 可以直接访问该组件的父实例或组件，父组件也可以通过 this.$children 访问它的所有的子组件，而且可以递归向上或向下无限访问，直到根实例或最内层的组件。 123456789101112131415161718192021&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;component-a&gt;&lt;/component-a&gt;&lt;/div&gt;&lt;script&gt; Vue.component('component-a', &#123; template: '&lt;button @click=\"handleEvent\"&gt;通过父链之间修改数据&lt;/button&gt;', methods: &#123; handleEvent() &#123; this.$parent.message = '来自子组件 component-a 的内容'; &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; message: '' &#125; &#125;)&lt;/script&gt; 尽管 Vue 允许这样操作，但在业务中，子组件应该尽可能的避免依赖父组件的数据，更不应该去主动修改它的数据。 因为这样使得父子附件紧耦合，只看父组件，很难理解父组件的状态，因为它可能被任意组件修改，理想情况下，只有组件自己能修改它的状态。父子组件最好还是通过 props 和 $emit 来通信。 子组件索引 当子组件较多时，通过 this.$children 来一一遍历找出需要的一个组件实例是比较困难的，尤其是组件动态渲染时，它们的序列是不固定的。 Vue 提供了子组件索引的方法，用特殊的属性 ref 来为子组件指定一个索引名称。 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;button @click=\"handleRef\"&gt;通过 ref 获取子组件实例&lt;/button&gt; &lt;component-a ref=\"comA\"&gt;&lt;/component-a&gt;&lt;/div&gt;&lt;script&gt; Vue.component('component-a', &#123; template: '&lt;div&gt;子组件&lt;/div&gt;', data() &#123; return &#123; message: '子组件内容' &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', methods: &#123; handleRef() &#123; var msg = this.$refs.comA.message; alert(msg); &#125; &#125; &#125;)&lt;/script&gt; 在父组件模板中，子组件标签上使用 ref 指定一个名称，并在子组件内通过 this.$refs 来访问指定名称的子组件。 $refs 只在组件渲染完成后才填充，并且并非是响应式的，它仅仅是作为一个直接访问子组件的应急方案，应当避免在模板或计算属性中使用 $refs。 使用 slot 分发内容 什么是 slot 当需要让组件组合使用，混合父组件与子组件的内容时，就会用到 slot，这个过程叫做内容分发， 在一个 Vue 实例中，使用 props 传递数据，enents 触发事件和 slot 内容分发，这就构成了 Vue 组件的 3 个 API 来源，再复杂的组件也是由这 3 部分组成的。 作用域 在介绍 slot 之前，需要理解编译的作用域，比如父组件中有如下模板： 123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; 这里的 message 就是一个 slot，但是他绑定的是父组件的数据，而不是组件 child-component 的数据。 父组件模板的内容是在父组件作用域内编译的，子组件模板的内容是在子组件作用域内编译的。 一个绑定数据作用域在父组件的例子： 123456789101112131415&lt;div id=\"app\"&gt; &lt;child-component v-show=\"showChild\"&gt;&lt;/child-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child-component', &#123; template: '&lt;div&gt;子组件&lt;/div&gt;', &#125;); var app = new Vue(&#123; el: '#app', data: &#123; showChild: true &#125; &#125;)&lt;/script&gt; 一个绑定数据作用域在子组件的例子： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;child-component&gt;&lt;/child-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child-component', &#123; template: '&lt;div v-show=\"showChild\"&gt;子组件&lt;/div&gt;', data() &#123; return &#123; showChild: true &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; 了解了两者作用域的区别，我们就可以知道，slot 分发的内容，作用域是在父组件上的。 slot 用法 单个 slot: 在子组件内使用特殊的 &lt;slot&gt; 元素可以为这个组件开启一个 slot (插槽)，在父组件模板中，插入在子组件标签内的所有内容将代替子组件的 &lt;slot&gt; 标签及它的内容。 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;child-component&gt; &lt;p&gt;分发内容&lt;/p&gt; &lt;p&gt;分发更多内容&lt;/p&gt; &lt;/child-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child-component', &#123; template: '\\ &lt;div&gt;\\ &lt;slot&gt;\\ &lt;p&gt;如果父组件没有插入内容，默认出现。&lt;/p&gt;\\ &lt;/slot&gt;\\ &lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 具名 slot: 给 &lt;slot&gt; 元素指定一个 name 之后可以分发多个内容，具名 slot 可以与单个 slot 共存。 12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;child-component&gt; &lt;h2 slot=\"header\"&gt;标题&lt;/h2&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;p&gt;更多正文内容&lt;/p&gt; &lt;div slot=\"footer\"&gt;底部信息&lt;/div&gt; &lt;/child-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child-component', &#123; template: '\\ &lt;div class=\"container\"&gt;\\ &lt;div class=\"header\"&gt;\\ &lt;slot name=\"header\"&gt;&lt;/slot&gt;\\ &lt;/div&gt;\\ &lt;div class=\"main\"&gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/div&gt;\\ &lt;div class=\"footer\"&gt;\\ &lt;slot name=\"footer\"&gt;&lt;slot&gt;\\ &lt;/div&gt;\\ &lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 渲染后： 1234567891011121314&lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"main\"&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;p&gt;更多正文内容&lt;/p&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;div&gt;底部信息&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 作用域插槽 作用域插槽是一种特殊的 slot，使用一个可以复用的模板代替已渲染元素。 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;child-component&gt; &lt;template scope=\"props\"&gt; &lt;p&gt;来组父组件的内容&lt;/p&gt; &lt;p&gt;&#123;&#123; props.msg &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/child-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child-component', &#123; template: '\\ &lt;div class=\"container\"&gt;\\ &lt;slot msg=\"来组子组件的内容\"&gt;&lt;/slot&gt;\\ &lt;/div&gt;' &#125;); var app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 观察例子可发现，父组件在 template 标签中属性 scope 定义了一个临时变量 props 来访问子组件插槽的数据 msg。 作用域插槽是使用场景主要是既可以复用子组件的 slot，又可以使 slot 的内容不一致。 访问 slot 使用方法 $slots 访问分发内容。 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;child-component&gt; &lt;h2 slot=\"header\"&gt;标题&lt;/h2&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;p&gt;更多正文内容&lt;/p&gt; &lt;div slot=\"footer\"&gt;底部信息&lt;/div&gt; &lt;/child-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child-component', &#123; template: '\\ &lt;div class=\"container\"&gt;\\ &lt;div class=\"header\"&gt;\\ &lt;slot name=\"header\"&gt;&lt;/slot&gt;\\ &lt;/div&gt;\\ &lt;div class=\"main\"&gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/div&gt;\\ &lt;div class=\"footer\"&gt;\\ &lt;slot name=\"footer\"&gt;&lt;slot&gt;\\ &lt;/div&gt;\\ &lt;/div&gt;', mounted() &#123; var header = this.$slots.header; var main = this.$slots.default; var footer = this.$slots.footer; console.log(header) console.log(footer[0].elm.innerHTML) &#125; &#125;); var app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 通过 $slots 可以访问某个具名的 slot，this.$slots.default 包括了所有没有包含在具名 slot 的节点。 $slots 在业务中几乎用不到，在 render 函数创建组件时会比较有用，但是还是用于独立组件的开发中。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"}]},{"title":"Vue.js 阅读笔记（二）","slug":"vue-basic/v-vue","date":"2019-12-11T16:00:00.000Z","updated":"2020-10-06T11:15:40.923Z","comments":true,"path":"2019/12/12/vue-basic/v-vue/","link":"","permalink":"http://akashigakki.github.io/2019/12/12/vue-basic/v-vue/","excerpt":"Vue.js 阅读笔记（二） 系统、框架性的认识 Vue。v-bind、v-on、v-if、v-for、v-model。","text":"Vue.js 阅读笔记（二） 系统、框架性的认识 Vue。v-bind、v-on、v-if、v-for、v-model。 内置指令基本指令 v-cloak v-cloak 不需要表达式，它会在实例结束编译时从绑定的 HTML 元素上移除，经常和 CSS 中的 display: none; 配合使用。 1234567891011&lt;div id=\"app\" v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'some messages' &#125; &#125;)&lt;/script&gt; 123[v-cloak] &#123; display: none;&#125; 当网速较慢，vue.js 文件还没有加载完时，页面上就会显示 的字样，直到 Vue 创建实例、编译模板时， DOM 才会被替换，所以这个过程中，屏幕是会有闪动的，使用 v-cloak 配合 CSS，就是解决初始化慢导致页面抖动的最佳实践。 一般情况下，在使用了 webpack 和 vue-route 时，项目的 HTML 只有一个空的 div 元素，剩余的内容都是由路由去挂载不同组件完成的，所以也就不需要 v-cloak 了。 v-once 也是一个不需要表达式的指令，作用是定义它的组件或元素只被渲染一次，包括元素或组件的所有节点。首次渲染之后，不再随数据的变化重新渲染，将被视为静态内容。 1234567891011&lt;div id=\"app\" v-once&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'some messages' &#125; &#125;)&lt;/script&gt; v-once 在业务中很少使用，当需要进一步优化性能时，才可能会使用到。 条件渲染指令 v-if、v-else-if、v-else 与 JavaScript 的条件语句 if、else、else if 类似，Vue.js 的条件指令可以根据表达式的值在 DOM 中渲染或销毁元素/组件。 12345678910111213&lt;div id=\"app\"&gt; &lt;div v-if=\"status === 1\"&gt;当 status 为 1 时，显示&lt;/div&gt; &lt;div v-else-if=\"status === 2\"&gt;当 status 为 2 时，显示&lt;/div&gt; &lt;div v-else&gt;否则，显示该行&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; status: 1, &#125; &#125;)&lt;/script&gt; Vue 在渲染元素时，会尽可能的复用已有的元素而非重新渲染： 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;template v-if=\"type === 'name'\"&gt; &lt;label for=\"name\"&gt;Name:&lt;/label&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"Here input your name\"&gt; &lt;/template&gt; &lt;template v-if=\"type === 'email'\"&gt; &lt;label for=\"email\"&gt;Email:&lt;/label&gt; &lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"Here input your email\"&gt; &lt;/template&gt; &lt;button @click=\"handleToggleClick\"&gt;Change Type&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; type: 'name', &#125;, methods: &#123; handleToggleClick: function() &#123; this.type = this.type === 'name' ? 'email' : 'name'; &#125; &#125; &#125;)&lt;/script&gt; 这里键入内容，点击切换后，虽然 DOM 改变了，但是输入框的内容并没有改变，只是替换了 placeholder 的内容，&lt;input&gt; 元素被复用了。 如果你不希望这样，可以使用 key 属性，它可以决定是否要复用元素，key 值必须要是唯一的。 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;template v-if=\"type === 'name'\"&gt; &lt;label for=\"name\"&gt;Name:&lt;/label&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" key=\"name-input\" placeholder=\"Here input your name\"&gt; &lt;/template&gt; &lt;template v-if=\"type === 'email'\"&gt; &lt;label for=\"email\"&gt;Email:&lt;/label&gt; &lt;input type=\"email\" name=\"email\" id=\"email\" key=\"email-input\" placeholder=\"Here input your email\"&gt; &lt;/template&gt; &lt;button @click=\"handleToggleClick\"&gt;Change Type&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; type: 'name', &#125;, methods: &#123; handleToggleClick: function() &#123; this.type = this.type === 'name' ? 'email' : 'name'; &#125; &#125; &#125;)&lt;/script&gt; v-show v-show 与 v-if 基本一致，只不过 v-show 是改变元素的 CSS 属性 display，当表达式的值为 false 时，元素会隐藏。 1234567891011&lt;div id=\"app\"&gt; &lt;div v-show=\"status === 1\"&gt;当 status 为 1 时，显示&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; status: 2, &#125; &#125;)&lt;/script&gt; 1234567891011&lt;div id=\"app\"&gt; &lt;div v-show=\"isShow\"&gt;显示/隐藏&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isShow: false &#125; &#125;)&lt;/script&gt; 注意：v-show 不能在 &lt;template&gt; 上使用。 v-if 和 v-show 的选择 v-if 是条件渲染，会根据表达式适当的销毁或重建元素及绑定事件或子组件。若表达式一开始为 false，则一开始元素\\组件并不会被渲染，只有当条件第一次变为 true 时才开始编译。 v-show 只是简单的 CSS 属性切换，无论条件是否为 true，都会被编译。 相比之下，v-if 更适合条件不经常改变的场景，因为它切换的开销相对较大，而 v-show 适合用于频繁切换的条件。 列表渲染指令 v-for 当需要将一个数组遍历或枚举一个对象循环显示时，就需要用到列表渲染指令v-for。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"book in books\"&gt;&#123;&#123; book.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; books: [ &#123; name: 'book_1' &#125;, &#123; name: 'book_2' &#125;, &#123; name: 'book_3' &#125; ] &#125; &#125;)&lt;/script&gt; 除了用 in 做分隔符，也可以使用 of 作为分隔符： 1&lt;li v-for=\"book of books\"&gt;&#123;&#123; book.name &#125;&#125;&lt;/li&gt; 还支持一个可选参数作为当前索引： 1&lt;li v-for=\"(book, index) in books\"&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; book.name &#125;&#125;&lt;/li&gt; 可选参数放在后面 除了数组外，对象的属性也是可以遍历的。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key, index) in user\"&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; user: &#123; name: 'Akashi', gender: 'male', age: 22 &#125; &#125; &#125;)&lt;/script&gt; 遍历对象属性时，有两个可选参数，分别是键名和索引，参数传入顺序为 (value, key, index)。 数组更新 Vue 的核心是数据与视图的双向绑定，当我们修改数组时，Vue 会检测到数据的变化，所以渲染的视图也会立即更新。 数组方法： push() 向数组的末尾添加一个或多个元素，并返回新的长度。 pop() 用于删除并返回数组的最后一个元素。 shift() 用于把数组的第一个元素从其中删除，并返回第一个元素的值。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 splice() 从数组中添加/删除项目，然后返回被删除的项目。 sort() 对数组的元素进行排序。 reverse() 用于颠倒数组中元素的顺序。 还有一些方法不会改变原数组： filter() 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 concat() 用于连接两个或多个数组。 slice() 从已有的数组中返回选定的元素(切片)。 12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(user, index) in users\"&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; user.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; users: [ &#123; name: 'Akashi', gender: 'male', age: 22 &#125;, &#123; name: 'Asuka', gender: 'female', age: 21 &#125; ] &#125; &#125;); app.users = app.users.filter(function (item) &#123; if (item.age &gt; 21) &#123; return item; &#125; &#125;);&lt;/script&gt; 这样，第二项 Asuka 就会被过滤。 Vue 在检测到数据变化时，并不是直接渲染整个列表，而是最大化的复用了 DOM 元素，替换的数组中，含有相同的元素的项不会被重新渲染，因此可以大胆的用新数组来替换旧数组，不用担心性能问题。 过滤与排序 当不想改变原数组，想通过一个数组副本来做过滤或者排序显示时，可以使用计算属性来返回过滤或排序后的数组。 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(user, index) in filterUser\"&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; user.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; users: [ &#123; name: 'Akashi', gender: 'male', age: 22 &#125;, &#123; name: 'Asuka', gender: 'female', age: 21 &#125; ] &#125;, computed: &#123; filterUser: function() &#123; return this.users.filter(function (user) &#123; if (user.gender === 'female') return user; &#125;); &#125; &#125; &#125;);&lt;/script&gt; 方法与事件 Vue 中事件处理引入了 v-on。 一个计时器的例子： 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;div&gt;点击次数 &#123;&#123; counter &#125;&#125;&lt;/div&gt; &lt;button @click=\"handleAdd()\"&gt;+1&lt;/button&gt; &lt;button @click=\"handleAdd(10)\"&gt;+10&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; counter: 0, &#125;, methods: &#123; handleAdd: function(count) &#123; count = count || 1; this.counter += count; &#125; &#125; &#125;)&lt;/script&gt; 在 methods 中我们定义了需要的方法供 @click 调用，需要注意的是，调用的方法名后可以不跟括号 ()。此时，如果该方法有参数，默认就会将原生事件对象 event 传入。 在大部分业务场景中，如果方法不需要传入参数，为了简便可以不写括号。 Vue 还提供了一个特殊的变量 $event，用于访问原生 DOM 事件： 1234567891011121314&lt;div id=\"app\"&gt; &lt;a href=\"https://akashigakki.github.io\" @click=\"handleClick('禁止打开', $event)\"&gt;打开链接&lt;/a&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', methods: &#123; handleClick: function(message, event) &#123; event.preventDefault(); window.alert(message); &#125; &#125; &#125;)&lt;/script&gt; 修饰符 在上一例中使用的 event.preventDefault() 也可以用 Vue 事件的修饰符来实现。 .stop .prevent .capture .self .once 具体用法： 12&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a @click.stop=\"handle\"&gt;&lt;/a&gt; 12&lt;!-- 提交事件不再重载页面 --&gt;&lt;form @submit.prevent=\"handle\"&gt;&lt;/form&gt; 修饰符也可以串联： 1&lt;a @click.stop.prevent=\"handle\"&gt;&lt;/a&gt; 只有修饰符： 1&lt;form @sublit.prevent&gt;&lt;/form&gt; 12&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div @click.capture=\"handle\"&gt;...&lt;/div&gt; 12&lt;!-- 只当事件在该元素本身(而不是子元素)触发时触发回调 --&gt;&lt;div @click.self=\"handle\"&gt;...&lt;/div&gt; 12&lt;!-- 只触发一次，组件同样适用 --&gt;&lt;div @click.once=\"handle\"&gt;...&lt;/div&gt; 键盘监听事件： 1&lt;input @keyup.13=\"submit\"&gt; 除了具体的某个 keyCode 外， Vue 还提供了一些快捷键名称： .enter .tab delete (捕获 删除 和 退格键) esc space up down left right 按键可以组合使用，或配合鼠标使用： .ctrl alt shift meta ( Mac 上是 Command 键， Windows 上是窗口键 ) 12&lt;!-- shift + s --&gt;&lt;input @keyup.shift.83=\"handleSave\"&gt; v-model 表单类控件承载了一个网页的录入与交互，Vue 中使用 v-model 完成表单的数据双向绑定。 基本用法 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message\" placeholder=\"输入...\"&gt; &lt;p&gt;输入的内容是：&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: '' &#125; &#125;)&lt;/script&gt; 对于文本域(textarea)也是同样的用法。 可以用 @input 代替 v-model，事实上，v-model 也是一个特殊的语法糖，只不过它会在不同的表单上智能处理。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;input type=\"text\" @input=\"handleInput\" placeholder=\"输入...\"&gt; &lt;p&gt;输入的内容是：&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: '', &#125;, methods: &#123; handleInput: function(e) &#123; this.message = e.target.value; &#125; &#125; &#125;)&lt;/script&gt; 单选按钮： 单选按钮在单独使用时，不需要 v-model，直接使用 v-bind 绑定一个布尔类型的值，为真时为选中。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;input type=\"radio\" :checked=\"picked\" @click=\"handleClick\" name=\"radio\" id=\"radio\"&gt; &lt;label for=\"radio\"&gt;单选按钮&lt;/label&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; picked: true &#125;, methods: &#123; handleClick: function () &#123; this.picked = !this.picked; &#125; &#125; &#125;)&lt;/script&gt; 配合 v-model 和 value 组合实现互斥效果： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;input type=\"radio\" v-model=\"picked\" name=\"html\" id=\"html\" value=\"html\"&gt; &lt;label for=\"html\"&gt;HTML&lt;/label&gt; &lt;input type=\"radio\" v-model=\"picked\" name=\"js\" id=\"js\" value=\"js\"&gt; &lt;label for=\"js\"&gt;JS&lt;/label&gt; &lt;input type=\"radio\" v-model=\"picked\" name=\"css\" id=\"css\" value=\"css\"&gt; &lt;label for=\"css\"&gt;CSS&lt;/label&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; picked: 'js' &#125; &#125;)&lt;/script&gt; 复选框： 复选框单独使用时，使用 v-model 绑定一个布尔值。 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checked\" name=\"checked\" id=\"checked\"&gt; &lt;label for=\"checked\"&gt;选择状态： &#123;&#123; checked &#125;&#125;&lt;/label&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; checked: true &#125; &#125;)&lt;/script&gt; 多个复选框(以数组绑定值)： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checked\" name=\"html\" id=\"html\" value=\"html\"&gt; &lt;label for=\"html\"&gt;HTML&lt;/label&gt; &lt;input type=\"checkbox\" v-model=\"checked\" name=\"js\" id=\"js\" value=\"js\"&gt; &lt;label for=\"js\"&gt;JS&lt;/label&gt; &lt;input type=\"checkbox\" v-model=\"checked\" name=\"css\" id=\"css\" value=\"css\"&gt; &lt;label for=\"css\"&gt;CSS&lt;/label&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; checked: ['html', 'css'] &#125; &#125;)&lt;/script&gt; 选择列表： 下拉选择器，也分为单选和多选两种方式。 123456789101112131415&lt;div id=\"app\"&gt; &lt;select name=\"selected\" v-model=\"selected\" id=\"selected\"&gt; &lt;option value=\"html\"&gt;HTML&lt;/option&gt; &lt;option value=\"js\"&gt;JS&lt;/option&gt; &lt;option value=\"css\"&gt;CSS&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; selected: 'js', &#125; &#125;)&lt;/script&gt; 在业务中，&lt;option&gt; 经常用 v-for 动态输出，value 和 text 也是用 v-bind 来动态输出： 12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;select name=\"selected\" v-model=\"selected\" id=\"selected\"&gt; &lt;option v-for=\"option in options\" :value=\"option.value\"&gt;&#123;&#123; option.text &#125;&#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; selected: 'js', options: [&#123; text: 'HTML', value: 'html' &#125;, &#123; text: 'JavaScript', value: 'js' &#125;, &#123; text: 'CSS', value: 'css' &#125;] &#125; &#125;)&lt;/script&gt; 虽然用选择列表 &lt;select&gt; 控件可以简单的完成下拉选择的需求，但是在实际业务中反而不常用， 因为它的样式依赖平台和浏览器，无法统一，也不太美观，功能也受限，比如不支持搜索， 所以常见的解决方案是使用 &lt;div&gt; 模拟一个类似的控件。 绑定值 在业务中，往往需要绑定一个动态数据，这时可以使用 v-band 来实现。 单选按钮： 123456789101112131415&lt;div id=\"app\"&gt; &lt;input type=\"radio\" name=\"radio\" v-model=\"picked\" :value=\"value\"&gt; &lt;label for=\"radio\"&gt;单选按钮&lt;/label&gt; &lt;p&gt;&#123;&#123; picked &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; value &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; picked: false, value: 123, &#125;, &#125;)&lt;/script&gt; 在选中时，app.picked === app.value，值都是 123。 复选框： 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" name=\"checked\" id=\"checked\" v-model=\"toggle\" :true-value=\"value1\" :false-value=\"value2\"&gt; &lt;label for=\"checked\"&gt;复选框&lt;/label&gt; &lt;p&gt;&#123;&#123; toggle &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; value1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; value2 &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; toggle: false, value1: 'a', value2: 'b', &#125;, &#125;)&lt;/script&gt; 勾选时，app.toggle === app.value1；未勾选时，app.toggle === app.value2。 选择列表： 123456789101112131415&lt;div id=\"app\"&gt; &lt;select name=\"selected\" id=\"selected\"&gt; &lt;option :value=\"number\"&gt;123&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; selected: '', number: 456 &#125;, &#125;)&lt;/script&gt; 当选中时，app.selected 是一个 Object，app.selected.number === 456 修饰符 与事件的修饰符类似，v-model 也有修饰符，用于控制数据同步的时机。 .lazy: 在输入框中，v-model 默认是在 input 事件中同步输入框的数据，使用修饰符 .lazy 会转变为在 change 事件中同步。 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model.lazy=\"message\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: '' &#125;, &#125;)&lt;/script&gt; 这时，message 并不是实时改变的，而是在失去焦点或按回车时才更新。 .number: 使用修饰符 .number 可以将输入转换为 Number 类型，否则虽然输入的是数字，但它的类型其实是 String，在数字输入框中会比较有用。 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model.number=\"message\"&gt; &lt;p&gt;&#123;&#123; typeof message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 123 &#125;, &#125;)&lt;/script&gt; .trim: 修饰符 .trim 可以自动过滤输入的首尾空格。 123456789101112&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model.trim=\"message\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: '' &#125;, &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"}]},{"title":"Vue.js 阅读笔记（一）","slug":"vue-ref/vuejs","date":"2019-12-10T16:00:00.000Z","updated":"2020-10-06T11:15:40.924Z","comments":true,"path":"2019/12/11/vue-ref/vuejs/","link":"","permalink":"http://akashigakki.github.io/2019/12/11/vue-ref/vuejs/","excerpt":"Vue.js 阅读笔记（一） 系统、框架性的认识 Vue。数据绑定、计算属性、过滤器 (data、methods、computed、filter…)。","text":"Vue.js 阅读笔记（一） 系统、框架性的认识 Vue。数据绑定、计算属性、过滤器 (data、methods、computed、filter…)。 Vue.js 是什么？ 简单来说，是一个数据双向绑定的渐进式前端框架。 MVVM 模式要了解 Vue 就需要了解 MVVM 模式，它是由经典的 MVC 架构衍生来的。当 View (视图层) 变化时，会自动更新到 ViewModel (视图模型) ，反之亦然。 View 和 ViewModel 之间通过双向绑定建立联系。 实例与数据绑定 首先，通过例子简单认识 Vue 的特别之处。 实例 数据双向绑定： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue.js&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.common.dev.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"name\" placeholder=\"your name\"&gt; &lt;h1&gt;Hello, &#123;&#123; name &#125;&#125; !&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; name: '' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击事件： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;button v-if=\"showBtn\" v-on:click=\"handleClick\"&gt;Click me&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; showBtn: true &#125;, methods: &#123; handleClick: function() &#123; console.log('clicked!'); &#125; &#125; &#125;)&lt;/script&gt; for: 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"book in books\"&gt;&#123;&#123; book.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; books: [&#123; name: 'vue.js' &#125;, &#123; name: 'javascript' &#125;, &#123; name: 'react' &#125;] &#125; &#125;)&lt;/script&gt; 生命周期比较常用的生命周期钩子： created: 实例创建完成后调用，需要初始化处理一些数据时会比较有用。 mounted: el 挂载到实例上后调用，一般我们的第一个业务处理逻辑会在这里开始。 beforeDestroy: 实例销毁之前调用。 插值与表达式使用双大括号 实现最基本的文本插值，它会自动将我们双向绑定的数据实时显示出来。 12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &#123;&#123; date &#125;&#125; &lt;span v-html=\"link\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; date: new Date(), link: '&lt;a href=\"#\"&gt;This is a link.&lt;/a&gt;' &#125;, mounted: function() &#123; // 声明一个变量指向Vue的实例this，保证作用域一致 var _this = this; this.timer = setInterval(function() &#123; _this.date = new Date(); &#125;, 1000); &#125;, beforeDestroy: function() &#123; if (this.timer) &#123; clearInterval(this.timer) &#125; &#125; &#125;)&lt;/script&gt; 插值表达式中的简单运算、三元运算 12345678910111213141516&lt;div id=\"app\"&gt; &#123;&#123; number / 3 &#125;&#125; &#123;&#123; isOK ? '确定' : '取消' &#125;&#125; &#123;&#123; text.split(',').reverse().join(',') &#125;&#125; &lt;span v-html=\"link\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; number: 100, isOK: false, text: '123,456' &#125; &#125;)&lt;/script&gt; 过滤器在插值尾部添加管道符 | 对数据进行过滤 通过给实例添加 filters 来设置 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"app\"&gt; &#123;&#123; date | formDate &#125;&#125;&lt;/div&gt;&lt;script&gt; var padDate = function(value) &#123; return value &lt; 10 ? '0' + value : value; &#125; var app = new Vue(&#123; el: '#app', data: &#123; date: new Date() &#125;, filters: &#123; formDate: function(value) &#123; // value为需要过滤的数据 var date = new Date(value); var year = date.getFullYear(value); var month = padDate(date.getMonth(value) + 1); var day = padDate(date.getDate()); var hours = padDate(date.getHours(value)); var minutes = padDate(date.getMinutes(value)); var seconds = padDate(date.getSeconds(value)); return year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ':' + seconds; &#125; &#125;, mounted: function() &#123; var _this = this; this.timer = setInterval(function() &#123; _this.date = new Date(); &#125;, 1000); &#125;, beforeDestroy: function() &#123; if (this.timer) &#123; clearInterval(this.timer) &#125; &#125; &#125;)&lt;/script&gt; 指令与事件 指令是在 Vue 中最常用的一个功能，带有前缀 v-，如 v-if、v-html等。 指令的主要职责就是当其表达式的值改变时，相应的将某些行为应用到 DOM 上。 数据驱动 DOM 是 Vue.js 的核心理念，所以不到万不得已时不要主动操作 DOM，只需要维护好数据，DOM \b的事 Vue 会帮你优雅的处理。 v-if对元素进行判断 1234567891011&lt;div id=\"app\"&gt; &lt;p v-if=\"show\"&gt;显示这段文本&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; show: true, &#125; &#125;)&lt;/script&gt; v-band绑定元素数据，用于动态更新 HTML 元素上的属性。 12345678910111213&lt;div id=\"app\"&gt; &lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt; &lt;img v-bind:src=\"imgUrl\" alt=\"img\"&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; url: 'https://www.github.com', imgUrl: 'https://xxx.xx.xx/img.png' &#125; &#125;)&lt;/script&gt; v-on绑定事件监听器。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;p v-if=\"show\"&gt;显示这段文本&lt;/p&gt; &lt;button v-on:click=\"handleClose\"&gt;点击隐藏&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; show: true, &#125;, methods: &#123; handleClose: function() &#123; this.show = false; &#125; &#125; &#125;)&lt;/script&gt; 语法糖语法糖是指在不影响功能的情况下，添加某种方法实现同样的效果，从而方便程序的开发。 在 Vue.js 中，v-bind 和 v-on 都提供了语法糖，可以缩写为 : 和 @： 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;a :href=\"url\"&gt;链接&lt;/a&gt; &lt;img :src=\"imgUrl\" alt=\"img\"&gt; &lt;button @click=\"handleClose\"&gt;点击隐藏&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; url: 'https://www.github.com', imgUrl: 'https://xxx.xx.xx/img.png' &#125;, methods: &#123; handleClose: function() &#123; this.show = false; &#125; &#125; &#125;)&lt;/script&gt; 语法糖可以简化代码的书写。 计算属性 模板内的表达式常用于简单的运算，当其过长或逻辑复杂时，会难以维护。计算属性就是用于解决该问题的。 12345678910111213141516&lt;div id=\"app\"&gt; &#123;&#123; reversedTest &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: '123,456', &#125;, computed: &#123; reversedTest: function() &#123; return this.text.split(',').reverse().join(','); &#125; &#125; &#125;)&lt;/script&gt; 计算属性的用法12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"app\"&gt; 总价：&#123;&#123; prices &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; package1: [&#123; name: 'iPhone8', price: 7199, count: 2, &#125;, &#123; name: 'iPad', price: 2888, count: 1 &#125;], package2: [&#123; name: 'apple', price: 3, count: 5, &#125;, &#123; name: 'banana', price: 2, count: 10, &#125;], &#125;, computed: &#123; prices: function() &#123; var prices = 0; for (let i = 0; i &lt; this.package1.length; i++) &#123; prices += this.package1[i].price * this.package1[i].count; &#125; for (let i = 0; i &lt; this.package2.length; i++) &#123; prices += this.package2[i].price * this.package2[i].count; &#125; return prices; &#125; &#125; &#125;)&lt;/script&gt; 例子中，商品数量或价格变化时，计算属性 prices 就会自动更新，视图中的价格也会自动变化。 每一个计算属性都包含了一个 getter 和一个 setter，上面例子是计算属性的默认用法，只是利用了 getter 来读取。 在需要时，也可以提供一个 setter 函数，当手动修改计算属性的值就像修改一个普通数据那样时，就会触发 setter 函数，执行一些自定义的操作。 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &#123;&#123; fullName &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; firstName: 'sai', lastName: 'akashi', &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.firstName + ' ' + this.lastName; &#125;, set: function(newValue) &#123; var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length-1]; &#125; &#125; &#125; &#125;)&lt;/script&gt; 绝大多数情况下，我们只会用默认的 getter 方法来读取一个计算属性，在业务中很少用到 setter，所以在声明一个计算属性时，可以直接使用默认的写法，不必将 getter 和 setter 都声明。 计算属性还有两个很实用的技巧容易被忽略，一是计算属性可以依赖其他计算属性，二是计算属性不仅可以依赖当前的 Vue 实例的数据，还可以依赖其他实例的数据。 12345678var app2 = new Vue(&#123; el: '#app2', computed: &#123; reversedTest: function() &#123; return app1.text.split(',').reverse.join(','); &#125; &#125;&#125;) 这里的 app2 的计算属性是依赖 app1 的数据 text。 这样的用法在组件和组件化里会时常用到，尤其是在多人协同开发时。 计算属性缓存有一个问题，你可能会发现调用 methods 里的方法也可以和计算属性达到同样的目的 12345678910111213141516&lt;div id=\"app\"&gt; &#123;&#123; reversedTest() &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: '123,456', &#125;, methods: &#123; reversedTest: function() &#123; return this.text.split(',').reverse().join(','); &#125; &#125;, &#125;)&lt;/script&gt; 既然可以使用 methods 代替，甚至还可以接受参数，使用起来更灵活，那么为什么还需要计算属性呢？原因就是计算属性是基于它的依赖缓存的。 一个计算属性所依赖的数据发生变化时，它才会重新取值，所以 text 只要不改变，计算属性也就不会更新。 但是 methods 不同，只要重新渲染，它就会被调用，因此函数也会被执行。 使用计算属性还是 methods 取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性。 v-bind class 与 style 的绑定 DOM 元素经常会动态的绑定一些 class 类名或 style 样式，在 vue 中同样可以通过 v-bind 实现多种绑定的方法。 v-bind: 1&lt;img v-bind:src=\"imgUrl\"&gt; 可以简写为： 1&lt;img :scr=\"imgUrl\"&gt; 绑定 class 的几种方式 对象语法 给 v-band:class 设置一个对象，可以动态的切换 class。 1234567891011&lt;div id=\"app\"&gt; &lt;div class=\"static\" :class=\"&#123; 'active': isActive &#125;\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, &#125; &#125;)&lt;/script&gt; 渲染结果： 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 当 :class 的表达式过长或逻辑复杂时，还可以绑定一个计算属性，这是一种很友好和常见的用法，一般当条件多于两个时，都可以使用 data 或 computed。 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;div :class=\"classes\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, error: null, &#125;, computed: &#123; classes: function() &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-fail': this.error &amp;&amp; this.error.type === 'fail', 'text': !this.error &#125; &#125; &#125; &#125;)&lt;/script&gt; 最终渲染结果： 1&lt;div class=\"active text\"&gt;&lt;/div&gt; 数组语法 给 :class 绑定一个数组，应用一个 class 列表。 123456789101112&lt;div id=\"app\"&gt; &lt;div :class=\"[activeCls, errorCls]\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; activeCls: 'active', errorCls: 'error' &#125; &#125;)&lt;/script&gt; 也可以在数组中使用对象语法： 123456789101112&lt;div id=\"app\"&gt; &lt;div :class=\"[&#123; 'active': isActive &#125;, errorCls]\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, errorCls: 'error' &#125; &#125;)&lt;/script&gt; 以上两个实例的最终渲染结果都为： 1&lt;div class=\"active error\"&gt;&lt;/div&gt; 当然，也可以和对象语法一样，使用 data, computed, metohds 三种方法。 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;button :class=\"classes\"&gt;&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; size: 'large', disabled: true &#125;, computed: &#123; classes: function() &#123; return [ 'btn', &#123; ['btn-' + this.size]: this.size !== '', ['btn-disabled']: this.disabled &#125; ]; &#125; &#125; &#125;)&lt;/script&gt; 最终渲染结果： 1&lt;button class=\"btn btn-large btn-disabled\"&gt;&lt;/button&gt; 使用计算属性给元素动态设置类名，在业务中经常用到，尤其在写复用的组件时，所以在开发过程中，如果表达式较长或逻辑复杂，应该尽量的优先使用计算属性。 组件上的使用 如果直接在自定义组件上使用 class 或 :class，样式规则会直接应用到个组件的根元素上： 123Vue.component('my-component', &#123; template: '&lt;p class=\"article\"&gt;some text&lt;/p&gt;'&#125;); 1234567891011&lt;div id=\"app\"&gt; &lt;my-component :class=\"&#123; 'active': isActive &#125;\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, &#125; &#125;)&lt;/script&gt; 绑定内联样式 使用 :style 可以给元素绑定内联样式，方法与 :class 类似，有对象语法和数组语法，看起来像直接在元素上写 CSS。 1234567891011121314&lt;div id=\"app\"&gt; &lt;div :style=\"styles\"&gt;context&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; styles: &#123; color: 'red', fontSize: 14 + 'px' &#125; &#125;, &#125;)&lt;/script&gt; 最终渲染结果： 1&lt;div style=\"color: red; font-size: 14px;\"&gt;context&lt;/div&gt; 在实际业务中，:style 的数组语法并不常用，一般写在 data 和 computed 中，较为常用的应当是计算属性： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;div :style=\"styles\"&gt;context&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', computed: &#123; styles: function() &#123; return &#123; color: 'yellow', fontSize: 18 + 'px' &#125; &#125; &#125; &#125;)&lt;/script&gt; 另外，使用 :style 时，Vue.js 会自动给特殊的 CSS 属性名称增加前缀，如 transform。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"}]},{"title":"LeetCode-QuickSort","slug":"algorithm_quick_sort/quick","date":"2019-11-15T16:00:00.000Z","updated":"2020-10-06T11:15:40.722Z","comments":true,"path":"2019/11/16/algorithm_quick_sort/quick/","link":"","permalink":"http://akashigakki.github.io/2019/11/16/algorithm_quick_sort/quick/","excerpt":"QuickSort 快速排序 - 递归分治为两个子数组，独立进行排序，主要在于切分元素的选择，左边子数组元素小于切分元素，右边子数组元素大于切分元素。","text":"QuickSort 快速排序 - 递归分治为两个子数组，独立进行排序，主要在于切分元素的选择，左边子数组元素小于切分元素，右边子数组元素大于切分元素。 快速排序的思想对于双边循环法，以两个指针和切分元素将数组进行递归切分，左边子数组元素小于切分元素，右边子数组元素大于切分元素，递归切分至最小元素时，自然实现排序(最小时包括一个左边元素，一个切分元素，一个右边元素，它们是有序的)。 对于单边循环法，只使用一个指针和切分元素将数组进行递归切分，并且使用一个标记指针记录切分边界的位置，当元素小于切分元素，移动标记元素并且与比较元素交换位置。 代码示例单边循环法 Java 实现 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Arrays;public class QuickSort &#123; public static void sort(int[] nums, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(nums, lo, hi); sort(nums, lo, j - 1); sort(nums, j + 1, hi); &#125; private static int partition(int[] nums, int lo, int hi) &#123; int pivot = nums[lo]; int mark = lo; for (int i = lo + 1; i &lt;= hi; i++) &#123; if (nums[i] &lt; pivot) &#123; mark++; swap(nums, mark, i); &#125; &#125; swap(nums, lo, mark); return mark; &#125; private static void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; public static void main(String[] args) &#123; int[] nums = new int[]&#123;3, 2, 6, 4, 1, 9, 7&#125;; QuickSort sort = new QuickSort(); sort.sort(nums, 0, nums.length - 1); System.out.println(Arrays.toString(nums)); &#125;&#125; Python 实现 1234567891011121314151617181920def sort(nums, low, high): if low &lt; high: key = partition(nums, low, high) sort(nums, low, key-1) sort(nums, key+1, high)def partition(nums, low, high): mark, key = low, nums[low] for i in range(low+1, high+1): if nums[i] &lt; key: mark += 1 nums[mark], nums[i] = nums[i], nums[mark] nums[low], nums[mark] = nums[mark], nums[low] return markif __name__ == \"__main__\": nums = [3, 2, 6, 4, 1, 9 ,7] sort(nums, 0, len(nums)-1) print(nums) 双边循环法 Java 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;public class Quick &#123; public static void sort(int[] nums, int lo, int hi) &#123; if (lo &gt;= hi) return; int pivot = partition(nums, lo, hi); sort(nums, lo, pivot-1); sort(nums, pivot+1, hi); &#125; public static int partition(int[] nums, int lo, int hi) &#123; int pivot = nums[lo]; int left = lo + 1; int right = hi; boolean done = true; while (done) &#123; while (left &lt;= right &amp;&amp; nums[left] &lt; pivot) left++; while (left &lt;= right &amp;&amp; nums[right] &gt; pivot) right--; if (left &gt; right) done = false; else swap(nums, left, right); &#125; swap(nums, lo, right); return right; &#125; private static void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;3, 2, 6, 4, 1, 9 ,7&#125;; Quick sort = new Quick(); sort.sort(nums, 0, nums.length-1); System.out.println(Arrays.toString(nums)); &#125;&#125; Python 实现 123456789101112131415161718192021222324252627def sort(nums, low, high): if low &lt; high: key = partition(nums, low, high) sort(nums, low, key-1) sort(nums, key+1, high)def partition(nums, low, high): left, right, key = low + 1, high, nums[low] done = True while done: while left &lt;= right and nums[left] &lt; key: left += 1 while left &lt;= right and nums[right] &gt; key: right -= 1 if left &gt; right: done = False else: nums[left], nums[right] = nums[right], nums[left] nums[low], nums[right] = nums[right], nums[low] return rightif __name__ == \"__main__\": nums = [3, 2, 6, 4, 1, 9 ,7] sort(nums, 0, len(nums)-1) print(nums)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"LeetCode-MergeSort","slug":"algorithm_merge_sort/merge","date":"2019-11-14T16:00:00.000Z","updated":"2020-10-06T11:15:40.722Z","comments":true,"path":"2019/11/15/algorithm_merge_sort/merge/","link":"","permalink":"http://akashigakki.github.io/2019/11/15/algorithm_merge_sort/merge/","excerpt":"MergeSort 归并排序 - 分治为子数组进行比较，然后归并。","text":"MergeSort 归并排序 - 分治为子数组进行比较，然后归并。 归并排序的思想归并，即将两个有序的数组归并成一个更大的有序数组。归并排序算法：要将一个数组排序，可以先递归的将它们分成两半进行排序，然后再将结果合并起来。合并时需要额外的空间进行操作。 原地归并排序将原数组递归分治为两个子数组进行比较，使用一个辅助数组进行归并。 在归并时，左半边用尽，取右半边元素；右半边用尽，取左半边元素；右半边当前元素小于左半边当前元素，取右半边元素，以及右半边当前元素大于左半边元素，取左半边元素。 Java 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;public class Merge &#123;// 原地归并排序 public void sort(int[] a, int lo, int hi) &#123; if (lo &gt;= hi) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid+1, hi); merge(a, lo, mid, hi); &#125; public static void merge(int[] nums, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; int[] aux = new int[nums.length]; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = nums[k]; &#125; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; else if (aux[j] &lt; aux[i]) nums[k] = aux[j++]; else nums[k] = aux[i++]; &#125; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;3, 2, 6, 4, 1, 9 ,7&#125;; Merge sort = new Merge(); sort.sort(nums, 0, nums.length-1); System.out.println(Arrays.toString(nums)); &#125;&#125; Python 实现 1234567891011121314151617181920212223242526272829303132333435def sort(nums): if len(nums) &lt; 2: return nums mid = len(nums) // 2 left = nums[:mid] right = nums[mid:] sort(left) sort(right) i, j, k = 0, 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: nums[k] = left[i] i += 1 else: nums[k] = right[j] j += 1 k += 1 while i &lt; len(left): nums[k] = left[i] i += 1 k += 1 while j &lt; len(right): nums[k] = right[j] j += 1 k += 1if __name__ == \"__main__\": nums = [3, 2, 6, 4, 1, 9 ,7] sort(nums) print(nums) 另一种实现方式(个人感觉更简洁)： 123456789101112131415161718192021222324252627282930def sort(nums): if len(nums) &lt; 2: return nums mid = len(nums) // 2 left = sort(nums[:mid]) right = sort(nums[mid:]) return merge(left, right)def merge(left, right): i, j = 0, 0 aux = list() while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: aux.append(left[i]) i += 1 else: aux.append(right[j]) j += 1 aux += left[i:] aux += right[j:] return auxif __name__ == \"__main__\": nums = [3, 2, 6, 4, 1, 9 ,7] res = sort(nums) print(res) 自顶向下的归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;public class MergeUB &#123;// 自顶向下的归并排序 private static int[] aux; public void sort(int[] a) &#123; aux = new int[a.length]; sort(a, 0, a.length-1); &#125; public static void sort(int[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid+1, hi); merge(a, lo, mid, hi); &#125; public static void merge(int[] nums, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = nums[k]; &#125; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; else if (aux[j] &lt; aux[i]) nums[k] = aux[j++]; else nums[k] = aux[i++]; &#125; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;3, 2, 6, 4, 1, 9 ,7&#125;; MergeUB sort = new MergeUB(); sort.sort(nums); System.out.println(Arrays.toString(nums)); &#125;&#125; 自底向上的归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Arrays;public class MergeBU &#123;// 自底向上的归并排序 private static int[] aux; public void sort(int[] a) &#123; int N = a.length; aux = new int[N]; for (int size = 1; size &lt; N; size = size + size) &#123; for (int lo = 0; lo &lt; N-size; lo += size + size) &#123; merge(a, lo, lo+size-1, Math.min(lo+size+size-1, N-1)); &#125; &#125; &#125; public static void merge(int[] nums, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = nums[k]; &#125; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; else if (aux[j] &lt; aux[i]) nums[k] = aux[j++]; else nums[k] = aux[i++]; &#125; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;3, 2, 6, 4, 1, 9 ,7&#125;; MergeBU sort = new MergeBU(); sort.sort(nums); System.out.println(Arrays.toString(nums)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"LeetCode-InsertionSort","slug":"algorithm_insertion_sort/insertion","date":"2019-11-13T16:00:00.000Z","updated":"2020-10-06T11:15:40.722Z","comments":true,"path":"2019/11/14/algorithm_insertion_sort/insertion/","link":"","permalink":"http://akashigakki.github.io/2019/11/14/algorithm_insertion_sort/insertion/","excerpt":"InsertionSort 插入排序 - 后一位与前面数组进行比较。","text":"InsertionSort 插入排序 - 后一位与前面数组进行比较。 插入排序的思想指定两个指针，从数组头部开始，第一个指针控制有序数组的边界，从 1 开始，另一个指针进行比较操作，控制子数组(有序数组)边界的元素，与前面有序数组进行比较，如果小于前一个元素，就和前一个元素交换位置，完成一次比较。 代码示例 Java 实现 123456789101112131415161718192021222324import java.util.Arrays;public class Insertion &#123; public void sort(int[] nums) &#123; for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; j--) &#123; swap(nums, j, j-1); &#125; &#125; &#125; private static void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;3, 2, 6, 4, 1, 9 ,7&#125;; Insertion sort = new Insertion(); sort.sort(nums); System.out.println(Arrays.toString(nums)); &#125;&#125; 外层循环确定有序数组的边界和循环次数(从 1 开始)，内层循环控制子数组中的比较操作，将新加入子数组中的元素与之前的元素进行比较，并插入到数组中的合适位置。 Python 实现 123456789101112131415161718192021class Insertion(): def __init__(self, nums): self.nums = nums self.length = len(nums) def sort(self): for i in range(1, self.length): j = i while j and self.nums[j] &lt; self.nums[j-1]: self.nums[j], self.nums[j-1] = self.nums[j-1], self.nums[j] j -= 1 def show(self): print(self.nums)if __name__ == \"__main__\": nums = [3, 2, 6, 4, 1, 9 ,7] sort = Insertion(nums) sort.sort() sort.show() 简化版 1234567891011121314def sort(nums): length = len(nums) for i in range(1, length): j = i while j and nums[j] &lt; nums[j-1]: nums[j], nums[j-1] = nums[j-1], nums[j] j -= 1 return numsif __name__ == \"__main__\": nums = [3, 2, 6, 4, 1, 9 ,7] res = sort(nums) print(res) 插入排序所需的时间取决于输入中元素的初始位置。如果对一个有序或接近有序的数组进行排序，效率会比随机数组有效的多。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"LeetCode-SelectionSort","slug":"algorithm_selection_sort/selection","date":"2019-11-12T16:00:00.000Z","updated":"2020-10-06T11:15:40.723Z","comments":true,"path":"2019/11/13/algorithm_selection_sort/selection/","link":"","permalink":"http://akashigakki.github.io/2019/11/13/algorithm_selection_sort/selection/","excerpt":"SelectionSort 选择排序 - 前一位和后面的数组进行比较。","text":"SelectionSort 选择排序 - 前一位和后面的数组进行比较。 选择排序的思想指定两个指针，从数组头部开始，将第一个与数组后面的数字逐一进行比较，如果第一个元素小于后面相比较的元素时，交换他们的位置，否则，位置不变，直到数组末尾，完成一轮比较。 结束一轮比较之后，数组第一个元素即为数组中最小的元素，指针向前移动一个位置，继续重复过程比较，直到最终获得一个有序的数组。 代码示例 Java 实现 1234567891011121314151617181920212223242526import java.util.Arrays;public class Selection &#123; public void sort(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; if (nums[i] &gt; nums[j]) &#123; swap(nums, i, j); &#125; &#125; &#125; &#125; private static void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;3, 2, 6, 4, 1, 9 ,7&#125;; Selection sort = new Selection(); sort.sort(nums); System.out.println(Arrays.toString(nums)); &#125;&#125; 外部循环控制第一个比较元素，即循环次数，内部循环控制第二个元素，并与第一个元素进行比较，符合条件，则进行交换。 Python 实现 1234567891011121314151617181920class Selection(): def __init__(self, nums): self.nums = nums self.length = len(nums) def sort(self): for i in range(self.length): for j in range(i+1, self.length): if self.nums[i] &gt; self.nums[j]: self.nums[i], self.nums[j] = self.nums[j], self.nums[i] def show(self): print(self.nums)if __name__ == \"__main__\": nums = [2, 3, 1, 6, 4, 9, 7] sort = Selection(nums) sort.sort() sort.show() 简化版 12345678910111213def sort(nums): length = len(nums) for i in range(length): for j in range(i+1, length): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return numsif __name__ == \"__main__\": nums = [2, 3, 1, 6, 4, 9, 7] res = sort(nums) print(res) 选择排序在第一次外部循环找到数组中最小的元素，将它和数组中第一个的元素位置交换(如果第一个元素最小就和自己交换)，然后，进入第二次外部循环，在剩下的元素中，找到最小的元素，与第二个元素的位置交换，如此往复，完成数组排序。 因为每一次遍历一遍找出的都是最小的元素，并不能为下一次扫描提供什么信息，一个有序的数组和一个元素随机的数组排列所需的时间是一样的。 交换次数和数组大小是线性关系，数据的移动是最少的。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"LeetCode-BubbleSort","slug":"algorithm_bubble_sort/bubble","date":"2019-11-11T16:00:00.000Z","updated":"2020-10-06T11:15:40.721Z","comments":true,"path":"2019/11/12/algorithm_bubble_sort/bubble/","link":"","permalink":"http://akashigakki.github.io/2019/11/12/algorithm_bubble_sort/bubble/","excerpt":"BubbleSort 冒泡排序 - 相邻两个元素进行比较。","text":"BubbleSort 冒泡排序 - 相邻两个元素进行比较。 冒泡排序的思想指定两个指针，从数组头部开始，把相邻的两个元素进行比较，当前一个元素大于后一个元素时，交换他们的位置，否则，位置不变，直到数组末尾，完成一轮比较。 结束一轮比较，获得数组中最大的元素，在数组末尾。接下来重复这个过程，在剩下的元素中进行比较，最终得到一个有序的数组。 代码示例 Java 实现 1234567891011121314151617181920212223242526272829303132import java.util.Arrays;public class Bubble &#123; public void sort(int[] nums) &#123;// 标记每轮遍历中数字是否发生了交换 boolean hasChange = true; for (int i = 0; i &lt; nums.length-1 &amp;&amp; hasChange; i++) &#123; hasChange = false; for (int j = 0; j &lt; nums.length-1-i; j++) &#123; if (nums[j] &gt; nums[j+1]) &#123; swap(nums, j, j+1); hasChange = true; &#125; &#125; &#125; &#125; private static void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; public static void main(String[] args) &#123; int[] nums = new int[] &#123;2, 3, 1, 6, 4, 9, 7&#125;; Bubble sort = new Bubble(); sort.sort(nums); System.out.println(Arrays.toString(nums)); &#125;&#125; 外部循环控制循环次数，内部循环实现每一轮冒泡处理：先元素比较，然后进行元素交换。 加入一个有序标记，如果元素没有发生交换，证明数组已经是有序的，结束循环。 Python 实现 123456789101112131415161718192021222324class Bubble(): def __init__(self, nums): self.nums = nums self.length = len(nums) self.has_change = True def sort(self): for i in range(self.length-1): if self.has_change: self.has_change = False for j in range(self.length-1-i): if self.nums[j] &gt; self.nums[j+1]: self.nums[j], self.nums[j+1] = self.nums[j+1], self.nums[j] self.has_change = True def show(self): print(self.nums)if __name__ == \"__main__\": nums = [2, 3, 1, 6, 4, 9, 7] sort = Bubble(nums) sort.sort() sort.show() 简化版 12345678910111213def sort(nums): length = len(nums) for i in range(length-1): for j in range(length-1-i): if nums[j] &gt; nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] return numsif __name__ == \"__main__\": nums = [2, 3, 1, 6, 4, 9, 7] res = sort(nums) print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之标准库","slug":"python_adv_modular/adv_modular","date":"2019-11-10T16:00:00.000Z","updated":"2020-10-06T11:15:40.833Z","comments":true,"path":"2019/11/11/python_adv_modular/adv_modular/","link":"","permalink":"http://akashigakki.github.io/2019/11/11/python_adv_modular/adv_modular/","excerpt":"标准库 标准库：一些常用的模块。","text":"标准库 标准库：一些常用的模块。 探索模块 使用 dir 要查明模块包含哪些东西，可以使用函数 dir，它列出对象的所有属性 123&gt;&gt;&gt; import copy&gt;&gt;&gt; dir(copy)['Error', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_copy_dispatch', '_copy_immutable', '_deepcopy_atomic', '_deepcopy_dict', '_deepcopy_dispatch', '_deepcopy_list', '_deepcopy_method', '_deepcopy_tuple', '_keep_alive', '_reconstruct', 'copy', 'deepcopy', 'dispatch_table', 'error'] 为方便阅读，可以去掉下划线打头的不提供外部使用的函数： 1[n for n in dir(copy) if not n.startswith('_')] 变量 __all__ 查看模块具体导入可用的内容 123&gt;&gt;&gt; import copy&gt;&gt;&gt; copy.__all__['Error', 'copy', 'deepcopy'] 这样就可以看到模块 copy 可以使用的公有接口 使用 help 函数 help 提供一些你需要的信息 12&gt;&gt;&gt; import sys&gt;&gt;&gt; help(sys) 查看文档 12&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.__doc__) sys访问和 Python 解释其相关的变量和函数。 函数 描述 argv 获取命令行参数，返回值是List，第一个元素是程序本身路径 exit([arg]) 退出当前程序，可以通过可选参数指定返回值或错误消息 modules 一个字典，将模块名映射到加载的函数 path 一个列表，返回模块的搜索路径 platform 返回操作系统的名称 stdin 标准输入流 stdout 标准输出流 stderr 标准错误流 version 解释器版本信息 argv 命令行执行，实现从外部传入参数 python3 test.py arg1 arg2 123import sysprint(sys.argv) 输出： 1['test.py', 'arg1', 'arg2'] exit([arg]) 123import sysprint(sys.exit(\"运行结束.\")) os访问和操作系统相关的变量和函数。 模块 描述 getcwd 获取当前的工作目录 chdir 修改当前工作目录 listdir 获取指定文件夹中的所有文件和文件夹组成的列表 mkdir 创建一个目录/文件夹 makedirs 递归创建文件夹 rmdir 移除一个目录（必须是空目录） removedirs 递归删除文件夹 rename 修改文件和文件夹的名称 stat 获取文件的相关信息 system 执行系统命令 getenv 获取系统环境变量 putenv 设置系统环境变量 exit 退出当前执行命令，直接关闭当前操作 unlink 删除文件 open 新建文件 path 模块 12&gt;&gt;&gt; os.path.__all__['normcase', 'isabs', 'join', 'splitdrive', 'split', 'splitext', 'basename', 'dirname', 'commonprefix', 'getsize', 'getmtime', 'getatime', 'getctime', 'islink', 'exists', 'lexists', 'isdir', 'isfile', 'ismount', 'expanduser', 'expandvars', 'normpath', 'abspath', 'samefile', 'sameopenfile', 'samestat', 'curdir', 'pardir', 'sep', 'pathsep', 'defpath', 'altsep', 'extsep', 'devnull', 'realpath', 'supports_unicode_filenames', 'relpath', 'commonpath'] 函数 描述 abspath() 将一个相对路径转化为绝对路径 basename() 获取路径中的文件夹或者文件名称（只要路径的最后一部分） dirname() 获取路径中的路径部分(除去最后一部分) join() 将两个路径合并为一个路径 split() 将一个路径切割成文件夹和文件名部分 splitext() 将一个文件名切成名字和后缀两个部分 getsize() 获取一个文件的大小 isfile() 检测一个路径是否是一个文件 isdir() 检测一个路径是否是一个文件夹 getctime() 获取文件的创建时间 getmtime() 获取文件的修改时间 getatime() 获取文件的访问时间 exists() 检测指定的路径是否存在 isabs() 检测一个路径是否是绝对路径 islink() 检测一个路径是否是链接 samefile() 检测两个路径是否指向同一个文件 参考： os path fileinput迭代多个文件或流的内容行。 123&gt;&gt;&gt; import fileinput&gt;&gt;&gt; fileinput.__all__['input', 'close', 'nextfile', 'filename', 'lineno', 'filelineno', 'fileno', 'isfirstline', 'isstdin', 'FileInput', 'hook_compressed', 'hook_encoded'] shutil拷贝、移动文件。 123&gt;&gt;&gt; import shutil&gt;&gt;&gt; shutil.__all__['copyfileobj', 'copyfile', 'copymode', 'copystat', 'copy', 'copy2', 'copytree', 'move', 'rmtree', 'Error', 'SpecialFileError', 'ExecError', 'make_archive', 'get_archive_formats', 'register_archive_format', 'unregister_archive_format', 'get_unpack_formats', 'register_unpack_format', 'unregister_unpack_format', 'unpack_archive', 'ignore_patterns', 'chown', 'which', 'get_terminal_size', 'SameFileError', 'disk_usage'] 函数 描述 copyfileobj(f1, f2) 将 f1 的数据覆盖 copy 给 f2，需打开文件 copyfile(f1, f2) 不用打开文件，直接用文件名进行覆盖 copy copymode(f1, f2) 拷贝权限，内容组，用户，均不变 copystat(f1, f2) 只拷贝了权限 copy(f1, f2) 拷贝文件和权限都进行 copy copy2(f1, f2) 拷贝了文件和状态信息 rmtree(dir) 可以递归删除目录下的目录及文件 move(dir, f) 递归移动一个文件 参考： shutil time获取时间、操作时间和日期以及设置它们格式。 时间的表示方式： 时间戳 timestamp - 新纪元开始后的秒数(1970年1月1日00:00:00开始按秒计算的偏移量) 格式化的时间字符串 结构化时间元组 - struct_time 函数 描述 localtime([secs]) 将秒数(时间戳)转换为表示当地时间的结构化时间元组 gmtime() 将时间戳转换为结构化时间 mktime(tuple) 将结构化时间转换为时间戳 sleep(ses) 休眠，什么都不做 asctime([tuple]) 将结构化时间转换为字符串 strptime(string[, format]) 将字符串转换为结构化时间 time() 当前时间戳(浮点类型) ctime() 当前时间字符串 123456789graph TBA[struct_time] --&gt;|strftime| B[Format string]B[Format string] --&gt;|strptime| A[struct_time]A[struct_time] --&gt;|mktime| C[Timestamp]C[Timestamp] --&gt;|localtime, gmtime| A[struct_time] 当前时间戳 - time() 123&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1573438880.298209 当前时间字符串 - ctime() 123&gt;&gt;&gt; import time&gt;&gt;&gt; time.ctime()'Mon Nov 11 10:21:08 2019' 当前结构化时间元组 123&gt;&gt;&gt; import time&gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2019, tm_mon=11, tm_mday=11, tm_hour=10, tm_min=23, tm_sec=28, tm_wday=0, tm_yday=315, tm_isdst=0) 休眠 12&gt;&gt;&gt; import time&gt;&gt;&gt; time.sleep(10) datetimetiem 模块的高级封装，接口更加直观。 首先查看模块下面的类： 123import datetime&gt;&gt;&gt; [n for n in dir(datetime) if not n.startswith('_')]['MAXYEAR', 'MINYEAR', 'date', 'datetime', 'datetime_CAPI', 'sys', 'time', 'timedelta', 'timezone', 'tzinfo'] datetime 模块中包含的类： 类名 功能说明 date 日期对象,常用的属性有 year, month, day time 时间对象 datetime 日期时间对象,常用的属性有 hour, minute, second, microsecond datetime_CAPI 日期时间对象C语言接口 timedelta 时间间隔，即两个时间点之间的长度 tzinfo 时区信息对象 datetime 获取当前结构化时间 - today()、now() 12345&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.today()datetime.datetime(2019, 11, 11, 11, 9, 38, 648690)&gt;&gt;&gt; datetime.datetime.now()datetime.datetime(2019, 11, 11, 11, 9, 43, 735714) 可用函数： 123&gt;&gt;&gt; import datetime&gt;&gt;&gt; [n for n in dir(datetime.datetime) if not n.startswith('_')]['astimezone', 'combine', 'ctime', 'date', 'day', 'dst', 'fold', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'hour', 'isocalendar', 'isoformat', 'isoweekday', 'max', 'microsecond', 'min', 'minute', 'month', 'now', 'replace', 'resolution', 'second', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'today', 'toordinal', 'tzinfo', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday', 'year'] random生成随机数。 123&gt;&gt;&gt; import random&gt;&gt;&gt; random.__all__['Random', 'seed', 'random', 'uniform', 'randint', 'choice', 'sample', 'randrange', 'shuffle', 'normalvariate', 'lognormvariate', 'expovariate', 'vonmisesvariate', 'gammavariate', 'triangular', 'gauss', 'betavariate', 'paretovariate', 'weibullvariate', 'getstate', 'setstate', 'getrandbits', 'choices', 'SystemRandom'] 函数 描述 random() 返回一个 [0, 1) 的随机实数 uniform(a, b) 返回一个 [a, b] 的随机实数 randrange([start], stop, [step]) 从 range(start, stop, step) 中随机选择一个数 choice(seq) 从序列中随机选择一个元素 shuffle(seq[, random]) 就地打乱序列 seq sample(seq, n) 从序列 seq 中随机选择 n 个不同的元素值 json序列化。 123&gt;&gt;&gt; import json&gt;&gt;&gt; json.__all__['dump', 'dumps', 'load', 'loads', 'JSONDecoder', 'JSONDecodeError', 'JSONEncoder'] 函数 描述 dump(fileobj) 字典转成 json 字符串，用于文件 dumps(str) 字典转成 json 字符串 load(fileobj) json 字符串转成字典，用于文件 loads(str) json 字符串转成字典 re正则表达式。 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.__all__['match', 'fullmatch', 'search', 'sub', 'subn', 'split', 'findall', 'finditer', 'compile', 'purge', 'template', 'escape', 'error', 'Pattern', 'Match', 'A', 'I', 'L', 'M', 'S', 'X', 'U', 'ASCII', 'IGNORECASE', 'LOCALE', 'MULTILINE', 'DOTALL', 'VERBOSE', 'UNICODE'] 函数 描述 match(pattern, string[, flags]) 在字符串开头匹配模式 search(pattern, string[, flags]) 在字符串中查找模式 sub(pat, repl, string[, count=0]) 将字符串中与模式 pat 匹配的子串都替换为 repl split(pattern, string[, maxsplit=0]) 根据模式来分割子串 findall(pattren, string) 返回一个列表，其中包含字符串中所有与模式匹配的子串 compile(pattern[, flags]) 根据包含正则表达式的字符串创建模式对象 logging日志。 123&gt;&gt;&gt; import logging&gt;&gt;&gt; logging.__all__['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR', 'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO', 'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler', 'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig', 'captureWarnings', 'critical', 'debug', 'disable', 'error', 'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass', 'info', 'log', 'makeLogRecord', 'setLoggerClass', 'shutdown', 'warn', 'warning', 'getLogRecordFactory', 'setLogRecordFactory', 'lastResort', 'raiseExceptions'] collections内建集合模块，提供多个集合类。 123&gt;&gt;&gt; import collections&gt;&gt;&gt; collections.__all__['deque', 'defaultdict', 'namedtuple', 'UserDict', 'UserList', 'UserString', 'Counter', 'OrderedDict', 'ChainMap'] 函数 描述 namedtuple() 创建一个自定义的 tuple 对象 deque() 高效实现插入和删除操作的双向列表，适合用于队列和栈 defaultdict() 字典，当 key 不存在时，返回一个默认值 OrderedDict() 有序字典 Counter() 计数器 namedtuple 1234567&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1&gt;&gt;&gt; p.y2 deque 123456&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque(['a', 'b', 'c'])&gt;&gt;&gt; q.append('x')&gt;&gt;&gt; q.appendleft('y')&gt;&gt;&gt; qdeque(['y', 'a', 'b', 'c', 'x']) 参考：collections","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之特性、迭代器和生成器","slug":"python_adv_character/adv_character","date":"2019-11-09T16:00:00.000Z","updated":"2020-10-06T11:15:40.831Z","comments":true,"path":"2019/11/10/python_adv_character/adv_character/","link":"","permalink":"http://akashigakki.github.io/2019/11/10/python_adv_character/adv_character/","excerpt":"特性、迭代器和生成器 Python 中的魔法(特殊)方法。","text":"特性、迭代器和生成器 Python 中的魔法(特殊)方法。 首先，所有的类都将隐式的继承 object 类，如果没有指定超类，将直接继承它，否则将间接的继承它。 构造函数 介绍的第一个魔法方法是构造函数，其实就是初始化方法，命名为 __init__。 构造函数将在对象创建后自动调用它们 1234567class Foobar: def __init__(self): self.somevar = 42if __name__ == \"__main__\": f = Foobar() print(f.somevar) 或者，给构造函数添加参数 123class Foobar: def __init__(self, value=42): self.somevar = value 参数是可选的，可以使用默认的参数值，也可以传入指定的参数值，对原有的值进行覆盖 重写 每一个类都有一个或多个超类，并从它们那里继承行为。 对于大多数的子类，重写构造函数时，必须调用超类的构造函数，否则可能无法正确的初始化对象 12345678910111213141516171819202122class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print('Aaaah...') self.hungry = False else: print('No, thanks!')class SongBird(Bird): def __init__(self): self.sound = 'Squawk!' def sing(self): print(self.sound)if __name__ == \"__main__\": s = SongBird() s.eat() 这时，执行程序，你会发现无法正确的初始化对象，提示对象没有 hungry 属性 这是因为子类重写了构造函数，但是并没有初始化父类的构造函数 调用未关联的超类构造函数由于历史遗留问题，我们先介绍旧版 Python 的初始化方式： 1234567class SongBird(Bird): def __init__(self): Bird.__init__(self) self.sound = 'Squawk!' def sing(self): print(self.sound) 修改之后再次执行，会发现已经可正确的初始化了 但是在新式类中，我们应该避免这种初始化方式，而使用 super 使用函数 super使用 super 时通常不用提供任何参数 1234567class SongBird(Bird): def __init__(self): super().__init__() self.sound = 'Squawk!' def sing(self): print(self.sound) 当然，如果子类没有重写构造函数，那么默认继承了父类的构造函数，可以直接使用 元素访问基本的序列和映射协议序列和映射基本上是元素的集合，要实现它们的基本行为，不可变对象需要实现2个方法，可变对象需要实现4个 __len__(self) 返回集合包含的项数 __getitem__(self, key) 返回与指定键相关联的值 __setitem__(self, key, value) 以键相关联的方式存储值 __delitem__(self, key) 当对象可变(且允许被删除时)，才需要实现 下面创建一个无穷序列 123456789101112131415161718192021222324252627282930313233def check_index(key): # 判断 if not isinstance(key, int): raise TypeError if key &lt; 0: raise IndexErrorclass ArithmeticSequence: def __init__(self, start=0, step=1): # 初始化 self.start = start self.step = step self.changed = &#123;&#125; def __getitem__(self, key): # 获取 check_index(key) try: # 如果元素已被修改，存储元素的值 return self.changed[key] except KeyError: # 如果元素未被修改，计算出元素的值 return self.start + key * self.step def __setitem__(self, key, value): # 修改 check_index(key) self.changed[key] = valueif __name__ == \"__main__\": # 创建一个从1开始，步长为2的无穷序列 s = ArithmeticSequence(1, 2) print(s[4]) 这里我们没有实现 __del__，意味着不允许删除元素 从 list、dict、str派生快速实现一个序列和映射，可以从已有的基本序列和映射继承，通过重写魔法方法，实现一个新的序列或映射，例如： 实现一个计算器列表： 12345678class CounterList(list): def __init__(self, *args): super.__init__(*args) self.counter = 0 def __getitem__(self, index): self.counter += 1 return super(CounterList, self).__getitem__(index) 特性之前有介绍 set 和 get 的存取方法，是一种很重要的封装状态变量(属性)的方法。但我们没有办法将所有属性都提供存取方法，这是不现实的，所以我们采用另外一种方法 —— property。它可以隐藏存取方法，让所有属性看起来都一样。 通过存取方法定义的属性通常称为特性。 函数 property123456789101112131415161718class Rectangle: def __init__(self): self.width = 0 self.height = 0 def get_size(self): return self.width, self.height def set_size(self, size): self.width, self.height = size size = property(get_size, set_size)if __name__ == \"__main__\": r = Rectangle() r.width = 5 r.height = 10 print(r.size) 这样，size 属性依然受制于 set 和 get 执行计算，但是看起来就像普通属性一样 或者使用装饰器实现 123456789101112131415161718class Rectangle: def __init__(self): self.width = 0 self.height = 0 @property def size(self): return self.width, self.height @size.setter def size(self, size): self.width, self.height = size if __name__ == \"__main__\": r = Rectangle() r.width = 5 r.height = 10 print(r.size) 静态方法和类方法静态方法和类方法在创建的过程中是分别包装在 staticmethod 和 classmethod 类的对象中的 静态方法的定义中，没有参数 self，可以直接通过类来调用 类方法的定义中包含类似于 self 的参数，通常被命名为 cls，对与类方法，也可以通过对象直接调用，但参数 cls 将自动关联到类 12345678910111213class MyClass: def smeth(): print('This is a static method') smeth = staticmethod(smeth) def cmeth(cls): print('Tish is a class method of', cls) cmeth = classmethod(cmeth)if __name__ == \"__main__\": m = MyClass() m.smeth() m.cmeth() 在引入装饰器(装饰器可以用于包装任何可调用的对象，并且可用于方法和函数)以后，还可以用于这样包装方法 123456789101112class MyClass: @staticmethod def smeth(): print('This is a static method') @classmethod def cmeth(cls): print('Tish is a class method of', cls)if __name__ == \"__main__\": MyClass.smeth() MyClass.cmeth() 定义方法后，无需实例化，可以直接使用它们 更多装饰器实现，参考 @property、装饰器 __getattr__、__setattr__ __getattr__(self, name) 在属性被访问而对象没有这样的属性时自动调用 __setattr__(self, name, value) 试图给属性赋值时自动调用 使用上面的方法可以编写处理多个特性的代码，但是，在可能的情况下，还是使用函数 property 代替比较好(出于使用方式和效率的考虑) 迭代器 迭代，意味着重复多次，就像循环那样，实现了 __iter__ 的对象是可迭代的。 方法 __iter__ 返回一个迭代器，它是包含方法 __next__ 的对象，而调用方法时可以不提供任何参数。 在某些情况下，你可能只想逐个地获取值，而不是使用列表一次性获取，因为如果值很多，列表可能占用太多的内存，然而使用迭代器更通用、更简单、更优雅 123456789101112131415161718class Fibs: def __init__(self): self.a = 0 self.b = 1 def __next__(self): self.a, self.b = self.b, self.a + self.b return self.a def __iter__(self): return selfif __name__ == \"__main__\": fibs = Fibs() for f in fibs: print(f) if f &gt; 100: break 实现了方法 __iter__ 的对象是可迭代的，而实现方法 __next__ 的对象是迭代器 1234567891011121314class TestIterator: value = 0 def __next__(self): self.value += 1 if self.value &gt; 10: raise StopIteration return self.value def __iter__(self): return selfif __name__ == \"__main__\": t = TestIterator() print(list(t)) 生成器 生成器是一中使用普通函数语法定义的迭代器。 生成器使用 yied 语句进行创建，之前有简单介绍，也可以说包含 yield 语句的函数称作生成器 现在我们使用一个生成器展开一个嵌套列表： 1234567def flatten(nested): for sublist in nested: for element in sublist: yield elementnested = [[1, 2,], [3, 4], [5]]print(list(flatten(nested))) 输出： 1[1, 2, 3, 4, 5]","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之再谈抽象","slug":"python_adv_abstract_more/adv_abs_more","date":"2019-11-08T16:00:00.000Z","updated":"2020-10-06T11:15:40.830Z","comments":true,"path":"2019/11/09/python_adv_abstract_more/adv_abs_more/","link":"","permalink":"http://akashigakki.github.io/2019/11/09/python_adv_abstract_more/adv_abs_more/","excerpt":"再谈抽象 封装、继承和多态。","text":"再谈抽象 封装、继承和多态。 封装 对外部隐藏有关对象工作原理的细节。 封装指的是向外隐藏不必要的细节，让你无需知道对象内部的细节就可以使用它。 假设我们有一个名为 OpenObject 的类，存在 set_name() 和 get_name() 方法： 1234&gt;&gt;&gt; o = OpenObject()&gt;&gt;&gt; o.set_name('akashi')&gt;&gt;&gt; o.get_name()'akashi' 具体实现： 123456class Person: def set_name(self, name): self.name = name def get_name(self): return self.name 这是属于方法上的封装，还可以在属性上进行封装，让外部不能访问 再谈隐藏将属性定义为私有，私有属性不能从对象外部进行访问，而只能通过存取器方法(get_name 和 set_name)访问 通常在 python 中，更常见的做法是使用特性(property)来替代存取器 让方法和属性设置为私有的，可以在名称前以两个下划线打头，例如：self.__name = name 然而在 python 中并没有真正支持私有化，使用 _类名__方法名 这种方式依然可以在外部访问，但是隐藏就是我们对外部发出的信号，让外部不要访问，所有开发中我们不应这样做 在 python 中，单下划线开始的成员变量叫保护变量，只有类对象（即类实例）和子类对象自己能访问到这些变量，需通过类提供的接口进行访问 双下划线开始的成员变量叫私有变量，只有类对象自己可以访问，连子类对象也不可以访问 继承 基于通用类创建出专用类，子类是对父类的扩充。 继承可以达到代码和功能复用的目的，并且子类可以对父类进行功能上的扩充。 12class Children(Person): pass 要确定一个类是否是另一个类的子类，可以使用内置方法 issubclass 12&gt;&gt;&gt; issubclass(Children, Person)True 如果你有一个类，想知道他的基类，可以访问其特殊属性 __bases__ 1&gt;&gt;&gt; Children.__bases__ 同样，确定对象是否是特定类的实例，可以使用 isinstance 123&gt;&gt;&gt; s = Children()&gt;&gt;&gt; isinstance(s, Children)True 多个超类Python 是支持多继承的，然而，除非万不得已，否则应该避免使用多重继承，因为在有些情况下，它可能带来意外的 “并发症” 多态 可对不同类型的对象执行相同的操作，表现在方法的重载和覆写、对象的向上转型。 多态意味着 多种形态，我认为是最重要的原则，这意味着你不知道变量指向的是那种对象，也可以对其执行操作，且操作的行为会随对象的类型而表现出不同 如： 1234&gt;&gt;&gt; 'abc'.count('a')1&gt;&gt;&gt; [1, 2, 'a'].count('a')1 像这样，方法 count 对于字符串和列表都可以使用，根据对象的不同做出不同的表现，这就是多态 相反，在使用时，我们只需要知道对象有 count 这个方法就可以了，它会根据不同的对象有不同的表现方式 另一个例子就是内置的运算符： 123456&gt;&gt;&gt; 1 + 23&gt;&gt;&gt; 'akashi' + 'sai'akashisai&gt;&gt;&gt; [1, 2] + [3, 4, 5][1, 2, 3, 4, 5] 在实现时，是依赖于对象的向上转型，使多态发生作用，这一点在静态类型语言中表现更为明显，以 Java 为例： 1234Shape rect = new Rectangle()Shape cir = new Circle()rect.draw()cir.draw() 接口和内省 (Java 单继承的局限、与多态相关) 接口这一概念与多态相关，处理多态对象时，我们只关心其接口(协议对外暴露的方法和属性。在 Python 中，不显示地指定对象必须包含哪些方法才能用作参数。不会像 Java 和 Go 那样显示编写接口，而是假定对象能够完成你要求它完成的任务，如果不能完成，程序将失败。 抽象基类 利用抽象基类可以实现对子类覆写方法的控制。 Python 在多态上几乎都只依赖于鸭子类型(如果走起来像鸭子，叫起来像鸭子，那么它就是鸭子)，然而官方也通过引入模块 abc 提供了抽象基类的支持，抽象基类是不能实例化的类，子类需要实现抽象基类的所有抽象方法。 123456from abc import ABC, abstractmethodclass Talker(ABC): @abstractmethod def talk(self): pass 123class Herring(Talker): def talk(self): print(\"Blub.\")","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之抽象","slug":"python_adv_abstract/adv_abs","date":"2019-11-06T16:00:00.000Z","updated":"2020-10-06T11:15:40.830Z","comments":true,"path":"2019/11/07/python_adv_abstract/adv_abs/","link":"","permalink":"http://akashigakki.github.io/2019/11/07/python_adv_abstract/adv_abs/","excerpt":"抽象 抽象可以节省人力，更重要的是，抽象是程序能够被人理解的关键所在。","text":"抽象 抽象可以节省人力，更重要的是，抽象是程序能够被人理解的关键所在。 自定义函数现在，如果我们需要计算一个裴波那契序列，我们编写如下面的代码： 12345fibs = [0, 1]for i in range(8): fibs.append(fibs[-2] + fibs[-1])print(fibs) 这样，我们得到了一个数列 1[0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 现在需求变了，我们需要用户可以指定序列的长度，再次编写如下代码： 123456fibs = [0, 1]num = int(input('How many Fibonacci numbers do you want?\\n'))for i in range(num - 2): fibs.append(fibs[-2] + fibs[-1])print(fibs) 现在，已经像是一个可用的程序的样子了，但是我们需要写出的代码是可以复用的，我们便会想到把它封装在一个自定义的函数里面 12345678910def fibs(num): result = [0, 1] for i in range(num-2): result.append(result[-2] + result[-1]) return resultif __name__ == \"__main__\": res = fibs(10) print(res) 这样，以后只需要直接调用函数 fibs() 就可以轻松获得序列了。 这是一个函数定义的过程，也是问题抽象的过程。 参数魔法位置参数函数参数传入的位置是有区别的，如下面的实例： 12345def hello(greeting, name): print('&#123;&#125;, &#123;&#125;!'.format(greeting, name))if __name__ == \"__main__\": hello('Hello', 'akashi') 输出： Hello, akashi! 如果我们传入参数的位置发生了变化，结果也会发生变化： 1hello('akashi', 'Hello') 输出：akashi, Hello! 程序并不能按照我们的意图执行，它不知道参数的正确位置，需要我们传入时就规定好位置 关键字参数和默认值想要程序知道参数的正确位置，可以使用关键字参数 1hello(name='akashi', greeting='Hello') 这样，指明了关键字，就可以不按位置传递参数 如果直接在定义函数中规定默认参数的值，调用时可以不用传递，但传入即会覆盖默认的参数 收集参数 通过 * 可以传入一个元组 12345def print_params(*params): print(params)if __name__ == \"__main__\": print_params(1, 2, 3) 输出：(1 2 3) 当收集的元组参数在中间位置时，需要指定后续参数： 12345def in_the_middle(x, *y, z): print(x, y, z)if __name__ == \"__main__\": in_the_middle(1, 2, 3, 4, z=5) 输出： 1 (2, 3, 4) 5 通过 ** 可以传入一个字典 12345def print_params(**params): print(params)if __name__ == \"__main__\": print_params(x=1, y=2, z=3) 输出： 1&#123;'x': 1, 'y': 2, 'z': 3&#125; 分配参数相反，也可以用于分配参数 12345678def add(x, y): print(x+y)if __name__ == \"__main__\": params_1 = (1, 2) params_2 = [3, 4] add(*params_1) add(*params_2) 字典同理 递归递归，简单来说就是一个函数自己调用自己。递归函数一般包含两个条件：基线条件和递归条件 基线条件：针对最小问题的解，满足条件时，函数直接返回一个值 递归条件：包含一个或多个调用，这些调用旨在解决问题的一部分 下面来看几个例子： 阶乘 计算 n 的阶乘，公式为 1x2x...x(n-1)xn 12345def factorial(n): result = n for i in range(1, n): result *= i return result 基线条件：1 的阶乘为 1递归条件：对于一个大于 1 的数字 n，其阶乘为 (n-1)*n 那么，满足这两个条件，可以实现为： 12345def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) 幂 计算 x 的 n 次幂，x*x*x...(n次) 12345def power(x, n): result = 1 for i in range(n): result *= x return result 基线条件：任何数字 x，它的 0 次幂为 1递归条件：当 n&gt;0 时，x 的 n 次幂为 x 乘以 x 的 n-1 次幂，即 power(x, n-1)*x 那么，满足这两个条件，可以实现为： 12345def power(x, n): if n == 0: return 1 else: return x * power(x, n-1) 二分查找定义两个指针用来确定搜索范围(lower, upper)，不断折中缩小范围，如果两指针(上限和下限)相同，则指向的位置就是数字所在的位置，将数字返回 12345678910111213141516171819def search(sequence, number, lower=0, upper=None): if upper is None: upper = len(sequence) - 1 if lower == upper: return upper else: middle = (lower + upper) // 2 if number &gt; sequence[middle]: return search(sequence, number, middle+1, upper) else: return search(sequence, number, lower, middle)if __name__ == \"__main__\": seq = [34, 67, 8, 123, 4, 100, 95] seq.sort() print(seq) res = search(seq, 34) print(res) 输出： 12[4, 8, 34, 67, 95, 100, 123]2","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之条件、循环","slug":"python_adv_if_for/adv_if_for","date":"2019-11-05T16:00:00.000Z","updated":"2020-10-06T11:15:40.832Z","comments":true,"path":"2019/11/06/python_adv_if_for/adv_if_for/","link":"","permalink":"http://akashigakki.github.io/2019/11/06/python_adv_if_for/adv_if_for/","excerpt":"条件、循环及其他语句 需要了解的列表推导式、字典推导式、lambda 匿名函数和关键字 yield。","text":"条件、循环及其他语句 需要了解的列表推导式、字典推导式、lambda 匿名函数和关键字 yield。 print 和 import 打印多个参数 使用逗号分隔可以打印多个参数 12&gt;&gt;&gt; print('age: ', 22)age: 22 (类似于 Java 中的字符串连接符 +) 导入时重名 一般导入 123import somemodulefrom somemodule import somefunction, antherfunctionfrom somemodule import * 当模块方法重名时，需要导入时指定别名，使用 as 12import math as foobarres = foobar.sqrt(4) 或： 12from math import sqrt as foobarres = foobar(4) 赋值魔法 序列解包(可迭代对象解包) 123456&gt;&gt;&gt; x, y, z = 1, 2, 3&gt;&gt;&gt; print(x, y, z)1 2 3&gt;&gt;&gt; values = 4, 5, 6&gt;&gt;&gt; values(4, 5, 6) 利用这个特性，我们还可以实现快速的元素值交换： 12345x, y = 1, 2print(x, y)x, y = y, xprint(x, y) 输出： 121 22 1 if123456if something: do somethingelif antherthing: do somethingelse: do something while12while condition: do something for12for some in somethings: pass 迭代字典12for key in item: print(key, item[key]) 或 12for key value in item.items(): print(key, value) 迭代工具 索引获取 123name = ['akashi', 'asuka', 'gakki']for i in range(len(name)): print(name[i]) 并行迭代 zip 将两个序列“缝合”，返回一个适合迭代的对象 12345name = ['akashi', 'asuka', 'gakki']age = [22, 21, 30]for name, age in zip(name, age): print(name, ':', age) 输出： 123akashi : 22asuka : 21gakki : 30 迭代同时获取索引和元素 函数 enumerate 1234name = ['akashi', 'asuka', 'gakki']for index, value in enumerate(name): print(index, value) 输出： 1230 akashi1 asuka2 gakki 列表推导式快速生成列表 12res = [x**2 for x in range(10)]print(res) 输出： 1[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 字典推导式快速生成字典 12345name = ['akashi', 'asuka', 'gakki']age = [22, 21, 30]res = &#123;name: age for name, age in zip(name, age)&#125;print(res) 输出： 1&#123;'akashi': 22, 'asuka': 21, 'gakki': 30&#125; 或 1234seq = [1, 2, 3, 4, 5, 6, 7, 8, 9]res = &#123;k:str(v) for k, v in enumerate(seq) if v % 2 == 0&#125;print(res) 输出： 1&#123;1: '2', 3: '4', 5: '6', 7: '8'&#125; 匿名函数 lambda定义一个只使用一次的函数 123func = lambda x, y: x + yres = func(2, 3)print(res) 输出： 5 yield可以将函数执行的中间结果返回但不结束程序 12345678def func(n): while n: yield n n -= 1if __name__ == \"__main__\": for i in func(4): print(i) 输出： 12344321 map()遍历序列，对序列中的每一个元素进行操作，创建一个新的序列，结果返回新序列的对象，需传入一个函数操作： 12345678def func(x, y): return x + yseq1 = [1, 2, 3]seq2 = [4, 5, 6]res = list(map(func, seq1, seq2))print(res) 输出： 1[5, 7, 9] 或 123seq = [1, 2, 3]res = list(map(lambda x: x**2, seq))print(res) 输出： 1[1, 4, 9] filter()对序列中的元素进行筛选，返回符合条件的序列的对象，也需要传入函数操作： 123seq = [1, 2, 3]res = list(filter(lambda x: x&gt;1, seq))print(res) 输出： 1[2, 3] reduce()累计函数，在 python2 中是内置函数，python3 中需要从 functools 模块中导入 返回一个操作最终的值，需要传入一个操作的函数 12345from functools import reduceseq = [1, 2, 3]res = reduce(lambda x, y: x + y, seq)print(res) 输出： 6","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之字典","slug":"python_adv_dict/adv_dict","date":"2019-11-04T16:00:00.000Z","updated":"2020-10-06T11:15:40.831Z","comments":true,"path":"2019/11/05/python_adv_dict/adv_dict/","link":"","permalink":"http://akashigakki.github.io/2019/11/05/python_adv_dict/adv_dict/","excerpt":"字典 通过名称来访问其各个值的数据结构 - 映射。字典是 Python 中唯一的内置映射类型。","text":"字典 通过名称来访问其各个值的数据结构 - 映射。字典是 Python 中唯一的内置映射类型。 dict使用 dict 从其他映射或键值对序列创建字典 123456&gt;&gt;&gt; items = [('name', 'akashi'), ('age', 22)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d&#123;'name': 'akashi', 'age': 22&#125;&gt;&gt;&gt; d['name']'akashi' 或者 12&gt;&gt;&gt; dict(name='akashi', age=22)&#123;'name': 'akashi', 'age': 22&#125; 基本的字典操作 使用 描述 len(item) 返回字典 item 包含的项数 item[key] 返回与键 key 相关联的值 item[key] = vlue 将值 vule 关联到 key del item[key] 删除键为 key 的项 key in item 检查字典 item 是否包含键为 key 的项 字典方法 方法 使用 描述 clear adict.clear() 删除所有的字典项 copy adict.copy() 浅复制 keys adict.keys() 获取字典的键 values adict.values() 获取字典的值 items adict.items() 获取字典的键值对 get adict.get(k) 返回 k 对应的值，如果没有，返回 None get adict.get(k, alt) 返回 k 对应的值，如果没有，返回 alt pop adict.pop(key) 弹出指定的键向关联的值，并从字典中删除 popitem adict.popitem() 随机弹出一个字典项，并从字典中删除 setdefault adict.setdefault(key, value) 获取与指定键相关联的值，如果不存在，在字典中添加指定的键值对 update adict.update(otherdict) 使用一个字典项更新另一个字典 clear() 删除所有的字典项 12345678item = &#123; 'name': 'akashi', 'age': 22&#125;print(item)item.clear()print(item) 输出： 12&#123;'name': 'akashi', 'age': 22&#125;&#123;&#125; copy() 浅复制 123456789101112item = &#123; 'name': 'akashi', 'age': 22, 'list': [1, 2]&#125;copy_item = item.copy()item['addr'] = 'local'copy_item['name'] = 'asuka'copy_item['list'].append(3)print(item)print(copy_item) 输出： 12&#123;'name': 'akashi', 'age': 22, 'list': [1, 2, 3], 'addr': 'local'&#125;&#123;'name': 'asuka', 'age': 22, 'list': [1, 2, 3]&#125; 当替换副本中的值时，原件不受影响，而如果修改副本中的值(就地修改而不是替换)，原件也会发生变化 深复制 1234567891011121314from copy import deepcopyitem = &#123; 'name': 'akashi', 'age': 22, 'list': [1, 2]&#125;copy_item = deepcopy(item)item['addr'] = 'local'copy_item['name'] = 'asuka'copy_item['list'].append(3)print(item)print(copy_item) 输出： 12&#123;'name': 'akashi', 'age': 22, 'list': [1, 2], 'addr': 'local'&#125;&#123;'name': 'asuka', 'age': 22, 'list': [1, 2, 3]&#125; keys() 获取字典中的键 12345item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.keys()) 输出： 1dict_keys(['name', 'age']) values() 获取字典中的值 12345item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.values()) 输出： 1dict_values(['akashi', 22]) items() 获取字典中的键值 12345item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.items()) 输出： 1dict_items([('name', 'akashi'), ('age', 22)]) get() 获取字典中的值 123456item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.get('name')) 输出： akashi 当指定的键不存在时，会输出 None 不存在时，指定默认值 123456item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.get('nickname', 'asuka')) 输出： asuka pop() 从字典中弹出一个值 1234567item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.pop('name'))print(item) 输出： 12akashi&#123;'age': 22&#125; popitem() 从字典中随机弹出一个键值对 因为字典里面是无序的，弹出的值是随机的 1234567item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.popitem())print(item) 输出： 12('age', 22)&#123;'name': 'akashi'&#125; setdefault() 与 get() 类似，获取指定的键关联的值，但不同的是，如果不存在，会在字典中添加指定的键值对 1234567item = &#123; 'name': 'akashi', 'age': 22,&#125;print(item.setdefault('addr', 'local'))print(item) 输出： 12local&#123;'name': 'akashi', 'age': 22, 'addr': 'local'&#125; update() 更新字典，有则替换，没有则添加 123456789101112item = &#123; 'name': 'akashi', 'age': 22,&#125;up_item = &#123; 'age': 21, 'addr': 'local'&#125;item.update(up_item)print(item) 输出： 1&#123;'name': 'akashi', 'age': 21, 'addr': 'local'&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之字符串","slug":"python_adv_string/adv_string","date":"2019-11-03T16:00:00.000Z","updated":"2020-10-06T11:15:40.834Z","comments":true,"path":"2019/11/04/python_adv_string/adv_string/","link":"","permalink":"http://akashigakki.github.io/2019/11/04/python_adv_string/adv_string/","excerpt":"字符串 字符串的基本操作和方法。","text":"字符串 字符串的基本操作和方法。 设置字符串的格式12&gt;&gt;&gt; \"&#123;foo&#125; &#123;&#125; &#123;bar&#125; &#123;&#125;\".format(1, 2, bar=4, foo=3)'3 1 4 2' 12me = 'my name is &#123;name&#125;'.format(name='akashi')print(me) 基本操作序列的基本操作(索引、切片、乘法、成员资格检查、长度、最小值、最大值)都适用于字符串 但是，字符串是不可变的，所有的元素赋值和切片赋值都是非法的。 字符串方法 方法 使用 描述 center astring.center(w) 返回一个字符串，长度为 w，在两边填充字符(默认为空格)，让字符串居中 count astring.count(item) 返回 item 出现的次数 lower astring.lower() 返回均为小写字母的字符串 upper astring.upper() 返回均为大写的字符串 title astring.title() 字符串单词首字母大写，返回结果 find astring.find(item) 返回 item 第一次出现时的下标 join astring.join(sequence) 将两个字符串元素合并，并返回结果 replace astring.replace(old, new) 将指定子串全部替换为另一个字符串返回 split astring.split(schar) 在 schar 位置将字符串分割为子串 strip astring.strip() 删除字符串开头和末尾的空白 center() 字符串居中 12345&gt;&gt;&gt; x = 'string'&gt;&gt;&gt; x.center(10)' string '&gt;&gt;&gt; x.center(20, '=')'=======string=======' count() 计算字符出现个数 123&gt;&gt;&gt; x = 'akashi'&gt;&gt;&gt; x.count('a')2 lower() 字符串转换成小写 123&gt;&gt;&gt; x = 'AKASHI'&gt;&gt;&gt; x.lower()'akashi' 类似还有 字符串转换成大写 - upper() 123&gt;&gt;&gt; x = 'asuka'&gt;&gt;&gt; x.upper()'ASUKA' 首字母大写 123&gt;&gt;&gt; x = 'gakki'&gt;&gt;&gt; x.title()'Gakki' find() 在字符串中查找子串，如果存在，返回第一次出现的第一个字符的索引，否则返回 -1 123&gt;&gt;&gt; x = 'akashi'&gt;&gt;&gt; x.find('ka')1 注：值匹配一次，返回第一次的下标 类似还有 index()、rindex()、rfind() join() 合并序列元素 1234567&gt;&gt;&gt; x = 'akashi'&gt;&gt;&gt; '-'.join(x)'a-k-a-s-h-i'&gt;&gt;&gt; seq = ['akashi', 'asuka', 'gakki']&gt;&gt;&gt; sep = '+'&gt;&gt;&gt; sep.join(seq)'akashi+asuka+gakki' 注：目的是将一个列表合并为一个字符串，可以指定中间的拼接字符。 split() 将字符串拆分为序列 123&gt;&gt;&gt; x = '1+2+3+4'&gt;&gt;&gt; x.split('+')['1', '2', '3', '4'] 注：和 join() 相反，split() 用于拆分字符串为列表。 replace() 替换字符串 123&gt;&gt;&gt; x = 'akashi'&gt;&gt;&gt; x.replace('kashi', 'suka')'asuka' 注：替换的是所有的字符串中出现的子串，一次执行替换全部。 strip() 取出字符串开始和结尾的空白 123&gt;&gt;&gt; x = ' akahsi '&gt;&gt;&gt; x.strip()'akahsi' 类似还有 lstrip()、rstrip() 判断字符串是否满足特定的条件方法以 is 打头，判断为真返回 True，否则返回 False 方法 使用 描述 isalnum() astring.isalnum() 检查字符串中字符是否都是字母或数 isalpha() astring.isalpha() 检查字符串字符是否都是字母 isdigit() astring.isdigit() 检查字符串字符是否都是数字 islower() astring.islower() 检查字符串字符是否都是小写 isupper() astring.isupper() 检查字符串字符是否都是大写","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 上手指南之列表","slug":"python_adv_list_and_tuple/adv_list_and_tuple","date":"2019-11-02T16:00:00.000Z","updated":"2020-10-06T11:15:40.833Z","comments":true,"path":"2019/11/03/python_adv_list_and_tuple/adv_list_and_tuple/","link":"","permalink":"http://akashigakki.github.io/2019/11/03/python_adv_list_and_tuple/adv_list_and_tuple/","excerpt":"列表 列表的基本操作和方法。","text":"列表 列表的基本操作和方法。 list 因为不能像修改列表一样修改字符串，有些情况需要字符串来创建列表。 12res = list('Hello')print(res) 输出：[&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;] 序列的运算： 运算名 运算符 说明 索引 [] 获取序列中的某个元素 连接 + 将序列连接在一起 重复 * 重复 N 次连接 成员 in 序列中是否有某元素 长度 len 序列元素个数 切片 [:] 取出序列的一部分 基本的列表操作 修改列表：给元素赋值 12345res = [1, 2, 3, 4]print(res)res[1] = 5print(res) 输出： 12[1, 2, 3, 4][1, 5, 3, 4] 删除元素 使用 del 语句可以实现列表中元素删除。 12345res = [1, 2, 3, 4]print(res)del res[1]print(res) 输出： 12[1, 2, 3, 4][1, 3, 4] 给切片赋值 赋值 12345res = list('akashi')print(res)res[1:] = list('rashi')print(res) 输出： 12['a', 'k', 'a', 's', 'h', 'i']['a', 'r', 'a', 's', 'h', 'i'] 替换序列，改变序列长度 12345res = list('akashi')print(res)res[1:] = list('suka')print(res) 输出： 12['a', 'k', 'a', 's', 'h', 'i']['a', 's', 'u', 'k', 'a'] 不替换原有元素的情况下插入元素 12345res = [1, 5]print(res)res[1:1] = [2, 3, 4]print(res) 输出： 12[1, 5][1, 2, 3, 4, 5] 删除切片 12345res = [1, 2, 3, 4, 5]print(res)res[1:4] = []print(res) 输出： 12[1, 2, 3, 4, 5][1, 5] 指定步长 [start:stop:step] 注：start 缺省默认从头开始，stop 缺省默认至列表结尾，step 缺省默认为 1 12345res = [1, 2, 3, 4, 5]print(res)num = res[::2]print(num) 输出： 12[1, 2, 3, 4, 5][1, 3, 5] 序列反转 123res = [1, 2, 3, 4, 5]num = res[::-1]print(num) 输出： 1[5, 4, 3, 2, 1] 列表方法 方法名 用法 说明 append alist.append(item) 在列表末尾添加一个新元素 clear alist.clear() 就地清空列表的内容 copy alist.copy() 复制列表 count alist.count(item) 返回 item 在列表中出现的次数 extend alist.extend(otherlist) 同时将多个值附加到列表末尾 index alist.index(item) 返回 item 第一次出现时的下标 insert alist.insert(i, item) 在列表的第 i 个位置插入一个元素 pop alist.pop() 删除并返回列表中最后一个元素 pop alist.pop(i) 删除并返回列表中第 i 个位置的元素 del del alist[i] 删除列表中第 i 个位置的元素 remove alist.remove(item) 从列表中移除第一次出现的 item reverse alist.reverse() 将列表元素倒序排列 sort alist.sort() 将列表元素排序 append() 用于将一个对象附加到列表末尾 123lst = [1, 2, 3]lst.append(4)print(lst) 输出： 1[1, 2, 3, 4] clear() 就地清空列表的内容 123lst = [1, 2, 3]lst.clear()print(lst) 输出： 1[] copy() 复制列表 123456a = [1, 2, 3]b = a.copy()b[1] = 4print(a)print(b) 输出： 12[1, 2, 3][1, 4, 3] 等效于 12a = [1, 2, 3]b = a[:] 常规复制只是将另一个名称关联到了列表，本质上还是同一个列表。 count() 计算指定的元素在列表中出现的次数 123lst = [1, 1, 2, 3]res = lst.count(1)print(res) 输出： 2 extend() 同时将多个值附加到列表末尾 1234a = [1, 2, 3]b = [4, 5, 6]a.extend(b)print(a) 输出： 1[1, 2, 3, 4, 5, 6] index() 在列表中查找指定的值第一次出现的索引 12name = ['akashi', 'asuka', 'asuka']print(name.index('asuka')) 输出： 1 insert() 用于将一个对象插入列表 123lst = [1, 2, 3, 5]lst.insert(3, 4)print(lst) 输出： 1[1, 2, 3, 4, 5] pop() 从列表中删除一个元素(末尾为最后一个元素)，并返回这一个元素 12lst = [1, 2, 3, 4]print(lst.pop()) 输出： 4 注：push 和 pop 是普遍接受的两种栈操作，但是 Python 没有提供 push，可以使用 append 代替。 remove() 删除第一个为指定值的元素 123lst = [1, 1, 2, 3]lst.remove(1)print(lst) 输出： 1[1, 2, 3] reverse() 按相反的顺序排列列表中的元素 123lst = [1, 2, 3]lst.reverse()print(lst) 输出： 1[3, 2, 1] sort() 用于对列表就地排序 123lst = [4, 6, 2, 1, 3, 5]lst.sort()print(lst) 输出： 1[1, 2, 3, 4, 5, 6] 因为是就地排序，修改了列表而不返回任何的值，如果像下面这样，就是得到一个 None 123x = [2, 1, 4, 3]y = x.sort()print(y) 输出： None 想要获取排序后的列表的副本，可以使用函数 sorted() 123x = [2, 1, 4, 3]y = sorted(x)print(y) 高级排序 方法 sort() 接受两个可选参数：key 和 reverse 参数 key 可以设置为一个用于排序的函数(可以是自定义函数)： 123name = ['akashi', 'asuka', 'gakki']name.sort(key=len)print(name) 参数 reverse 指定为 True 或 False，指出是否按相反顺序排序。 元组：不可修改的序列 元组也是序列，与列表的差别在于不可修改。 使用逗号分隔，自动创建一个元组 创建 12&gt;&gt;&gt; 1, 2, 3(1, 2, 3) 表示一个值的元组 12&gt;&gt;&gt; 4,(4,) tuple12res = tuple('123')print(res) 输出： 1('1', '2', '3') 元组操作与列表大体一致，也有切片 元组用作映射中的键(以及集合的成员)，而列表不行。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"}]},{"title":"Python 应用 uWSGI + Nginx 部署","slug":"Python_Deploy/deploy","date":"2019-10-29T16:00:00.000Z","updated":"2020-10-06T11:15:40.720Z","comments":true,"path":"2019/10/30/Python_Deploy/deploy/","link":"","permalink":"http://akashigakki.github.io/2019/10/30/Python_Deploy/deploy/","excerpt":"uWSGI + Nginx 项目部署。","text":"uWSGI + Nginx 项目部署。 Python 应用 uWSGI + Nginx 部署新建一个 Django 应用部署 使用 py 文件启动 uWSGI 123def application(env, start_response): start_response('200 ok', [('Content-type', 'text/html')]) return [b'Hello uWSGI.'] 启动: 1uwsgi --http-socket :8000 --plugin python3 --wsgi-file uwsgi_test.py 可能需要安装 12sudo apt install uwsgi-plugin-commonsudo apt install uwsgi-plugin-python3 视情况也可能是 apt install uwsgi-plugin-python，看自己使用的 Python 版本和软连接情况。 这样，在对应的 IP 下的 8000 端口可以访问到文件。 新建 Django 项目 1django-admin startproject django_deployment 通过修改配置允许外部访问 setting.py: 1ALLOWED_HOSTS = [\"*\"] 启动 1python3 manage.py runserver 0.0.0.0:8000 打通 Django 与 uWSGI 的链路先停止应用 启动 uwsgi 打通关系 在项目根目录启动 1uwsgi --http-socket :8000 --plugin python3 --module django_deployment.wsgi 将命令行配置改为文件配置 新建 django-uwsgi.ini: 12touch django-uwsgi.inivim django-uwsgi.ini 1234567891011121314151617181920212223# 配置域[uwsgi]# 工作目录chdir = /source/python/deployment/django_deployment# 模块module = django_deployment.wsgi# 请求端口http-socket = :8000# mastermaster = True# 进程processes = 4# 线程threads = 1# 是否退出是清理相关内容vacuum = true 启动 1uwsgi --ini django-uwsgi-ini 后台启动 后台运行程序并打印日志 12345678910111213141516171819202122232425262728# 配置域[uwsgi]# 工作目录chdir = /source/python/deployment/django_deployment# 模块module = django_deployment.wsgi# 请求端口http-socket = :8000# mastermaster = True# 进程processes = 4# 线程threads = 1# 是否退出是清理相关内容vacuum = true# backend run uwsgidaemonize = %(chdir)/log/uwsgi-8000.loglog-maxsize = 1024*1024*1024pidfile = %(chdir)/pid/uwsgi-8000.pid 创建文件夹 log 和 pid 启动 1uwsgi --ini django-uwsgi.ini 停止 1uwsgi --stop pid/uwsgi-8000.pid Django Nginx + uWSGI 部署uWSGI 启动 Django 服务器 启动并查看 pid 1uwsgi --ini django-uwsgi-ini 1cat pid/uwsgi-8000.pid 1ps -aux | grep xxx 修改 Nginx 配置文件，完成反向代理复制备份配置文件 nginx.conf 为 nginx.conf.back 修改 nginx.conf 在 63 行处： 123456789101112upstream uwsgi &#123; server 122.51.1.19:8000;&#125;server &#123; listen 80; server_name 122.51.1.19; charset utf-8; location / &#123; proxy_pass http://uwsgi; &#125;&#125; 启动 1nginx 查看启动进程情况 1ps -aux | grep nginx 添加 log 配置文件 12345678910111213upstream uwsgi &#123; server 122.51.1.19:8000;&#125;server &#123; listen 80; server_name 122.51.1.19; charset utf-8; access_log /var/log/nginx/nginx.log; location / &#123; proxy_pass http://uwsgi; &#125;&#125; 重启 1nginx -s reload 查看日志： 123cd /var/log/ngxin/lstail -f nginx.log 收集静态文件，完成静态文件寻址配置 收集静态文件 1vim django_deployment/settings.py 1STATIC_ROOT = os.path.join(BASE_DIR, 'static') 1python manage.py collectstatic 配置静态文件路由 1234567891011121314151617upstream uwsgi &#123; server 122.51.1.19:8000;&#125;server &#123; listen 80; server_name 122.51.1.19; charset utf-8; access_log /var/log/nginx/nginx.log; location / &#123; proxy_pass http://uwsgi; &#125; location /static &#123; allas /source/python/deployment/django_deployment/static; &#125;&#125; 重新加载 1nginx -s reload HTTPS 加密部署使用 443 端口，协议加密传输报文。 申请 SSL 证书 在 Nginx 中新建文件夹 ssl，存放 crt 和 key 远程拷贝到服务器 12scp 2_topic.akashi.org.cn.crt root@122.51.1.19:/etc/nginx/ssl/scp 3_topic.akashi.org.cn.key root@122.51.1.19:/etc/nginx/ssl 配置 Nginx 支持 HTTPS nginx.conf: 1234listen 443 ssl;ssl_certificate /etc/nginx/ssl/domain.com.crt;ssl_certificate_key /etc/nginx/ssl/domain.com.key;ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 定义 80 端口的返回 12345server &#123; listen 80; server_name topic.akashi.org.cn; rewrite ^(.*)$ https://$host$1 permanent;&#125; 或者 12345server &#123; listen 80; server_name topic.akashi.org.cn; return 301 https://topic.akashi.org.cn;$request_rui;&#125; 重启生效 1nginx -s reload 部署高可用服务添加配置的启动端口，开启多个服务，并且转发到 nginx 上，还可以通过权重分配达到负载均衡 1234upstream uwsgi &#123; server 127.0.0.1:8000 weight=3; server 127.0.0.1:8001 weight=1;&#125; 注意事项 不要使用 root 权限启动 uwsgi 服务 关闭 uwsgi 外网访问 1http-scoket = 127.0.0.1:8000 1http-scoket = 127.0.0.1:8001","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Nginx","slug":"Nginx","permalink":"http://akashigakki.github.io/tags/Nginx/"}]},{"title":"Ubuntu 下 MySQL 的安装","slug":"mysql-install-contos/mysql-install","date":"2019-10-28T16:00:00.000Z","updated":"2020-10-06T11:15:40.741Z","comments":true,"path":"2019/10/29/mysql-install-contos/mysql-install/","link":"","permalink":"http://akashigakki.github.io/2019/10/29/mysql-install-contos/mysql-install/","excerpt":"Ubuntu 下 MySQL 的安装 记录服务器下 MySQL 的安装过程。","text":"Ubuntu 下 MySQL 的安装 记录服务器下 MySQL 的安装过程。 123apt install mysql-client-core-5.7apt install mysql-client-5.7apt install mysql-server-5.7 停止、启动和重启 mysql 服务 123service mysql stopservice mysql startservice mysql restart 查看默认登录的用户名和密码 1sudo cat /etc/mysql/debian.cnf 使用默认用户登录 1mysql -u debian-sys-maint -p 查看当前所有存在的用户 1select user from mysql.user; 修改密码 1update mysql.user set authentication_string=PASSWORD(\"这里输入你的密码\") where User='root'; 更新所有操作权限 12update mysql.user set plugin=\"mysql_native_password\";flush privileges; 退出并重新使用你设置的密码登录 12exitmysql -uroot -p","categories":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/categories/Linux/"},{"name":"环境安装","slug":"Linux/环境安装","permalink":"http://akashigakki.github.io/categories/Linux/环境安装/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/tags/Linux/"},{"name":"环境安装","slug":"环境安装","permalink":"http://akashigakki.github.io/tags/环境安装/"}]},{"title":"Python 解析库的使用","slug":"pyquery_xpath/pyquery-xpath","date":"2019-10-27T16:00:00.000Z","updated":"2020-10-06T11:15:40.825Z","comments":true,"path":"2019/10/28/pyquery_xpath/pyquery-xpath/","link":"","permalink":"http://akashigakki.github.io/2019/10/28/pyquery_xpath/pyquery-xpath/","excerpt":"Python 解析库的使用 lxml、Beautiful Soup 和 pyquery 的使用。","text":"Python 解析库的使用 lxml、Beautiful Soup 和 pyquery 的使用。 XPathXPath 常用规则 表达式 描述 nodename 选取此节点的所有子节点 / 从当前节点选取直接子节点 // 从当前节点选取子孙节点 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 实例引入eg: 123456789101112131415from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;a href=\"link.html\"&gt;item&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = etree.tostring(html)print(result.decode('utf-8')) 所有节点使用 // 开头的 XPath 规则来匹配所有符合要求的节点 eg: 12345678import requestsfrom lxml import etreeurl = 'https://akashigakki.github.io'response = requests.get(url)html = etree.HTML(response.text)result = html.xpath('//div')print(result) 子节点使用 / 匹配子节点 eg: 12345678import requestsfrom lxml import etreeurl = 'https://akashigakki.github.io'response = requests.get(url)html = etree.HTML(response.text)result = html.xpath('//div/span')print(result) 父节点使用 .. 匹配获取父节点 eg: 123456789101112131415from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;a href=\"link.html\"&gt;item&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li/a/../@class')print(result) 也可以通过 parent:: 来获取 eg: 123456789101112131415from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;a href=\"link.html\"&gt;item&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li/a/parent::*/@class')print(result) 属性匹配使用 @ 进行属性过滤 eg: 12345678910111213141516from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li/a[@class=\"item\"]')print(result) 以上 xpath 只有 class 是 item 的 a 标签可以匹配到，结果只有一个节点。 文本获取使用 text() 进行文本获取 eg: 12345678910111213141516from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li/a[@class=\"item\"]/text()')print(result) 属性获取12345678910111213141516from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li/a/@href')print(result) 属性多值匹配使用 contains() 函数 如果一个节点的 class 属性有两个值，那么就无法通过属性匹配来获取了： 12345678910111213141516from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item li-first\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li[@class=\"item\"]/a/@href')print(result) 输出为 [] 12345678910111213141516from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item li-first\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class, \"item\")]/a/@href')print(result) 这种方式在某个节点的某个属性有多个值时经常用到。 多属性匹配使用 and 12345678910111213141516from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item li-first\" name=\"li\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class, \"item\") and @name=\"li\"]/a/@href')print(result) 其他运算符介绍： 运算符 描述 实例 返回值 or 或 age=19 or age=20 true/false and 与 age&gt;19 and age&lt;21 true/false mod 计算除法的余数 5 mod 2 余数 ` ` 计算两个节点集 `//book //cd` 返回所有拥有 book 和 cd 元素的节点集 + 加法 6 + 4 对应值 - 减法 6 - 4 对应值 * 乘法 6 * 4 对应值 div 除法 8 div 4 对应值 = 等于 age=19 true/false != 不等于 age!=19 true/false &lt; 小于 age&lt;19 true/false &lt;= 小于等于 age&lt;=19 true/false &gt; 大于 age&gt;19 true/false &gt;= 大于等于 age&gt;=19 true/false 按序选择123456789101112131415161718from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class=\"item li-first\" name=\"li\"&gt; &lt;a href=\"link.html\"&gt;item_1&lt;/a&gt; &lt;a class=\"item\"&gt;item_2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''html = etree.HTML(text)result_1 = html.xpath('//li/a[last()]/text()')result_2 = html.xpath('//li/a[position()=1]/text()')print(result_1)print(result_2) 具体参考 http://www.w3cschool.com.cn/xpath/xpath_functions.asp Beautiful Soup基本用法12345678910import requestsfrom bs4 import BeautifulSoupurl = 'https://akashigakki.github.io/'response = requests.get(url=url)html = response.textsoup = BeautifulSoup(html, 'lxml')print(soup.prettify)print(soup.title.string) Beautiful Soup 在使用时依赖于解析器，它除了支持 Python 标准库中的 HTML 解析器外(html.parser)，还支持第三方解析器如 lxml 和 xml 等。 初始化时，把第二个参数设置为解析器，如 soup = BeautifulSoup(html, &#39;lxml&#39;) 节点选择器 选择元素 12345678910111213141516from bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')print(soup.title)print(soup.title.string)print(soup.p) 输出： 123&lt;title&gt;The Title&lt;/title&gt;The Title&lt;p class=\"item\"&gt;Akashi&lt;/p&gt; 提取信息 (1) 获取节点名称 1234567891011121314from bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')print(soup.title.name) 输出： title (2) 获取属性 123456789101112131415rom bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')print(soup.p.attrs)print(soup.p.attrs['class']) 输出： 12&#123;'class': ['item']&#125;['item'] 嵌套选择 1234567891011121314rom bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')print(soup.head.title) 输出： &lt;title&gt;The Title&lt;/title&gt; 关联选择 (1) 子节点和子孙节点 选取节点元素之后，如果想要获取它的直接子节点，可以调用 contents 属性 如果想要获取所有的子孙节点，可以使用 children 来获取 123456789101112131415161718from bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://r1.example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://r2.example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')print(soup.div.contents)print(soup.div.children)for item in soup.div.children: print(item) 输出： 123456789101112['\\n', &lt;p class=\"item\"&gt;Akashi&lt;/p&gt;, '\\n', &lt;a class=\"site\" href=\"https://r1.example.com\"&gt;site_1&lt;/a&gt;, '\\n', &lt;a class=\"site\" href=\"https://r2.example.com\"&gt;site_2&lt;/a&gt;, '\\n']&lt;list_iterator object at 0x1018f5810&gt;&lt;p class=\"item\"&gt;Akashi&lt;/p&gt;&lt;a class=\"site\" href=\"https://r1.example.com\"&gt;site_1&lt;/a&gt;&lt;a class=\"site\" href=\"https://r2.example.com\"&gt;site_2&lt;/a&gt; (2) 父节点和祖先节点 如果想要获取某个节点元素的父节点，可以使用 parent 属性 如果想要获取所有的祖先节点，可以使用 parents 属性 (3) 兄弟节点 如果想要获取同级节点，可以使用 netx_sibling 获取下一个兄弟元素，previous_sibling 获取上一个兄弟元素 使用 next_siblings 返回所有后面的兄弟节点，使用 previous_sibling 返回所有前面的兄弟节点 (4) 提取信息 调用 string 和 attrs 等属性获得其文本和属性 方法选择器 find_all() 查询所有符合条件的元素 (1) name 1soup.find_all(name='li') (2) attrs 123soup.find_all(attrs=&#123; 'id': 'list-1'&#125;) 12soup.find_all(id='list-`')soup.fin_all(class_='element') (3) text 1soup.find_all(text=re.compile('link')) find 匹配一个元素，参数与 find_all 一致 其他方法： find_parents()、find_parent()、find_next_sibling()、find_next_siblings()、find_previous_sibling()、find_previous_siblings() CSS 选择器1234567891011121314151617181920212223242526# import requests# from bs4 import BeautifulSoup# url = 'https://akashigakki.github.io/'# response = requests.get(url=url)# html = response.text# soup = BeautifulSoup(html, 'lxml')# print(soup.prettify)# print(soup.title.string)from bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://r1.example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://r2.example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')print(soup.select('a')) 输出： 1[&lt;a class=\"site\" href=\"https://r1.example.com\"&gt;site_1&lt;/a&gt;, &lt;a class=\"site\" href=\"https://r2.example.com\"&gt;site_2&lt;/a&gt;] 嵌套选择 12345678910111213141516from bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p class='item'&gt;Akashi&lt;/p&gt; &lt;a href='https://r1.example.com' class='site'&gt;site_1&lt;/a&gt; &lt;a href='https://r2.example.com' class='site'&gt;site_2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''soup = BeautifulSoup(html, 'lxml')for div in soup.select('div'): print(soup.select('a')) 属性获取 1234soup = BeautifulSoup(html, 'lxml')for a in soup.select('a'): print(a['class']) print(a.attrs['class']) 文本获取 1234soup = BeautifulSoup(html, 'lxml')for a in soup.select('a'): print(a.get_text()) print(a.string) pyquery 如果使用 jQuery 操作 css 选择器比较熟悉，那么使用起 pyquery 就会非常顺手了，因为它们的语法基本是一样的。 初始化1234567import requestsfrom pyquery import PyQuery as pqurl = 'https://akashigakki.github.io'html = requests.get(url=url)doc = pq(html.text)print(doc('title')) 基本 css 选择器使用起来和 jQuery 完全相同，如： 1doc('#container .list li') 以上分别为 id 选择器、class 选择器和标签选择器。 查找节点 需要查找子节点时，使用 find() 方法 eg: 123doc = pq(html)items = doc('.list')lis = items.find('li') find() 方法会返回符合条件的所有子孙节点，如果只是查找子节点，可以使用 children() eg: 1lis = items.children('.active') 使用 parent() 获取某个节点的父节点 eg: 123doc = pq(html)items = doc('.list')contaier = items.parent() 如果想获取所有祖先节点，使用 parents() 方法 eg: 1container = items.parents() 获取兄弟节点 siblings() eg: 123doc = pq(html)li = doc('.list')print(li.siblings()) 如果需要筛选，还可以继续传入参数： 1print(li.siblings('.active')) 获取信息 获取属性 eg: 1234doc = pq(html)a = doc('.item a')print(a.attr('href'))print(a.attr.href) 以上两种方式都可以获取属性。 获取文本 使用 text() 来实现 eg: 1print(a.text()) 也可以使用 html() 获取 HTML 文本 eg: 1print(a.html()) 节点操作 addClass 和 removeClass 可以对节点进行动态修改 attr、text 和 html 对节点的内容进行修改 remove() 移除 伪类选择器eg: 1234doc = pq(html)li = doc('li:first-child')li = doc('li:last-child')li = doc('li:nth-child(2)') 依次选择了第一个 li 节点、最后一个 li 节点和第二个 li 节点。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"工具","slug":"Python/工具","permalink":"http://akashigakki.github.io/categories/Python/工具/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"工具","slug":"工具","permalink":"http://akashigakki.github.io/tags/工具/"}]},{"title":"pymysql 操作关系型数据库","slug":"python_pymysql/pymysql","date":"2019-09-24T16:00:00.000Z","updated":"2020-10-06T11:15:40.920Z","comments":true,"path":"2019/09/25/python_pymysql/pymysql/","link":"","permalink":"http://akashigakki.github.io/2019/09/25/python_pymysql/pymysql/","excerpt":"pymysql 操作关系型数据库 关系型数据库 MySQL 的数据存储操作。","text":"pymysql 操作关系型数据库 关系型数据库 MySQL 的数据存储操作。 数据库连接1234567891011import pymysql# 创建一个连接，新建数据库并且输出版本db = pymysql.connect(host='localhost', user='root', password='root', port=3306)cursor = db.cursor()cursor.execute('select version()')data = cursor.fetchone()print('Database version: ', data)cursor.execute('create database spiders default character set utf8mb4')db.close() 这里使用 connect() 方法声明一个 MySQL 连接对象 db，传入对应参数 连接成功后，调用 cursor() 方法获得 MySQL 的操作游标，利用游标来执行 SQL 语句， 执行操作使用 execute() 方法实现，首先获取了 MySQL 当前的版本，使用 fetchone() 获取结果的第一条数据， 然后创建一个数据库，命名为 spider，使用 utf8mb4 编码， 最终关闭数据库。 创建表1234567import pymysqldb = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'create table if not exists students (id varchar(255) not null, name varchar(255) not null, age int not null, primary key (id))'cursor.execute(sql)db.close() 插入数据12345678910111213141516import pymysqlid = '20190001'user = 'Akashi'age = 22db = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'insert into students(id, name, age) values(%s, %s, %s)'try: cursor.execute(sql, (id, user, age)) db.commit()except Exception as e: print(e) db.rollback()db.close() 这里最终需要执行对 db 对象的 commit() 方法才可以实现数据的插入，对于数据的插入、更新、删除操作都需要使用提交数据库才会保存生效。 我们还加入了异常处理，如果执行失败，打印异常并且执行数据回滚，保证了数据的一致性。 事务一个事务中的命令，要么全部执行，要么都不执行，这样确保了数据的一致性。事务包括原子性、一致性、隔离性、和持久性。 属性 解释 原子性 事务是一个不可分割的工作单位，事务中的所有操作，要么都执行，要么都不执行。 一致性 事务必须使数据库从一个一致性状态变到另一个一致性状态。 隔离性 一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性 也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响。 下面对插入进一步的改进，使用字典进行传入，对 sql 语句做更好的封装： 123456789101112131415161718192021222324import pymysqldata = &#123; 'id': '20190002', 'name': 'Asuka', 'age': 21&#125;table = 'students'keys = ', '.join(data.keys())values = ', '.join(['%s'] * len(data))db = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'insert into &#123;table&#125;(&#123;keys&#125;) values(&#123;values&#125;)'.format(table=table, keys=keys, values=values)try: cursor.execute(sql, tuple(data.values())) print('Successful') db.commit()except Exception as e: print(e) db.rollback()db.close() 更新数据1234567sql = 'update students set age = %s where name = %s'try: cursor.execute(sql, (21, 'Akashi')) db.commit()except: db.rollback()db.close() 如果数据存在，则更新数据，如果数据不存在，则插入数据： 1234567891011121314151617181920212223242526272829import pymysqldata = &#123; 'id': '20190001', 'name': 'Akashi', 'age': 21&#125;table = 'students'keys = ', '.join(data.keys())values = ', '.join(['%s'] * len(data))db = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'insert into &#123;table&#125;(&#123;keys&#125;) values(&#123;values&#125;) on duplicate key update'.format(table=table, keys=keys, values=values)update = ','.join([\" &#123;key&#125; = %s\".format(key=key) for key in data])sql += updatetry: cursor.execute(sql, tuple(data.values())*2) print('Successful') db.commit()except Exception as e: print(e) db.rollback()db.close() 删除数据123456789101112131415161718import pymysqltable = 'students'condition = 'age &gt; 20'db = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'delete from &#123;table&#125; where &#123;condition&#125;'.format(table=table, condition=condition)try: cursor.execute(sql) print('Successful') db.commit()except Exception as e: print(e) db.rollback()db.close() 查询数据12345678910111213141516import pymysqldb = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'select * from students where age &gt;= 20'try: cursor.execute(sql) print('Count:', cursor.rowcount) one = cursor.fetchone() print('One:', one) results = cursor.fetchall() print('Results:', results)except Exception as e: print(e) 推荐逐条取数据: 12345678910111213141516import pymysqldb = pymysql.connect(host='localhost', user='root', password='root', port=3306, db='spiders')cursor = db.cursor()sql = 'select * from students where age &gt;= 20'try: cursor.execute(sql) print('Count:', cursor.rowcount) row = cursor.fetchone() while row: print('Row:', row) row = cursor.fetchone()except Exception as e: print(e) 利用内部的指针偏移获取查询结果。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"工具","slug":"Python/工具","permalink":"http://akashigakki.github.io/categories/Python/工具/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"工具","slug":"工具","permalink":"http://akashigakki.github.io/tags/工具/"}]},{"title":"面向对象进阶","slug":"Object_Oriented_Adv/object-oriented-adv","date":"2019-09-15T16:00:00.000Z","updated":"2020-10-06T11:15:40.719Z","comments":true,"path":"2019/09/16/Object_Oriented_Adv/object-oriented-adv/","link":"","permalink":"http://akashigakki.github.io/2019/09/16/Object_Oriented_Adv/object-oriented-adv/","excerpt":"面向对象进阶 类的继承、多态、抽象类与接口的具体使用。","text":"面向对象进阶 类的继承、多态、抽象类与接口的具体使用。 继承性 继承是面向对象的第二大特征，而继承性要解决的问题就是代码的重用问题，利用继承性可以从已有的类继续派生出新的子类，也可以利用子类扩展出更多的操作功能。 继承是为了增强代码的复用性，扩充类的功能，具体实现为： 123class 子类 extends 父类 &#123;&#125; 子类又被称为派生类 父类又被称为超类 基本实现父类：Person： 1234567891011121314151617181920public class Person &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 子类：Student: 1234567891011121314151617181920public class Student extends Person &#123; private Integer sid; private String school; public Integer getSid() &#123; return sid; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public String getSchool() &#123; return school; &#125; public void setSchool(String school) &#123; this.school = school; &#125;&#125; 调用： Main: 12345678910public class Main &#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(\"Akashi\"); student.setAge(22); student.setSchool(\"SMU\"); student.setSid(123456); System.out.println(\"name: \" + student.getName() + \" age: \" + student.getAge() + \" school: \" + student.getSchool() + \" sid: \" + student.getSid()); &#125;&#125; 子类实际上是将父类定义得更加具体化的一种手段。 限制虽然继承可以进行类功能的扩充，但是其在定义的时候也会存在若干限制： Java 不允许多继承，但是允许多层继承 虽然可以多层继承，但是从实际开发角度讲，类之间的继承最多不要超过三层，太多继承关系会让类过于复杂。 子类在继承父类的时候，严格上来讲会继承父类中的全部操作，但是对于所有的私有操作属于隐式继承，而所有的非私有操作属于显式继承。 隐式继承即只可以利用 setter 和 getter 方法间接的访问私有属性，子类也并不可以直接访问父类的私有属性。 在子类对象构造前一定会默认调用父类的构造(默认使用无参构造)，以保证父类的对象先实例化，子类的对象后实例化。 1234567891011121314151617class A &#123; public A() &#123; System.out.println(\"A类的构造方法\"); &#125;&#125;class B extends A &#123; public B() &#123; System.out.println(\"B类的构造方法\"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; B b = new B(); &#125;&#125; 输出： 12A类的构造方法B类的构造方法 覆写 继承性的主要特征是子类可以根据父类已有的功能进行功能的扩展，但是在子类定义属性或方法时，有可能出现定义的属性或方法与父类同名的情况，这样的操作被称为覆写。 当子类定义了和父类的方法名称、返回值类型、参数类型及个数完全相同的方法时，就称为方法的覆写。 实现12345public class A &#123; public void func() &#123; System.out.println(\"A类中的func方法\"); &#125;&#125; 12345public class B extends A &#123; public void func() &#123; System.out.println(\"B类中的func方法\"); &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; B b = new B(); b.func(); &#125;&#125; 输出为： 1B类中的func方法 覆写的执行问题 观察实例化的是那一个类 观察这个实例化的类里面调用的方法是否已经被覆写过，如果没有覆写过则调用父类的方法 注意：父类方法中使用 private 声明的方法是无法被外部看见的，也是不能被覆写的。 final 关键字 使用 final 定义的类不能再有子类，即：任何类都不能继承以 final 声明的父类。 使用 final定义的方法不能被子类所覆写。 多态性 方法的多态性 重载：同一个方法名称，根据不同的参数类型及个数可以完成不同的功能 覆写：同一个方法，根据实例化的子类不同，所完成的功能也不同 对象的多态性 向上转型：子类对象变为父类对象，格式：父类 父类对象 = 子类实例(自动转换) 向下转型：父类对象变为子类对象，格式：子类 子类对象 = (子类)父类实例(强制转换) 实现向下转型(自动完成)： 123456public class Main &#123; public static void main(String[] args) &#123; A a = new B(); a.func(); &#125;&#125; 输出： 1B类中的func方法 判断最终的输出，要看是实例化的那一个类。这里实例化的是 B (new B()) 向上转型(强制转换) 1234567public class Main &#123; public static void main(String[] args) &#123; A a = new B(); B b = (B)a; b.func(); &#125;&#125; 先向上转型，再强制向下转型，同样输出 B类中的func方法，在强制向下转型时是有条件的，必须先向上转型，不然会抛出类型转换异常 ClassCastException。 123456public class Main &#123; public static void main(String[] args) &#123; A a = new B(); a.func(); &#125;&#125; 向下转型是会存在安全隐患的，开发中应尽量避免此操作。 转型意义在实际开发中，对象向上转型的主要意义在于参数的统一，也是最为主要的用法。 而对象的向下转型指的是调用子类的个性化操作方法。 抽象性 利用抽象类可以明确定义子类需要覆写的方法。 普通类可以直接产生实例化对象，并且在普通类中可以包含构造方法、普通方法、static 方法、常量、变量等内容。而抽象类就是指在普通类里面增加了抽象方法的组成部分，抽象方法指的是没有方法体的方法，同时抽象方法还必须使用 abstract 定义。 1234567public abstract class A &#123; public void func() &#123; System.out.println(\"A类中的func方法\"); &#125; public abstract void print();&#125; 抽象类不能直接实例化对象 抽象类必须有子类，即每一个抽象类一定要被子类所继承(使用extends)，但同样的因为单继承的原因，一个子类只能继承一个抽象类，这个问题会在之后的接口中提出解决办法。 抽象类的子类必须覆写抽象类中的全部抽象方法。 依靠对象的向上转型概念，可以通过抽象类的子类完成抽象类的实例化对象操作。 123456789public class B extends A &#123; public void func() &#123; System.out.println(\"B类中的func方法\"); &#125; public void print() &#123; System.out.println(\"覆写父类的抽象方法\"); &#125;&#125; 123456public class Demo &#123; public static void main(String[] args) &#123; B b = new B(); b.print(); &#125;&#125; 抽象类的相关限制 抽象类里面会存在一些属性，那么在抽象类里面一定会存在构造方法，目的是为了属性的初始化，并且子类对象实例化时依然满足先执行父类构造再调用子类构造的情况。 抽象类不能使用 final 定义，因为抽象类必须有子类，而 final 定义的类不能有子类。 抽象类中可以没有任何抽象方法，但是只要有抽象类，就不能直接使用关键字 new 实例化对象。 抽象类应用 —— 模板设计模式抽象类的最主要特点相当于制约了子类必须覆写的方法，同时抽象类中也可以定义普通方法，而且最为关键的是，这些普通方法定义在抽象类时，可以直接调用类中定义的抽象方法，但是具体的抽象方法内容就必须由子类来提供。 12345678public abstract class A &#123; public abstract void print(); public void getPrint() &#123; this.print(); &#125;&#125; 123456public class B extends A &#123; public void print() &#123; System.out.println(\"覆写父类的抽象方法\"); &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; A a = new B(); a.getPrint(); &#125;&#125; 接口 利用抽象类可以实现对子类覆写方法的控制，但是抽象类的子类存在单继承限制，所以需要 Java 的接口来解决。同时，在开发中为了将具体的代码的实现细节对调用者隐藏，也可以利用接口来进行方法视图的描述。 定义接口12345public interface A &#123; public abstract void func(); public abstract void print();&#125; 接口必须要有子类，但是此时一个子类可以使用 implements 关键字实现多个接口，避免单继承局限。 接口的子类(如果不是抽象类)，必须要覆写接口中的全部抽象方法。 接口的对象可以利用子类对象的向上转型进行实例化操作。 12345public class B implements A &#123; public void func() &#123; System.out.println(\"A接口的抽象方法\"); &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; A a = new B(); a.func(); &#125;&#125; 接口的应用 —— 工厂设计模式(Factory)一个良好的代码编写风格要求遵从于以下两个标准： 客户端(示例中的主方法)调用简单，不需要关注具体的细节。 程序代码的修改，不影响客服端的调用，即：使用者可以不去关心代码是否变更。 我们来看以下的一个例子： 123public interface Fruit &#123; public void eat();&#125; 12345public class Apple implements Fruit &#123; public void eat() &#123; System.out.println(\"eating apple.\"); &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; Fruit fruit = new Apple(); fruit.eat(); &#125;&#125; 这时我们再添加一个新的子类，想要调用新的子类就需要去修改实例化接口的子类： 12345public class Orange implements Fruit &#123; public void eat() &#123; System.out.println(\"eating orange.\"); &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; Fruit fruit = new Orange(); fruit.eat(); &#125;&#125; 这种写法是不推荐的，为了解决耦合，需要引入工厂模式的概念，即想办法让客户端只看见接口，而不让其看见子类，这时需要一个中间的工具类来取得接口对象。 这样客户端就不用再关心接口的子类，只要通过 Facroty (工厂类)就可取得接口对象。 增加一个工厂类进行过渡： 1234567891011121314151617public class Factory &#123; public static Fruit getInstance(String fruit) &#123; if (\"apple\".equals(fruit)) &#123; return new Apple(); &#125; else if (\"orange\".equals(fruit)) &#123; return new Orange(); &#125; else &#123; return null; &#125; &#125;&#125; 123456public class Main &#123; public static void main(String[] args) &#123; Fruit fruit = Factory.getInstance(\"orange\"); fruit.eat(); &#125;&#125; 改写后，客户端的操作上取消了 new 关键字的使用，而使用 Factory.getInstance() 方法根据指定的子类的标记取得接口实例化对象，这时客户端不再需要关注具体的子类，也不需要关注 Factory 类是怎样处理的，只需要关注如何获取接口对象并操作。 这样的设计在开发中就称为工厂设计模式。 接口的应用 —— 代理设计模式(Proxy)代理设计就是指一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题负责其他相关业务的处理。 就好比代理上网，客户通过网络代理连接网络，由代理服务器完成用户权限、访问限制等与上网操作相关的操作。 123public interface Network &#123; public void browse();&#125; 12345678910111213141516public class Proxy implements Network &#123; private Network network; public Proxy(Network network) &#123; this.network = network; &#125; private void check() &#123; System.out.println(\"检查用户是否合法\"); &#125; public void browse() &#123; this.check(); this.network.browse(); &#125;&#125; 12345public class Real implements Network &#123; public void browse() &#123; System.out.println(\"上网浏览信息\"); &#125;&#125; 1234567public class Demo &#123; public static void main(String[] args) &#123; Network network = null; network = new Proxy(new Real()); network.browse(); &#125;&#125; 抽象类与接口的区别比较： 区别 抽象类 接口 关键字 abstract class interface 组成 构造方法、普通方法、抽象方法、static 方法、常量、变量 抽象方法、全局常量 子类使用 class 子类 extends 抽象类 class 子类 implements 接口, 接口... 关系 抽象类可以实现多个接口 接口不能继承抽象类，却可以继承多个父接口 权限 可以使用各种权限 只能使用 public 权限 限制 单继承局限 没有单继承局限 相同： 子类：抽象类和子类都必须有子类，子类必须覆写全部的抽象方法实例化对象：依靠子类对象的向上转型进行对象的实例化 建议； 在进行某些公共操作时一定要定义出接口 有了接口就需要利用子类完善方法 如果是自己写的方法，那么绝对不要使用关键字 new 直接实例化接口子类，应该使用工厂类完成 接口是在类之上的标准，接口比类更加灵活，在考虑用什么实现时，优先考虑接口 Object 类Object 类是所有类的父类，也就是说任何一个类在定义时如果没有明确地继承一个父类，那么它就是 Object 的子类。 Object 类的 3 个覆写方法 方法 描述 public String toString() 取得对象信息 public Boolean equals(Object obj) 对象比较 public int hashCode() 取得对象哈希码","categories":[{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"http://akashigakki.github.io/tags/面向对象/"}]},{"title":"面向对象","slug":"Object_Oriented/object-oriented","date":"2019-09-13T16:00:00.000Z","updated":"2020-10-06T11:15:40.719Z","comments":true,"path":"2019/09/14/Object_Oriented/object-oriented/","link":"","permalink":"http://akashigakki.github.io/2019/09/14/Object_Oriented/object-oriented/","excerpt":"面向对象 定义简单 Java 类，static 与 this 的理解。","text":"面向对象 定义简单 Java 类，static 与 this 的理解。 简单 Java 类基本要求： 类名称必须存在意义 类中的所有属性必须 private 封装，封装之后的属性必须提供 setter、getter 类中可以提供任意多个构造方法，但是必须保留一个无参构造方法 类中不允许出现任何输出语句，所有信息输出必须交给被调用处输出 类中需要提供一个可以取得对象完整信息的方法，一般叫做 getInfo()，返回 String 型数据 创建 Emp 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Emp &#123; private int empno; // 编号 private String ename; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 奖金 // 定义一个无参构造方法 public Emp() &#123; &#125; // 有参构造 public Emp(int empno, String ename, String job, double sal, double comm) &#123; this.empno = empno; this.ename = ename; this.job = job; this.sal = sal; this.comm = comm; &#125; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public double getSal() &#123; return sal; &#125; public void setSal(double sal) &#123; this.sal = sal; &#125; public double getComm() &#123; return comm; &#125; public void setComm(double comm) &#123; this.comm = comm; &#125; public String getInfo() &#123; return \"empno: \" + empno + '\\n' + \"ename: \" + ename + '\\n' + \"job: \" + job + '\\n' + \"sal: \" + sal + '\\n' + \"comm: \" + comm; &#125;&#125; 调用 123456public class Main &#123; public static void main(String[] args) &#123; Emp emp = new Emp(7936, \"akashi\", \"Engineer\", 5000, 3000); System.out.println(emp.getInfo()); &#125;&#125; 数组 数组属于引用类型，所以在数组的操作过程中，以有内存分配问题。 声明并开辟数组 12数据类型 数组名称 [] = new 数据类型 [长度];数据类型 [] 数组名称 = new 数据类型 [长度]; 分步完成 12数据类型 [] 数组名称 = null; // 声明数组名称 = new 数据类型 [长度]; // 开辟空间 内存分配中和对象保存唯一的区别在于：对象中的堆内存是保存属性，而数组中的堆内存保存的是一组信息。 数组长度不允许改变，所以使用时需注意数组越界。 不能使用未开辟空间的数组。 初始化 12数据类型 [] 数组名称 = &#123;value, value, ....&#125;;数据类型 [] 数组名称 = new 数据类型 [] &#123;value, value, ....&#125;; eg: 1int[] data = new int[] &#123;1, 2, 3, 4&#125;; 二维数组1234567891011121314public class Array &#123; public static void main(String[] args) &#123; int[][] data = new int[][] &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125; &#125;; for (int i = 0; i &lt; data.length; i++) &#123; for (int j = 0; j &lt; data[i].length; j++) &#123; System.out.print(data[i][j] + \"\\t\"); &#125; System.out.println(); &#125; &#125;&#125; 从二维数组开始其实就进入了一个多维数组的概念范畴，一维数组表示一行数据，二维数组描述一张表的数据，三维数据就可以描述一个三维图形的结构，也就是说数组维度越多概念越复杂。在开发中只有很少的情况会涉及多维开发，尽量使用一维数组来进行简洁高效的开发。 数组操作 数组冒泡排序 1234567891011121314151617181920212223242526public class BubbleSort &#123; public static void sort(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - 1; j++) &#123; if (array[j] &gt; array[j+1]) &#123; int temp =array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; show(array); &#125; private static void show(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \"\\t\"); &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123;2, 1, 9, 0, 5, 3, 7, 4, 63, 8, 6&#125;; BubbleSort sorter = new BubbleSort(); sorter.sort(array); &#125;&#125; 数组转置 1234567891011121314151617181920212223public class Reverse &#123; public static void reverse(int[] array) &#123; int N = array.length; for (int i = 0; i &lt; N/2; i++) &#123; int temp = array[i]; array[i] = array[N-1-i]; array[N-1-i] = temp; &#125; show(array); &#125; private static void show(int[] array) &#123; for (int i : array) &#123; System.out.print(i + \"\\t\"); &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123;1, 2, 3, 4, 5, 6, 7&#125;; Reverse sorter = new Reverse(); sorter.reverse(array); &#125;&#125; 对象数组数组是引用类型，而类也是引用类型，如果是对象数组的话表示一个引用类型里面嵌套其他的引用类型。 对象数组动态初始化 1类名称 [] 对象数组名称 = new 类名称 [长度]; 对象数组的静态初始化 1类名称 [] 对象数组名称 = new 类名称[] &#123;实例化对象, 实例化对象,....&#125;; eg: 123456789public static void main(String[] args) &#123; Book[] books = new Book[] &#123; new Book(\"Java\"), new Book(\"Python\"), new Book(\"JavaScript\") &#125;; for (int i = 0; i &lt; books.length; i++) &#123; books[i].getInfo(); &#125;&#125; String 类的基本概念 String 是字符串的描述类型，虽然 String 本身不属于引用数据类型，但是可以像基本数据类型那要直接赋值，是一个特殊的类。 常用 API public class String String() 创建一个空字符串 int length() 获取字符串长度 int charAt(int i) 获取第 i 个字符 int indexOf(String p) 获取 p 第一次出现的位置(没有则返回 -1) int indexOf(String p, int i) 获取 p 在 i 个字符后第一次出现的位置(没有则返回 -1) String concat(String t) 将 t 附在该字符串末尾(字符串连接) String sbustring(int i, int j) 使用字符串的子字符串(第 i 个字符到第 j-1 个字符) String[] split(String delim) 使用 delim 分隔符切分字符串 int compareTo(String t) 比较字符串 boolean equals(String t) 该字符串的是和 t 的值是否相同 int hashCode() 散列值 boolean contains(String t) 判断字符串是否存在 String trim() 去掉字符串两边空格 String replaceAll(String t, String rep_t) 用新的内容替换全部旧的内容 this 关键字 this 可以完成 3 中方法：调用本类属性，调用本类方法，表示当前对象。 调用本类属性123456789public class Book &#123; private String title; private double price; public Book(String title, double price) &#123; this.title = title; this.price = price; &#125;&#125; 这里为类中的属性赋值，如果参数名与属性名相同，在 Java 里会采用 就近取用 的原则，若没有对属性进行 this 的指定，就不能标记为属性，函数会把形参里面的值赋给形参，就无法对属性赋值了。 用 this 表示本类的属性，与形参区分，在名称相同的情况下也可以明确定位并赋值。 调用本类方法this 本质上就是明确进行本类结构的标记，而除了访问类中的属性外，也可以进行类中的方法调用。 12345678910public class Book &#123; public void getInfo() &#123; this.show(); System.out.println(\"图书名称：\" + title + \"，价格：\" + price); &#125; public void show() &#123; System.out.println(\"this 调用本类方法\"); &#125;&#125; 1234567891011121314151617181920212223public class Book &#123; private String title; private double price; public Book() &#123; System.out.println(\"new 了一个新对象\"); &#125; public Book(String title) &#123; this(); this.title = title; &#125; public Book(String title, double price) &#123; this(); this.title = title; this.price = price; &#125; public void getInfo() &#123; System.out.println(\"图书名称：\" + title + \"，价格：\" + price); &#125;&#125; 表示当前对象当前对象就是指当前正在调用的类中的方法的实例化对象。 数据表与 简单 Java 类映射 简单 Java 类在实际的开发中都是根据其数据表的定义来实现的。 下面我们需要实现主表与部门表的对应关系，即：一个部门可以有多个员工 我们使用一个外键 deptno 进行关联。 Dept: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Dept &#123; private int deptno; private String dname; private String loction; public Dept() &#123; &#125; public Dept(int deptno, String dname, String loction) &#123; this.deptno = deptno; this.dname = dname; this.loction = loction; &#125; public int getDeptno() &#123; return deptno; &#125; public void setDeptno(int deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getLoction() &#123; return loction; &#125; public void setLoction(String loction) &#123; this.loction = loction; &#125; public String getInfo() &#123; return \"deptno = \" + deptno + '\\n' + \"dname = \" + dname + '\\n' + \"loction = \" + loction; &#125;&#125; Emp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Emp &#123; private int empno; // 编号 private String ename; // 姓名 private String job; // 职位 private double sal; // 工资 private double comm; // 奖金 private int deptno; // 部门编号 // 定义一个无参构造方法 public Emp() &#123; &#125; // 有参构造 public Emp(int empno, String ename, String job, double sal, double comm, int deptno) &#123; this.empno = empno; this.ename = ename; this.job = job; this.sal = sal; this.comm = comm; this.deptno = deptno; &#125; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public double getSal() &#123; return sal; &#125; public void setSal(double sal) &#123; this.sal = sal; &#125; public double getComm() &#123; return comm; &#125; public void setComm(double comm) &#123; this.comm = comm; &#125; public int getDeptno() &#123; return deptno; &#125; public void setDeptno(int deptno) &#123; this.deptno = deptno; &#125; public String getInfo() &#123; return \"empno: \" + empno + '\\n' + \"ename: \" + ename + '\\n' + \"job: \" + job + '\\n' + \"sal: \" + sal + '\\n' + \"comm: \" + comm + '\\n' + \"deptno: \" + deptno; &#125;&#125; Main: 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Emp emp1 = new Emp(7936, \"akashi\", \"Engineer\", 5000, 3000, 10); Emp emp2 = new Emp(7937, \"asuka\", \"Engineer\", 5000, 3000, 20); Dept dept = new Dept(10, \"IT\", \"Chengdu\"); emp2.setDeptno(10); System.out.println(\"=========================\"); System.out.println(emp1.getInfo()); System.out.println(\"=========================\"); System.out.println(emp2.getInfo()); System.out.println(\"=========================\"); System.out.println(dept.getInfo()); &#125;&#125; static 关键字 static 关键字可以用于定义属性及方法。 static 定义属性如果类中的属性希望定义为公共属性(所有对象都可以使用的属性)，则可以在声明属性前加上 static 关键字。 eg: 1static String pub = \"人民邮电出版社\"; 既然 static 是一个公共属性的概念，那么如果只是简单的由一个对象去修改 static 的做法不是很适合，最好的做法是由类来进行访问。 1Book.pub = \"电子工业出版社\"; static 属性与非 static 属性最大的一个区别，所有非 static 属性必须产生实例化对象才可以进行访问，但是 static 属性不受实例化对象的控制，在没有实例化对象产生的情况下，也可以使用 static 属性。 在实际的开发中， static 定义的属性出现几率并不是很高。 static 定义方法使用 static 定义的方法也可以在没有实例化对象的情况下由类名称直接进行调用。 static 方法不能直接访问非 static 属性或方法，只能调用 static 属性或方法。 非 static 方法可以访问 static 的属性和方法，不受任何限制。 当一个类中没有属性产生，就没有必要开辟堆内存保存属性内容了，这时候就可以考虑类中的方法使用 static 进行声明。 主方法 public 主方法是程序的入口，所以这个方法对任何操作都一定是可见的，所以就必须使用 public 类修饰符 访问包位置 private protected public 本类 可见 可见 可见 同包其他类或子类 不可见 可见 可见 其他包的类或子类 不可见 不可见 可见 static 证明此方法是由类名称调用的 void 没有返回值 main 是一个系统规定好的方法名称，不能修改 String[] args 指的是程序运行时传递的参数","categories":[{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"http://akashigakki.github.io/tags/面向对象/"}]},{"title":"典型算法处理实现","slug":"Algorithmic_Basis/basis","date":"2019-09-11T16:00:00.000Z","updated":"2020-10-06T11:15:40.718Z","comments":true,"path":"2019/09/12/Algorithmic_Basis/basis/","link":"","permalink":"http://akashigakki.github.io/2019/09/12/Algorithmic_Basis/basis/","excerpt":"典型算法处理实现 记录几个常见算法实现。","text":"典型算法处理实现 记录几个常见算法实现。 典型的数组处理找出数组中最大的元素1234567891011121314151617class Max &#123; public static double max(double[] list) &#123; double max = list[0]; for (int i = 0; i &lt; list.length; i++) &#123; if (list[i] &gt; max) &#123; max = list[i]; &#125; &#125; return max; &#125; public static void main(String args[]) &#123; double[] list = new double[] &#123;1.2, 3.0, 5, 0.4, 9, 6.8, 7&#125;; System.out.println(max(list)); &#125;&#125; 计算数组元素的平均值1234567891011121314151617class Avg &#123; public static double avg(double[] list) &#123; int N = list.length; double sum = 0; for (int i = 0; i &lt; N; i++) &#123; sum += list[i]; &#125; double average = sum / N; return average; &#125; public static void main(String args[]) &#123; double[] list = new double[] &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; double avg = avg(list); System.out.println(avg); &#125;&#125; 复制数组123456789101112131415161718class CopyArray &#123; public static int[] copy(int[] list) &#123; int N = list.length; int[] list_new = new int[N]; for (int i = 0; i &lt; N; i++) &#123; list_new[i] = list[i]; &#125; return list_new; &#125; public static void main(String[] args) &#123; int[] list1 = new int[] &#123;1, 2, 3, 4, 5, 6, 7&#125;; int[] list2 = copy(list1); for (int i : list2) &#123; System.out.println(i); &#125; &#125;&#125; 颠倒数组元素的顺序12345678910111213141516171819class Reverse &#123; public static double[] rev(double[] list) &#123; int N = list.length; for (int i = 0; i &lt; N / 2; i++) &#123; double temp = list[i]; list[i] = list[N-1-i]; list[N-1-i] = temp; &#125; return list; &#125; public static void main(String[] args) &#123; double[] list = new double[] &#123;1, 2, 3, 4, 5, 6, 7&#125;; double[] rev_list = rev(list); for (int i = 0; i &lt; rev_list.length; i++) &#123; System.out.println(rev_list[i]); &#125; &#125;&#125; 矩阵相乘123456789101112131415161718192021222324252627282930class MatrixMult &#123; public static double[][] multip(double[][] array1, double[][] array2) &#123; int N = array1.length; double[][] matrix = new double[N][N]; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; for (int k = 0; k &lt; N; k++) &#123; matrix[i][j] += array1[i][k] * array2[k][j]; &#125; &#125; &#125; return matrix; &#125; public static void main(String[] args) &#123; double[][] array1 = new double[][] &#123; &#123;1, 2, 3&#125;, &#123;3, 2, 1&#125; &#125;; double[][] array2 = new double[][] &#123; &#123;1, 2, 3&#125;, &#123;3, 2, 1&#125; &#125;; double[][] matrix = multip(array1, array2); int M = array1.length; for (int i = 0; i &lt; M; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; System.out.println(matrix[i][j]); &#125; &#125; &#125;&#125; 典型的静态方法的实现计算一个整数的绝对值1234567891011121314class Abs &#123; public static int abs(int x) &#123; if (x &lt; 0) &#123; return -x; &#125; else &#123; return x; &#125; &#125; public static void main(String[] args) &#123; int x = -2; System.out.println(abs(x)); &#125;&#125; 计算一个浮点数的绝对值1234567891011121314class AbsDouble &#123; public static double abs(double x) &#123; if (x &lt; 0) &#123; return -x; &#125; else &#123; return x; &#125; &#125; public static void main(String[] args) &#123; double x = -2.3; System.out.println(abs(x)); &#125;&#125; 判定一个数是否是素数123456789101112131415161718class Prime &#123; public static boolean isPrime(int n) &#123; if (n &lt; 2) &#123; return false; &#125; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; int x = 123; System.out.println(isPrime(x)); &#125;&#125; 计算平方根123456789101112131415161718class Sqrt &#123; public static double sqrt(double x) &#123; if (x &lt; 0) &#123; return Double.NaN; &#125; double err = 1e-15; double t = x; while(Math.abs(t - x / t) &gt; err * t) &#123; t = (x / t + t) / 2.0; &#125; return t; &#125; public static void main(String[] args) &#123; double x = 9; System.out.println(sqrt(x)); &#125;&#125; 计算直角三角形的斜边1234567891011class Hypotenuse &#123; public static double hypotense(double a, double b) &#123; return Math.sqrt(a * a + b * b); &#125; public static void main(String[] args) &#123; double x = 3; double y = 4; System.out.println(hypotense(x,y)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"算法","slug":"算法","permalink":"http://akashigakki.github.io/tags/算法/"}]},{"title":"Java 基本概念","slug":"basic-java/java-basic","date":"2019-09-10T16:00:00.000Z","updated":"2020-10-06T11:15:40.726Z","comments":true,"path":"2019/09/11/basic-java/java-basic/","link":"","permalink":"http://akashigakki.github.io/2019/09/11/basic-java/java-basic/","excerpt":"Java 基本概念 从 Java 语法开始，理解面向对象的基本概念。","text":"Java 基本概念 从 Java 语法开始，理解面向对象的基本概念。 数据类型划分 数据类型 基本数据类型 数值型 整数类型(byte、short、int、long) 浮点类型(float、double) 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组([]) 方法的定义 方法也被称为函数，是一段可以重复调用的代码块。 方法的主要功能是封装可执行的一段代码，这样不仅仅可以进行重复调用，更可以方便的实现代码的维护，定义如下： 1234public[权限修饰符] static[属性] 返回值类型[关键字] 方法名称(参数类型, 参数变量, ...) 抛出异常类型 &#123; 方法体 (本方法要执行的若干操作); [return [返回值];]&#125; 方法重载 方法重载是指方法名称相同，参数的类型不同或个数不同，调用的时候将会按照传递的参数类型和个数完成不同方法体的执行。 1234567891011121314151617181920212223242526272829303132333435363738public class FuncOverload &#123; /** * 实现两个整型类型的相加 * @param x * @param y * @return */ public static int add(int x, int y) &#123; return x + y; &#125; /** * 实现三个整型类型的相加 * @param x * @param y * @param z * @return */ public static int add(int x, int y, int z) &#123; return x + y + z; &#125; /** * 实现两个小数类型的相加 * @param x * @param y * @return */ public static double add(double x, double y) &#123; return x + y; &#125; public static void main(String[] args) &#123; System.out.println(\"两个整型参数相加：\" + add(10, 20)); System.out.println(\"三个整型参数相加：\" + add(10, 20, 30)); System.out.println(\"两个浮点型参数相加：\" + add(10.2, 20.3)); &#125;&#125; 方法的递归调用 递归调用是一种特殊的调用形式，指的是方法自己调用自己的形式。 注意：在项目应用的开发中避免过多的使用递归，因为如果处理不当，就有可能出现内存溢出问题。 123456789101112131415161718public class RecursiveCall &#123; /** * 实现从 1 到 n 的累加 * @param num * @return */ public static int sum(int num) &#123; if (num == 1) &#123; return 1; &#125; else &#123; return num + sum(num - 1); &#125; &#125; public static void main(String[] args) &#123; System.out.println(sum(100)); &#125;&#125; 面向对象程序设计的特性封装性一层含义是指把对象的属性和行为看成一个密不可分的整体，将两者封装在一个不可分割的独立单位(即对象)中； 另一层含义指信息隐蔽，把不需要让外界知道的信息隐藏起来，有些对象的属性和行为允许外界知道或使用，但不允许更改，而另一些对象的属性及行为，则不允许外界知晓，或只允许使用对象的功能，而尽可能隐蔽对象的功能实现细节。 继承性继承性是指首先拥有反应事物一般性质的类，然后在其基础上派生出反应特殊事物的类。 面向对象程序设计的继承机制，大大增强了程序代码的可复用性，提高了软件开发的效率，降低了程序产生错误的可能，也为程序的修改扩展提供了便利。 若一个子类只允许继承一个父类，称为单继承；若允许继承多个父类，称为多继承。目前许多面向对象程序设计语言不支持多继承。Java 通过接口 interface 的方式弥补由于 Java 不支持多继承而带来的子类不能使用多个父类成员的缺憾。 多态性多态是指允许程序中出现重名现象。 Java 中含有方法重载和对象多态两种形式的多态。 方法重载：在一个类中，允许多个方法使用同一个名字，但方法的参数不同，完成的功能也不同。 对象多态：子类对象可以与父类对象相互转换，而且根据其使用的子类不同完成不同的功能也不同。 多态的特性使程序的抽象程度和简洁程度更高，有助于程序设计人员对程序的分组协同开发。 类与对象类与对象的基本定义12345678class 类名称 &#123; 数据类型 属性(变量); 权限修饰符 返回值的数据类型 方法名称 (形式参数列表) &#123; 执行语句; [return 返回值;] &#125;&#125; eg: 12345678class Book &#123; String title; double price; public void getInfo() &#123; System.out.printLn(\"图书名称：\" + title, \"价格：\" +price); &#125;&#125; 类定义完成之后，需要使用还需要对象声明和实例化： 1类名称 对象名称 = new 类名称(); 分步完成： 12类名称 对象名称 = null; // 声明对象对象名称 = new 类名称(); // 实例化对象 因为类属于引用数据类型，而引用数据类型和基本数据类型最大的不同就在于需要内存的开辟及使用，关键字 new 的主要功能就是开辟内存空间，只要使用引用数据类型，就必须使用 new 关键字来开辟空间。 对象实例化后可进行的操作： 对象.属性： 表示操作类中的属性的内容；对象.方法()： 表示调用类中的方法。 123456789public class BookClass &#123; public static void main(String[] args) &#123; Book book = new Book(); book.title = \"Java\"; book.price = 89.0; book.getInfo(); &#125;&#125; 引用数据的初步分析引用传递是整个 Java 中的精髓所在，而引用传递的核心概念也只有一点：一块堆内存空间(保存对象的属性信息)可以同时被多个栈内存共同指向，则每一个栈内存都可以修改同一块堆内存空间的属性值。 堆内存(heap)：保存每一个对象的属性内容，堆内存需要用关键字 new 才可以开辟，如果一个对象没有对应的堆内存指向，将无法使用。 栈内存(stack)：保存的是一块堆内存的地址数值，每一块栈内存只能保存一块堆内存地址。 对象引用传递： 1234567891011121314public class BookClass &#123; public static void main(String[] args) &#123; Book book1 = new Book(); book1.title = \"Java\"; book1.price = 89.0; Book book2 = new Book(); book2 = book1; book2.price = 69.8; book1.getInfo(); &#125;&#125; 这里打印 book1 的结果，价格变成了 69.8，这就是两个不同的栈内存指向了同一块堆内存空间(引用传递)，所以当 book2 修改属性内容时，会直接影响 book1对象的内容。 我们还可以发现，我们开始为 book2 new 了一个内存空间，但是没有使用，而是使用引用传递(book2 = book1)，这样原本 book2 的内存空间没有任何指向，就会成为垃圾空间。 所有的垃圾会不定期的被垃圾收集器(Garbage Collector)回收，回收后会被释放掉其所占用的空间。 封装性初步分析需要让用户看不见操作的东西，就需要使用 private 关键字进行封装，将类中的属性进行私有化操作。 Book.java: 1234567public class Book &#123; private String title; private double price; public void getInfo() &#123; System.out.println(\"图书名称：\" + title + \"，价格：\" + price); &#125;&#125; Main.java: 12345678public class Main &#123; public static void main(String[] args) &#123; Book book = new Book(); book.title = \"Java\"; book.pirce = 89.9; book.getInfo(); &#125;&#125; 这样运行项目是会报错的，在声明了 private 关键字之后，属性只能在 Book 类中被访问，就不可以对属性进行直接调用了，所以主类需要使用，就需要定义 setter、getter 方法。 下面改写 Book 类： 123456789101112131415161718192021222324public class Book &#123; private String title; private double price; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public void getInfo() &#123; System.out.println(\"图书名称：\" + title + \"，价格：\" + price); &#125;&#125; 在 Main 中调用： 12345678public class Main &#123; public static void main(String[] args) &#123; Book book = new Book(); book.setTitle(\"Java\"); book.setPrice(89.9); book.getInfo(); &#125;&#125; 构造方法如果实例化新的对象，需要使用关键字 new 来完成，但是除了 new 这个关键字之外，还有可能在对象实例化时为其进行一些初始化操作，直观时候就需要构造方法的支持。 构造方法是一种特殊的方法，它只在新对象实例化的时候调用，其定义原则是：方法名称与类名称相同，没有返回类型声明，同时构造方法也可以进行重载。 与普通方法的区别： 构造方法是在实例化新对象(new)的时候只调用一次； 普通方法是在实例化对象产生之后，通过 Object.function 的方式多次调用。 利用构造方法为属性赋值： 1234567891011121314151617181920212223242526272829public class Book &#123; private String title; private double price; public Book(String title, double price) &#123; this.title = title; this.price = price; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public void getInfo() &#123; System.out.println(\"图书名称：\" + title + \"，价格：\" + price); &#125;&#125; Main 调用: 123456public class Main &#123; public static void main(String[] args) &#123; Book book = new Book(\"Java\", 89.8); book.getInfo(); &#125;&#125; 构造方法重载： 123456789101112131415161718192021222324252627282930313233343536public class Book &#123; private String title; private double price; public Book() &#123; &#125; public Book(String title) &#123; this.title = title; &#125; public Book(String title, double price) &#123; this.title = title; this.price = price; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public void getInfo() &#123; System.out.println(\"图书名称：\" + title + \"，价格：\" + price); &#125;&#125; 现在方法被我们重载了 3 次，我们可传入不同的形参： 12345678910public class Main &#123; public static void main(String[] args) &#123; Book book = new Book(\"Java\", 89.8); book.getInfo(); Book book1 = new Book(\"Python\"); book1.getInfo(); Book book2 = new Book(); book2.getInfo(); &#125;&#125; 匿名对象按之前的内存关系来讲，对象的名字可以解释为在栈内存中保存，而对象的具体内容(属性)在堆内存中保存，这样一来，没有栈内存指向堆内存空间，就是一个匿名对象。 匿名对象 12345public class Main &#123; public static void main(String[] args) &#123; new Book(\"Java\", 89.9).getInfo(); &#125;&#125; 通过匿名对象调用了类中的方法，但由于匿名对象没有对应的栈内存指向，所以只能使用一次，一次之后就将成为垃圾，并且等待被 GC 回收释放。","categories":[{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/tags/Java/"},{"name":"基础","slug":"基础","permalink":"http://akashigakki.github.io/tags/基础/"}]},{"title":"Matplotlib 数据可视化","slug":"python_matplotlib/matplotlib","date":"2019-09-06T16:00:00.000Z","updated":"2020-10-06T11:15:40.917Z","comments":true,"path":"2019/09/07/python_matplotlib/matplotlib/","link":"","permalink":"http://akashigakki.github.io/2019/09/07/python_matplotlib/matplotlib/","excerpt":"matplotlib 数据可视化 使用 Python 的数学绘图库工具 matplotlib 生成图表。","text":"matplotlib 数据可视化 使用 Python 的数学绘图库工具 matplotlib 生成图表。 安装 matplotlib1pip3 install matplotlib 绘制简单的折线图123456from matplotlib import pyplotsquates = [1, 4, 9, 16, 25]pyplot.plot(squates)pyplot.show() 修改标签文字和线条粗细123456789101112131415from matplotlib import pyplotsquates = [1, 4, 9, 16, 25]pyplot.plot(squates, linewidth=3)# 设置标题，并给坐标轴加上标签pyplot.title('Square Numbers', fontsize=17)pyplot.xlabel('Value', fontsize=10)pyplot.ylabel('Square of Value',fontsize=10)# 设置刻度标记的大小pyplot.tick_params(axis='both', labelsize=13)pyplot.show() 校正图形我们发现向 plot() 提供一系列数字时，它假设第一个数据点对应的 x 轴的值为 0，但是我们的第一个值为 1，我们需要同时提供输入值和输出值。 12345678910111213141516from matplotlib import pyplotsquates = [1, 4, 9, 16, 25]input_values = [1, 2, 3, 4, 5]pyplot.plot(input_values, squates, linewidth=3)# 设置标题，并给坐标轴加上标签pyplot.title('Square Numbers', fontsize=17)pyplot.xlabel('Value', fontsize=10)pyplot.ylabel('Square of Value',fontsize=10)# 设置刻度标记的大小pyplot.tick_params(axis='both', labelsize=13)pyplot.show() 使用 scatter() 绘制散点图并设置其样式1234567891011121314from matplotlib import pyplotpyplot.scatter(2, 4, s=30)# 设置标题，并给坐标轴加上标签pyplot.title('Square Numbers', fontsize=17)pyplot.xlabel('Value', fontsize=10)pyplot.ylabel('Square of Value',fontsize=10)# 设置刻度标记的大小pyplot.tick_params(axis='both', which='major', labelsize=13)pyplot.show() 绘制一系列点12345678910111213141516from matplotlib import pyplotx_values = [1, 2, 3, 4, 5]y_values = [1, 4, 9, 16, 25]pyplot.scatter(x_values, y_values, s=30)# 设置标题，并给坐标轴加上标签pyplot.title('Square Numbers', fontsize=17)pyplot.xlabel('Value', fontsize=10)pyplot.ylabel('Square of Value',fontsize=10)# 设置刻度标记的大小pyplot.tick_params(axis='both', which='major', labelsize=13)pyplot.show() 自动计算数据12345678910111213141516171819from matplotlib import pyplotx_values = list(range(1, 1001))y_values = [x**2 for x in x_values]pyplot.scatter(x_values, y_values)# 设置标题，并给坐标轴加上标签pyplot.title('Square Numbers', fontsize=17)pyplot.xlabel('Value', fontsize=10)pyplot.ylabel('Square of Value',fontsize=10)# 设置刻度标记的大小pyplot.tick_params(axis='both', which='major', labelsize=13)# 设置每个坐标轴的取值范围pyplot.axis([0, 1100, 0, 1100000])pyplot.show() 删除数据点轮廓1pyplot.scatter(x_values, y_values, edgecolors='none', s=7) 自定义颜色向 scatter() 传递参数 c 设置颜色的名称。 1pyplot.scatter(x_values, y_values, c='red', edgecolors='none', s=7) RGBA: 1pyplot.scatter(x_values, y_values, c=(0.8, 0.2, 0.2, 0.4), edgecolors='none', s=7) 使用颜色映射示例通过 y 的值设置颜色： 12345678910111213141516171819from matplotlib import pyplotx_values = list(range(1, 1001))y_values = [x**2 for x in x_values]pyplot.scatter(x_values, y_values, c=y_values, cmap=pyplot.cm.Blues, edgecolors='none', s=7)# 设置标题，并给坐标轴加上标签pyplot.title('Square Numbers', fontsize=17)pyplot.xlabel('Value', fontsize=10)pyplot.ylabel('Square of Value',fontsize=10)# 设置刻度标记的大小pyplot.tick_params(axis='both', which='major', labelsize=13)# 设置每个坐标轴的取值范围pyplot.axis([0, 1100, 0, 1100000])pyplot.show() 自动保存图表要让程序自动将图表保存到文件中，可以将 pyplot.show() 替换为 pyplot.savefig() 1pyplot.savefig('squares_plot.png', bbox_inches='tight') 随机漫步随机漫步每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的。 创建 RandomWalk() 类为模拟随机漫步，我们将创建一个 RandomWalk 类，它随机的选择前进方向。这个类需要三个属性，其中一个是存储随机漫步次数的变量，另外两个是列表，分别存储随机漫步经过的每个点的 x 和 y 坐标。 123456789from random import choiceclass RandomWalk(): def __init__(self, num_points=5000): self.num_points = num_points # 从(0, 0)开始 self.x_values = [0] self.y_values = [0] 选择方向1234567891011121314151617181920212223242526272829303132from random import choiceclass RandomWalk(): def __init__(self, num_points=5000): self.num_points = num_points # 从(0, 0)开始 self.x_values = [0] self.y_values = [0] def fill_walk(self): # 漫步直到指定长度 while len(self.x_values) &lt; self.num_points: # 决定前进的方向及距离 x_direction = choice([1, -1]) x_distance = choice([0, 1, 2, 3, 4]) x_step = x_direction * x_distance y_direction = choice([1, -1]) y_distance = choice([0, 1, 2, 3, 4]) y_step = y_direction * y_distance # 拒绝原地踏步 if x_step == 0 and y_step == 0: continue # 计算下一个点的 x 和 y 的值 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step self.x_values.append(next_x) self.y_values.append(next_y) rw_visual 12345678from matplotlib import pyplotfrom random_walk import RandomWalkrw = RandomWalk()rw.fill_walk()pyplot.scatter(rw.x_values, rw.y_values, s=7)pyplot.show() 模拟多次12345678910111213from matplotlib import pyplotfrom random_walk import RandomWalkwhile True: rw = RandomWalk() rw.fill_walk() pyplot.scatter(rw.x_values, rw.y_values, s=7) pyplot.show() keep_running = input(\"Make anther walk? (y/n): \") if keep_running == 'n': break 给点着色1234567891011121314151617# from matplotlib import pyplotimport matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: rw = RandomWalk() rw.fill_walk() point_numbers = list(range(rw.num_points)) plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Reds, edgecolors='none', s=7) plt.show() keep_running = input(\"Make anther walk? (y/n): \") if keep_running == 'n': break 重新绘制起点和终点12plt.scatter(0, 0, c='green', edgecolors='none', s=30)plt.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none', s=30) 隐藏坐标轴12plt.axes().get_xaxis().set_visible(False)plt.axes().get_yaxis().set_visible(False) 增加点数rw = RandomWalk(50000) 123456789101112131415161718192021222324# from matplotlib import pyplotimport matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: rw = RandomWalk(50000) rw.fill_walk() point_numbers = list(range(rw.num_points)) plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, edgecolors='none', s=7) # 突出起点和终点 plt.scatter(0, 0, c='green', edgecolors='none', s=30) plt.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none', s=30) plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) plt.show() keep_running = input(\"Make anther walk? (y/n): \") if keep_running == 'n': break 调整尺寸plt.figure(figsize=(10, 6)) 1234567891011121314151617181920212223242526# from matplotlib import pyplotimport matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: rw = RandomWalk(50000) rw.fill_walk() plt.figure(figsize=(10, 6)) point_numbers = list(range(rw.num_points)) plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, edgecolors='none', s=7) # 突出起点和终点 plt.scatter(0, 0, c='green', edgecolors='none', s=30) plt.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none', s=30) plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) plt.show() keep_running = input(\"Make anther walk? (y/n): \") if keep_running == 'n': break 使用 Pygal 模拟掷骰子Pygal 可以生成可缩放的矢量图形文件。 安装1pip3 install pygal 画廊查看 pygal 文档 ：http://pygal.org/ 创建 Die 类123456789from random import randintclass Die(): def __init__(self, num_sides=6): self.num_sides = num_sides def roll(self): return randint(1, self.num_sides) 掷骰子掷一个 6 面的骰子，将结果打印出来： 1234567891011from die import Diedie = Die()results = []for roll_num in range(100): result = die.roll() results.append(result)print(results) 分析结果计算每个点出现的次数： 123456789101112131415161718from die import Diedie = Die()results = []for roll_num in range(1000): result = die.roll() results.append(result)# print(results)frequencies = []for value in range(1, die.num_sides+1): frequency = results.count(value) frequencies.append(frequency)print(frequencies) 绘制直方图123456789101112131415161718192021222324252627282930from die import Dieimport pygaldie = Die()results = []for roll_num in range(1000): result = die.roll() results.append(result)# print(results)frequencies = []for value in range(1, die.num_sides+1): frequency = results.count(value) frequencies.append(frequency)# print(frequencies)# 对结果进行可视化hist = pygal.Bar()hist.title = \"Results of rolling one D6 1000 times.\"hist.x_labels = ['1', '2', '3', '4', '5', '6']hist.x_title = \"Result\"hist.y_title = \"Frequencies\"hist.add('D6', frequencies)hist.render_to_file('die_visual.svg') 同时掷两个骰子1234567891011121314151617181920212223242526272829303132from die import Dieimport pygaldie_1 = Die()die_2 = Die()results = []for roll_num in range(1000): result = die_1.roll() + die_2.roll() results.append(result)# print(results)frequencies = []max_result = die_1.num_sides + die_2.num_sidesfor value in range(1, max_result+1): frequency = results.count(value) frequencies.append(frequency)# print(frequencies)# 对结果进行可视化hist = pygal.Bar()hist.title = \"Results of rolling two D6 1000 times.\"hist.x_labels = ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']hist.x_title = \"Result\"hist.y_title = \"Frequencies\"hist.add('D6 +D6', frequencies)hist.render_to_file('die_visual_2d6.svg') 同时掷两个不同面数的骰子1234567891011121314151617181920212223242526272829303132from die import Dieimport pygaldie_1 = Die()die_2 = Die(10)results = []for roll_num in range(5000): result = die_1.roll() + die_2.roll() results.append(result)# print(results)frequencies = []max_result = die_1.num_sides + die_2.num_sidesfor value in range(1, max_result+1): frequency = results.count(value) frequencies.append(frequency)# print(frequencies)# 对结果进行可视化hist = pygal.Bar()hist.title = \"Results of rolling a D6 and D10 5000 times.\"hist.x_labels = ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16']hist.x_title = \"Result\"hist.y_title = \"Frequencies\"hist.add('D6 +D6', frequencies)hist.render_to_file('die_visual_d6_d10.svg')","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"工具","slug":"Python/工具","permalink":"http://akashigakki.github.io/categories/Python/工具/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"工具","slug":"工具","permalink":"http://akashigakki.github.io/tags/工具/"}]},{"title":"Python 包管理工具 pipenv 构建虚拟环境","slug":"python_pipenv/pipenv","date":"2019-09-02T16:00:00.000Z","updated":"2020-10-06T11:15:40.919Z","comments":true,"path":"2019/09/03/python_pipenv/pipenv/","link":"","permalink":"http://akashigakki.github.io/2019/09/03/python_pipenv/pipenv/","excerpt":"Python 包管理工具 pipenv 构建虚拟环境 又一 Python 虚拟环境和包管理工具，requests 的作者 Kenneth Reitz 的作品，相当于 virtualenv 和 pip 的合体，解决 requirements.txt 的不确定构建问题。","text":"Python 包管理工具 pipenv 构建虚拟环境 又一 Python 虚拟环境和包管理工具，requests 的作者 Kenneth Reitz 的作品，相当于 virtualenv 和 pip 的合体，解决 requirements.txt 的不确定构建问题。 为什么使用 pipenv requirements.txt 依赖管理存在局限。 当我们通过 pip install -r requirements.txt 安装依赖模块时，会默认安装最新的版本，但如果你的库有存在不兼容旧版本的接口时，代码在新的环境下就不能运行了。这就是不确定构建。 依赖关系的复杂性 当我们的项目使用了包 A，它依赖于包 B 的 2.x 系列，这时候 requirements.txt 会长这样： 12A==1.0B==2.5.1 当我们需要使用包 C，而它依赖于 B 的 3.0 的 API，在这种情况下 pip install C 就会变成： 123A==1.0B==3.0.0C==1.0 这时候 A 很可能就没办法使用。而通过 Pipfile.lock 的确定构建就可以解决这个问题。 自己的使用感受是，相对于 virtualenv， 启动和使用更加方便。 因为 virtualenv 的项目和虚拟环境是分开管理的，在使用 virtualenv 一段时间以后，就可能分不清哪个项目对应哪个虚拟环境，而使用 pipenv 就不用关心这个问题，直接在项目下 pipenv shell 就搞定了。 但为保证包的完整性，加入到 Pipfile 的操作就比较耗时间。 安装 pipenv1pip3 install pipenv 创建虚拟环境123mkdir projectcd projectpipenv install 初始化好虚拟环境后，会在项目目录下生成 2个 文件 Pipfile 和 Pipfile.lock。为 pipenv 包的配置文件，代替原来的 requirement.txt。 项目提交时，可将 Pipfile 文件和 Pipfile.lock 文件一并提交，待其他开发克隆下载，根据此 Pipfile 运行命令 pipenv install --dev 生成自己的虚拟环境。 Pipfile.lock 文件是通过 hash 算法将包的名称和版本，及依赖关系生成哈希值，可以保证包的完整性。 激活虚拟环境1pipenv shell pipenv 很智能，如果你进入了一个项目文件没有安装虚拟环境，直接启动虚拟环境，那么它会新建一个虚拟环境。 也就是说，创建过程是可以直接省略的。 退出虚拟环境1exit 安装/卸载包安装相关模块并加入到 Pipfile 12pipenv install xxxpipenv uninstall xxx 查看安装包依赖关系1pipenv graph 查看虚拟环境安装目录1pipenv --venv 显示目录信息1pipenv --where 生成 lockfile1pipenv lock 运行 Python 文件1pipenv run python xxx.py 删除虚拟环境1pipenv --rm","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"http://akashigakki.github.io/tags/虚拟环境/"}]},{"title":"自建图床方案","slug":"picture-bed/picture-bed","date":"2019-08-29T16:00:00.000Z","updated":"2020-10-06T11:15:40.825Z","comments":true,"path":"2019/08/30/picture-bed/picture-bed/","link":"","permalink":"http://akashigakki.github.io/2019/08/30/picture-bed/picture-bed/","excerpt":"自建图床方案 原使用的新浪微博图床不再支持外链，虽然还有补救的方法，但最安全的还是自建图床，本篇在图床的使用上提供了一些选择。","text":"自建图床方案 原使用的新浪微博图床不再支持外链，虽然还有补救的方法，但最安全的还是自建图床，本篇在图床的使用上提供了一些选择。 维持原有方案对于 Markdown 的重度依赖者来说，图床简直就是刚需，对图床的选择一般考量的无非就是方便、安全且免费，但这个需求原本就是矛盾的，想要数据安全就没有免费的说法。 免费图床方案一般有：新浪微博图床、微博图床、SMMS图床 当然除了插件使用也可以直接在网站上使用：SM·MS、Imgur 微博图床配合 Chrome 插件使用完全符合方便的理念，但从微博限制外链开始，很多站点的图片就无法显示了，解决办法也有很多，但都存在缺陷，而且最重要的是,不是自己的图床终究没有办法掌控，万一哪一天微博将你图片删了也完全没有办法，所以使用免费图床，图片备份还是很重要的。 从 https 回到 http 这个是折腾最少的方法，改了协议以后，原微博图床上的图片就可以正常显示了，但缺点也很明显，在都转为加密协议的潮流之下，使用回 http 会有诸多限制，类似于微信公众号等平台是不再支持不加密的图片显示的，同时也存在安全风险。 设置 no-referrer 在文章页面源码加上 1&lt;meta name=\"referrer\" content=\"no-referrer\" /&gt; 这种做法也存在缺陷，这样的话站点就识别不了你，对 SEO 优化很不友好。 自建付费图床直接购买一个对象存储服务自建图床是最安全的做法，推荐的有阿里云的 OSS 对象存储、腾讯云的 COS 对象存储、七牛云和又拍云等。实测阿里云 OSS 一年 40GB 只需 9 元，还是很划算的。 七牛云搭建免费图床那有没有既免费又安全的图床呢，当然也是有的。 七牛云的对象存储服务在实名认证之后可以免费领取 10GB 的云存储空间和每个月 10GB 的 CDN 加速流量，对于个人写作完全是足够了，我们可以用它来搭建一个自用的图床。 首先，注册并完成认证：七牛云 进入对象存储，新建存储空间，设置空间名称和选择区域 配置完成后，其实就可以在 内容管理 上传和查看图片了。但开始之前我们需要先绑定一个域名，七牛云提供的域名仅供测试使用，时间到了以后会自动回收。所以配置一个自己的域名可以一直使用。 完成基本配置之后是配置域名的 CNAME 详情可参考官方文档：配置CNAME 这里以阿里云的为例，添加 CNAME 记录： 配置成功以后就可以配合插件或应用使用了。 可以使用插件七牛云图床自动上传七牛云和获取 Markdown 格式图片 也可以使用PicGo配置来实现七牛云上传： 在配置前我们需要获取七牛云的密钥： 在应用中填入详细配置 这样我们就可以开始使用了。 GitHub 搭建免费图床 当然我们还有更多的选择，还可以同样使用 PicGo + Github 实现自建图床。 创建仓库 设置 拷贝仓库到本地（可省略） 获取 token 访问 https://github.com/settings/tokens/new，创建 token 获取到 token 设置 PicGo 配置 PicGo 的相关参数 这样，一个 Github 的图床也创建好了。 但是，国内访问 Github 的速度还是比较缓慢，其实我们可以把 Github 换成国内的码云，这样速度就上来了，具体操作和搭建 Github 的图床大致相同。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"图床","slug":"图床","permalink":"http://akashigakki.github.io/tags/图床/"}]},{"title":"免费申请 Google Cloud 服务器一年 300 刀攻略","slug":"google_cloud/google-cloud","date":"2019-08-28T16:00:00.000Z","updated":"2020-10-06T11:15:40.731Z","comments":true,"path":"2019/08/29/google_cloud/google-cloud/","link":"","permalink":"http://akashigakki.github.io/2019/08/29/google_cloud/google-cloud/","excerpt":"免费申请 Google Cloud 服务器一年 300 刀攻略 没有双币信用卡也可以免费申请 Google Cloud 服务器教程。","text":"免费申请 Google Cloud 服务器一年 300 刀攻略 没有双币信用卡也可以免费申请 Google Cloud 服务器教程。 前提条件 首先，你需要有一个 Google 账号 可以访问 Google Cloud，也就是科学上网（翻墙） 拥有一张双币信用卡，或者是虚拟外币信用卡也可以（Google需要验证身份，会先扣除1美元，不过很快会退回，实际不收费） 因为博主并没有信用卡，所以申请了 payonner 的电子银行账号，同样也通过了验证。 注册 payonner官网： www.payoneer.com 没有什么难度，按照要求注册就行。 详细注册参考指引链接：https://aibing.cc/jiaocheng/52280.shtml 经验证，美国地区任意银行账户都是可以的（博主按照参考教程多申请了几个账户都可以收到 Google 的付款），无需多申请。 激活 Google Cloud官网： https://console.cloud.google.com/freetrial 进入官网，登录 Google 账号，就可以开始激活： 截止到博主现在的时间，Google 已经取消了中国区域的用户注册，因为国内薅羊毛实在太多。如果有支持外币的信用卡可以直接选取香港或台湾地区进行激活，因为我申请的 payonner 美国区的银行账号，选取美国区域进行激活。 地址选取 谷歌地图搜索一个真实的美国地址就行，或者直接 google： 美国地址生成器，就可以获得一个随机的美国地址。 付款方式 付款方式是最关键的，没有双币信用卡就需要选择银行账户进行验证： 仔细填好之前在 payonner 注册获得的银行账户就可以开始免费试用了。 验证如果通过信用卡进行激活，那么 Google 会先扣除 1 美元进行验证，验证成功后 $300，就到账了，扣除的金额也会退回。 如果通过美国区域银行账户进行激活，需要等待 2~3 天， Google 会通过银行账户打款不足 1 美元的金额，我们需要拿到具体的金额数字到 Google Cloud 控制台 =&gt; 结算 =&gt; 付款方法 进行验证，输入正确的金额就可以验证成功，获取免费 $300 的额度。 一般用户 $300 是完全够用一年的，如果你只是搭一个 ssr 看油管 4K 视频和简单的服务器搭建学习，但为了防止超出付费还是进入 结算 =&gt; 预算和提醒 设置一个提醒。 当然，网上还有很多使用一年以后继续不换账号和银行卡再续一年的骚操作，就不知道到时限快用完的时候还是否有效(逃)。 以上，就是全部的激活教程。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"},{"name":"云服务","slug":"杂项/云服务","permalink":"http://akashigakki.github.io/categories/杂项/云服务/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"云服务","slug":"云服务","permalink":"http://akashigakki.github.io/tags/云服务/"},{"name":"Google Cloud","slug":"Google-Cloud","permalink":"http://akashigakki.github.io/tags/Google-Cloud/"}]},{"title":"SSH 远程登录 Google Cloud 应用实例","slug":"google_cloud_ssh/ssh","date":"2019-08-28T16:00:00.000Z","updated":"2020-10-06T11:15:40.738Z","comments":true,"path":"2019/08/29/google_cloud_ssh/ssh/","link":"","permalink":"http://akashigakki.github.io/2019/08/29/google_cloud_ssh/ssh/","excerpt":"ssh 远程登录 Google Cloud 应用实例 配置 ssh 实现远程登录访问 Google 服务器。","text":"ssh 远程登录 Google Cloud 应用实例 配置 ssh 实现远程登录访问 Google 服务器。 首先，创建实例后，切换到 root: 1sudo -i 或者 1sudo su 查看当前用户查看当前用户： 1who 为当前用户设置新密码： 1sudo passwd xxx 注意：xxx 是你的用户名，也可以设置 root 用户的密码： sudo passwd root 也可以在 root 用户权限下新增加一个用户并设置密码 12adduser akashipasswd akashi 编辑 ssh 配置文件1vim /etc/ssh/sshd_config 修改以下内容为 yes: 12PermitRootLogin yesPasswordAuthentication yes 重启生效 1sudo service sshd reload 使用 ssh 密码登录1ssh 用户名@公网IP 如： 1ssh akashi@35.201.201.156 输入上面设置的密码实现登录。 本地生成公钥和私钥接下来介绍第二种方法，通过密钥实现登录。 在本地终端使用 ssh-keygen 命令生成新的密钥： 1ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME] 注意：[KEY_FILENAME] 是要用于 SSH 密钥文件的名称，[USERNAME] 是连接到该实例的用户的用户名。 如： 12cd .sshssh-keygen -t rsa -f cloudkey -C akashi 注意：生成密钥时的 passphrase 是给 private key 设置一个密码，避免私钥被人盗用的风险。 获取密钥12公钥文件：~/.ssh/[KEY_FILENAME].pub私钥文件：~/.ssh/[KEY_FILENAME] 为下一步准备，获取公钥： 1cat [KEY_FILENAME].pub 复制获取到的整串字符。 修改 SSH 公钥元数据拿着获取的公钥，访问 Google Cloud，进入谷歌云平台页面 -&gt; 计算引擎 -&gt; 元数据 -&gt; SSH 密钥，粘贴保存： 修改完成之后，Google 就会把上面这段 public key 写入到 ~/.ssh/authorized_keys 中 接下来就可以通过密钥登录了。 本地通过私钥登录赋予私钥文件仅本人可读权限 1chmod 400 &lt;下载的与云服务器关联的私钥的绝对路径&gt; 1ssh -i ~/.ssh/[KEY_FILENAME] [USERNAME]@[IP] 如： 1ssh -i ~/.ssh/cloudkey -p 22 akashi@35.201.201.156 至此，两种远程登录的方法介绍完毕。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/categories/Linux/"},{"name":"SSH","slug":"Linux/SSH","permalink":"http://akashigakki.github.io/categories/Linux/SSH/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"http://akashigakki.github.io/tags/SSH/"}]},{"title":"Google Cloud 搭建 SSR 服务器","slug":"google_cloud_ssr/ssr","date":"2019-08-27T16:00:00.000Z","updated":"2020-10-06T11:15:40.739Z","comments":true,"path":"2019/08/28/google_cloud_ssr/ssr/","link":"","permalink":"http://akashigakki.github.io/2019/08/28/google_cloud_ssr/ssr/","excerpt":"Google Cloud 搭建 SSR 服务器 使用 Google Cloud 搭建属于自己的 SSR 服务器，实现愉快的科学上网。","text":"Google Cloud 搭建 SSR 服务器 使用 Google Cloud 搭建属于自己的 SSR 服务器，实现愉快的科学上网。 创建 VM 实例 创建 首先，进入 Google Cloud 控制台，创建 VM 实例。 计算 =&gt; Computer Engine =&gt; VM 实例 配置 选取配置： 实际尝试后，台湾的速度是最快的。选择最小的内存，只是用于 SSR 服务端安装是足够的，预计每月 $5，一年就是 $60。 防火墙需要勾选允许 http 和 https 点击创建，这样，服务器就创建成功了。 安装 BBR 远程登录 BBR 是 Google 发布的拥塞控制算法，可以有效缓解服务器连接速度慢等问题，下面我们通过脚本进行安装。 点击实例的 ssh，在浏览器进行远程登录： 获取 root 权限 连接到服务器后，获取 root 用户权限： 1sudo -i 安装一些基本的工具： 123sudo yum install gitsudo yum install wgetsudo yum update 安装 BBR 加速 1wget -N –no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 完成后重启服务器，并且重新连接，获取 root 用户权限后，开启 BBR 服务： 1bash bbr.sh start 安装 SSR接下来，就是 SSR 服务端的安装。 ssr 脚本安装 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 按照要求配置 ip，用户，端口，密码、加密方式，协议等等。 然后，记住你的配置，之后需要在本地的客户端输入配置实现科学上网。 设置外部 IP 为静态 添加防火墙规则 注意：设置的端口需要与刚才 ssr 设置的端口一致。 以我的为例，我设置的是 8989 端口，端口原则上可以自由设置，但尽量设置大于 1000 的端口，而且不要和一些自己开发常用的端口冲突。 至此，服务端的配置已经全部完成，接下来就可以在 Mac、PC、IOS、安卓 等设备上安装 shadowsocks 客户端，填写你的配置，实现科学上网了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/categories/Linux/"},{"name":"SSR","slug":"Linux/SSR","permalink":"http://akashigakki.github.io/categories/Linux/SSR/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/tags/Linux/"},{"name":"云服务","slug":"云服务","permalink":"http://akashigakki.github.io/tags/云服务/"},{"name":"Google Cloud","slug":"Google-Cloud","permalink":"http://akashigakki.github.io/tags/Google-Cloud/"},{"name":"SSR","slug":"SSR","permalink":"http://akashigakki.github.io/tags/SSR/"}]},{"title":"Redis 使用笔记","slug":"redis/redis","date":"2019-08-23T16:00:00.000Z","updated":"2020-10-06T11:15:40.921Z","comments":true,"path":"2019/08/24/redis/redis/","link":"","permalink":"http://akashigakki.github.io/2019/08/24/redis/redis/","excerpt":"Redis 使用笔记 Redis 是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时， Redis 的诸多高级功能使其可以胜任消息队列、任务队列等不同的角色。","text":"Redis 使用笔记 Redis 是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时， Redis 的诸多高级功能使其可以胜任消息队列、任务队列等不同的角色。 简介存储结构Redis 是 Remote Dictionary Server （远程字典服务器）的缩写，它以字典结构存储数据，并允许其他应用通过 TCP 协议读写字典中的内容。与大多数脚本语言中的字典一样， Redis 字典中的键值除了可以使字符串，还可以是其他数据类型。它支持的键值数据类型如下： 字符串类型 散列表类型 列表类型 集合类型 有序集合类型 内存存储与持久化Redis 数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，因此 Redis 在性能上对比其他的基于硬盘存储的数据库有明显的优势，一台普通的笔记本电脑上， Redis 可以在一秒内读写超过 10 万个键值。 将数据存储在内存中也存在问题，比如程序退出后内存中的数据会丢失。不过 Redis 提供了对持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。 缓存、队列系统由于 Redis 提供了丰富的功能，越来越多的人将其用作缓存、队列系统。 Redis 可以为每个键设置生存时间（Time To Live TTL），生存时间到期后键会自动被删除。可以限定数据占用的最大内存空间，在数据达到空间限制之后可以按照一定的规则自动淘汰掉不需要的键。用作缓存系统性能非常出色。 除此之外， Redis 的列表类型键可以用来实现队列，并且支持阻塞式读取，可以很容易的实现一个高性能的优先级队列。同时在更高的层面上，Redis 还支持 “发布/订阅&quot; 的消息模式。 准备安装在 OS X 系统中安装： 1brew install redis 启动1redis-server 可以重新打开一个终端窗口，查看 redis： 1ps -ef | grep redis 或者通过端口号检查 Redis 服务器状态： 1netstat -nlt|grep 6379 Redis 服务器默认使用 6379 端口，当然可以通过 --port 自定义端口号。 启动 Redis-client启动完服务器以后，重新打开一个窗口： 1redis-cli 即可以启动 Redis 客服端。 查看连接： 1redis-cli ping 如果连接正常，会输出 PONG redis-cli 的一些使用： 自定义地址和端口号 1redis-cli -h 127.0.0.1 -p 6379 测试连接（不带运行参数 redis-cli） 1PING 1echo hi 停止终端运行： 1redis shutdown 考虑到 Redis 有可能正在将内存中的数据同步到硬盘中，强行终止 Redis 进程可能会导致数据丢失。通过 SHUTDOWN 命令， Redis 会先断开所有的客服端连接，然后根据配置执行持久化，最后完成退出。 Redis 可执行文件说明 名称 说明 redis-server Redis 服务器 redis-cli Redis 命令行客服端 redis-benchmark Redis 性能测试工具 redis-check-aof AOF 文件修复工具 redis-check-dump RDB 文件检查工具 redis-sentinel Sentinel 服务器 Redis 数据类型基础命令以下我们在开启 Redis 服务器的情况下，另外再开一个终端启动 redis-cli 客户端进行下面的学习： 键值存储 语法： 1set key value eg: 1set bar 1 存入了一个键为 bar，值为 1 的键值。 获取键名列表 语法： 1keys pattern eg: 1keys * 使用上面的命令我们获得了 Redis 中所有的键。 注意：keys 命令需要遍历 Redis 中所有的键， 当键的数量较多时会影响性能，不建议在生产环境中使用。 判断键是否存储 语法： 1exists key [key ...] eg: 1exists bar 如果存在，返回整数类型 1，否则返回 0。 获取数据类型 type 用来获取键值的数据类型，返回值可能是 string (字符串类型)、hash(散列类型)、list(列表类型)、set(集合类型)、zset(有序集合类型) 语法： 1type key eg: 1type bar 返回的值是 string。 删除键 语法： 1del key [key ...] eg: 1del bar 这样就删除了我们刚刚存入的 {&#39;bar&#39;: &#39;1&#39;} 字符串类型 赋值与取值 语法： 1set key value 1get key set 和 get 是 Redis 里面最基础的两个命令，用来设置和获取键值。 递增 当存储的字符串是整数形式时，Redis 提供了一个实现当前键值递增的命名 incr，返回递增后的值。 语法： 1incr key eg: 1incr num 当操作的键不存在时默认键值为 0，所以输出结果是递增后的 1。当键值不是整数时会提示错误。 增加指定的整数 语法： 1incrby key increment incrby 命令和 incr 命令基本一样，只不过前者可以通过参数 increment 指定一次增加的数值，如： 1incrby num 3 在上一次（1） 的结果上再增加 3，那么输出应该为 4。 减少指定的整数 语法： 1decr key 1decrby key decrement 同样的，decr 和 decrby 可以实现让键值递减。 eg: 1decrby num 2 继续使用上面的参数例子，在 4 的基础上减去 2，输出结果是 2。 增加指定浮点数 语法： 1incrbyfloat key increment eg: 1incrbyflodt num 2.7 输出结果为 4.7。 向尾部追加值 语法： 1append key value eg: 123set say helloappend say ' asuka!'get say append 的作用是向键值的末尾追加 value。例子中使用了引号是因为参数包含了空格，也可以输入类似于： 123set name akashiappend name saiget name 输出为： akashisai 获取字符串长度 语法： 1strlen key strlen 命令返回键值的长度，如果键不存在则返回 0。 eg: 1strlen say 同时获取/设置多个键值 语法： 12mget key [key ...]mset key value [key value ...] 位操作 一个字节由 8 个二进制位组成， Redis 提供了 4 个命令可以直接对二进制位进行操作。 语法： 1234getbit key offsetsetbit key offset valuebitcount key [start] [end]bitop operation destkey key [key ...] getbit 命令可以获得一个字符串类型键指定位置的二进制位的值（ 0 或 1）。 bitcount 命令可以获得字符串类型键中值是 1 的二进制位个数。 散列类型 散列表(hash)的键值是一种字典结构，其存储了字段(field)和字段值的映射，但字段值只能是字符串，不支持其他数据类型，也就是说，散列类型不能嵌套其他类型。 注意：其实 Redis 的其他数据类型同样不支持数据类型的嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或者散列表等。 散列类型适合存储对象。 赋值与取值 语法： 12345hset key field valuehget key fieldhmset key field value [field value ...]hmget key field [field ...]hgetall key eg: 12hset user name akashihget user name hset 的方便之处在于不区分插入和删除操作，这意味着不用事先判断字段是否存在来决定执行的是插入(insert)还是更新(update)操作。当字段不存在时，执行插入操作，返回 1，当字段存在时，执行更新操作，返回 0；当键本身不存在时，还会自动建立。 当需要设置/查找多个字段时： 12hmset user age 21 email akashi_sai@163.comhmget user name age email 如果想获取键中的所有字段和字段的值却不知道键中有哪些字段时，可以使用 hgetall 命令： 1hgetall user 判断字段是否存在 语法: 1hexists key field hexists 用来判断一个字段是否存在，如果存在返回 1，否则返回 0。 当字段不存在时赋值 语法： 1hsetnx key field value nx 表示 if not exisits hsetnx 与 hset 类似，区别在于如果字段已经存在，hsetnx 将不再执行任何操作。 增加数字 语法： 1hincrby key field increment eg: 1hincrby user age 1 删除字段 语法： 1hdel key field [field ...] hdel 命令可以删除一个或多个字段，返回值是被删除的字段个数。 只获取字段名或字段值 语法： 12hkeys keyhvals key eg: 12hkeys userhvals user 获取字段数量 语法： 1klen key eg: 1hlen user 列表类型 列表类型(list)可以存储一个有序的字符串列表，常用的操作是向两端添加元素，或者获得列表的某一个片段。 向列表两端增加元素 语法： 12lpush key value [value ...]rpush key value [value ...] eg: 12lpush list 1lpush list 0 在列表左边增加元素，完成后，列表 list 的元素为 0 1。 继续从右边增加元素： 1rpush list 2 3 现在列表中的元素排列为: 0 1 2 3。 从列表两端弹出元素 语法： 12lpop keyrpop key 以上面声明的 list 为例： 1lpop list 我们知道现在最左边的数字是 0，所以输入命令，返回了 0。 1rpop list 同样，返回最右边的数字 3。现在我们弹出了列表两端的两个数字，还存在列表中的还有 1 2。 获取列表中元素的个数 语法： 1llen key 当键不存在时返回 0。 1llen list 返回了当前的列表元素个数 2。 获取列表片段 语法： 1lrange key start stop Redis 的列表索引从 0开始，返回包括两端的元素。为了演示，我们先往列表里添加一些元素： 12rpush 3 4 5 6 7lrange list 2 5 现在列表里的元素分别有 1 2 3 4 5 6 7，返回索引从 2 开始，5 结束的元素，有：3 4 5 6。 删除列表中指定的值 语法： 1lrem key count value lrem 会删除列表中前 count 个值为 value 的元素，返回值是实际删除的元素个数。根据 count 的值的不同，分为以下几种情况： count &gt; 0 时，lrem 会从列表左边开始删除前 count 个值为 value 的元素。 count &lt; 0 时，lrem 会从列表右边开始删除前 |count| 个值为 value 的元素。 count = 0 时，lrem 会删除所有值为 value 的元素。 eg: 1lrem key 0 7 以上例子删除了所有值为 7 的元素。 获取/设置指定索引的元素值 如果要将列表类型当做数组来用，lindex 是必不可少的，lindex 用来返回指定元素的索引，索引从 0 开始。 12lindex key indexlset key index value eg: 12lindex list 1lindex list -1 -1 表示最右边的索引，以此类推，-2 即为列表里面倒数第二个元素。 只保留列表指定片段 语法： 1ltrim key start end ltrim 可以删除指定索引范围之外的所有元素，其指定列表范围的方法和 lrange 相同。 向列表中插入元素 语法： 1linsert key before|after pivot value linsert 先从左到右查找 pivot 元素位置，然后根据参数决定在之前或者之后插入。 将元素从一个列表转到另一个列表 语法： 1rpoplpush source destination 即先执行 rpop 再执行 lpush命令先从 source 列表类型键的右边弹出一个元素，然后将其加入到 destination 列表类型的左边，并返回这个元素的值。 当把列表类型当做队列使用时，rpoplpush 可以直观的在多个队列中传递数据； 当 source 和 destination 相同时，会不断执行队尾元素移到队首，借助这个特性可以实现一个网站监控系统。 集合类型 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在 Redis 内部是使用值为空的散列表实现的，所以这些操作的时间复杂度都是 O(1)。最方便的是多个集合类型之间还可以进行并集、交集和差集运算。 集合与列表类型的比较： 集合类型 列表类型 存储内容 字符串 字符串 有序性 否 是 唯一性 是 否 增加/删除元素 语法： 12sadd key member [member ...]srem key member [member ...] sadd 用来向集合中增加一个或多个元素，如果键不存在则会自动创建。因为在一个集合中不能有相同的元素，所以如果加入的元素已经存在就会忽略这个元素，返回值是成功加入的元素的数量。 eg: 12sadd letters asadd letters a b c 第一条成功加入一个元素，返回 1，第二条加入的 a 元素已经存在，忽略，新加入了 2 个元素，返回 2。 同理的 srem 用来从集合中删除一个或多个元素，并返回删除成功的个数。 eg: 1srem letters a 获得集合中的所有元素 语法： 1smembers key 判断元素是否在集合中 语法： 1sismember key member 判断一个元素是否存在集合中的时间复杂度为 O(1)， 当存在时返回 1，否则返回 0。 集合间运算 语法： 123sdiff key [key ...]sinter key [key ...]sunion key [key ...] sdiff 表示执行集合的差集运算、sinter 表示执行集合的交集运算、sunion 表示执行集合的并集运算。 获取集合中元素个数 语法： 1scard key 进行集合运算并将结果存储 语法： 123sdiffstore destination key [key ...]sinterstore destination key [key ...]sunionstore destination key [key ...] 随机获取集合中的元素 语法； 1srandmember key [count] eg: 12srandmember letterssrandmember letters 2 可选参数 count 用来随机获取多个元素， 当 count 为正数时，随机获取集合里 count 个不重复的元素； 当 count 为负数时，随机获取集合里 |count| 个元素，有可能相同； 从集合中弹出一个元素 语法： 1spop key eg: 1spop letters 有序集合 有序集合就是在集合类型的基础上将集合中的每个元素都关联到了一个分数，分数可以是相同的。 有序集合与列表有些类似，下面介绍它们的不同之处： 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多以后，访问中间数据的速度会较慢，它合适实现如 “新鲜事”,”日志”等很少访问中间元素的应用，或者是时效性比较强的应用。 有序集合类型是使用散列表和跳表(skip list)实现的，即使读取中间数据速度也很快(时间复杂度为O(log(n))) 列表中不能简单地调整某个元素的位置，但是有序集合可以(通过更改元素关联的分数) 有序集合要比列表类型更耗费内存 增加元素 语法： 1zadd key score member [score member ...] zadd 用来向有序集合加入一个元素和该元素的分数，如果该元素已存在则会用新的分数替换原有的分数，返回新加入到集合中的元素个数。 获得元素分数 1zscore key member 获取排名在某个范围的元素列表 语法： 12zrange key start stop [withscores]zrevrange key start stop [withscores] zrevrange 和 zrange 的唯一不同在于 zrevrange 是按照元素分数从大到小的顺序给出结果的。 获得指定分数范围内的元素 语法： 1zrangebyscore key min max [withscores] [limit offset count] 第一个可选参数就和字面的意思一样，是带上分数返回，第二个可选参数表示在获得的元素列表的基础上向后偏移 offset 个元素，并且只获取前 count 个元素。 增加某个元素的分数 语法： 1zincrby key increment member zincrby 可以增加一个元素的分数，返回值是更改后的分数。 获取集合中元素的数量 语法： 1zcard key 获得指定分数范围内的元素个数 语法： 1zcount key min max 删除一个或多个元素 语法： 1zrem key member [member ...] 按照排名范围删除元素 语法： 1zremrangebyrank key start stop 按照分数范围删除元素 语法: 1zremrangebyscore key min max 获得元素排名 语法： 12zrank key memberzrevrank key member zrank 会按照元素从小到大的顺序获得元素排名，相反， zrevrank 会按照从大到小的顺序排名。 计算有序集合的交集 语法: 1zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregatesum|min|max]","categories":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/categories/数据库/"},{"name":"Redis","slug":"数据库/Redis","permalink":"http://akashigakki.github.io/categories/数据库/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"http://akashigakki.github.io/tags/Redis/"}]},{"title":"Scrapy 实战：广度优先策略抓取","slug":"scrapy-vcbstudio/bf-scrapy","date":"2019-08-21T16:00:00.000Z","updated":"2020-10-06T11:15:40.923Z","comments":true,"path":"2019/08/22/scrapy-vcbstudio/bf-scrapy/","link":"","permalink":"http://akashigakki.github.io/2019/08/22/scrapy-vcbstudio/bf-scrapy/","excerpt":"Scrapy 实战：广度优先策略抓取 通过广度优先策略抓取 VCB-Studio 站点文章信息。","text":"Scrapy 实战：广度优先策略抓取 通过广度优先策略抓取 VCB-Studio 站点文章信息。 新建项目首先，选取本次爬取的站点： https://vcb-s.com/，通过观察分析，站点文章采用分页的形式，我们可以先遍历每一页抓取到所有的文章 URL 列表，之后再进入具体文章抓取需要的信息。以上就是广度优先策略抓取。 CrawlSpider 本次我们以通用爬虫为例， ScrawlSpider 是 Scrapy 提供的一个通用 Spider，在 Spider 里，我们可以指定一些爬取规则来实现页面的爬取，这些爬取规则由一个专门的数据结构 Rule 表示。 Rule 里面包含提取和跟进页面的配置，Spider 会根据 Rule 来确定当前页面中的那些链接需要继续爬取、那些页面的爬取结果需要用哪个方法解析等。 首先，创建一个 CrawlSpider，我们需要定制一个模板，可以通过以下命令查看： 1scrapy genspider -l 之前默认使用 basic，现在我们使用 crawl 进行创建： 1scrapy genspider -t crawl source vcb-s.com 简单修改生成后的模板： 123456789101112131415161718192021import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Ruleclass SourceSpider(CrawlSpider): name = 'source' allowed_domains = ['vcb-s.com'] start_urls = ['https://vcb-s.com/'] rules = ( Rule(LinkExtractor(allow=r'Items/'), callback='parse_item', follow=True), ) def parse_item(self, response): item = &#123;&#125; #item['domain_id'] = response.xpath('//input[@id=\"sid\"]/@value').get() #item['name'] = response.xpath('//div[@id=\"name\"]').get() #item['description'] = response.xpath('//div[@id=\"description\"]').get() return item 定义 Rule在 Rule 里面定义规则，爬取当前分页下面的文章链接和后一页的连接，返回到回调函数之后，就可以获取所有分页下的文章链接了： 1234rules = ( Rule(LinkExtractor(allow='archives\\/.*', restrict_css='#article-list .title-article a'), callback='parse_item'), Rule(LinkExtractor(restrict_css='.pagination li:last-child a')) ) 使用正则表达式传递给 allow 做参数进行提取。 运行项目之前我们先设置 settings.py，不读取 robots.txt 和添加 user-agent 伪装为浏览器： 123ROBOTSTXT_OBEY = FalseUSER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' 接下来运行项目，就发现下一页和详情页都被抓取到了： 1scrapy crawl source Rule 规则定义十分强大，我们仅用了两行就实现了所有文章链接的提取和下一页的提取。 定义容器在 items.py 中定义我们要提取的字段： 12345678910import scrapyclass VcbstudioItem(scrapy.Item): collection = 'source_list' title = scrapy.Field() date = scrapy.Field() image = scrapy.Field() content = scrapy.Field() source_url = scrapy.Field() 这里我们定义了一个 collection，因为之后需要使用 MongoDB 进行存储，在这里先定义一个集合。 测试用例在提取页面信息的时候，我们不清楚自己定义的规则是否提取到准确的信息时，我们可以通过以下两种方式进行调试： Scrapy shell 在终端输入命令： 1scrapy shell https://vcb-s.com 这里的 URL 就是我们需要测试的 URL，通过这样来模拟 Scrapy 的请求过程，就可以测试 response 调用的 xpath() 和 css() 的数据提取了 例如： 123response.css('.title-article h1 a::text').getall()response.css('.label i.fa.fa-calendar::text').get() 查看数据是否被规则正确提取。 断点调试 在项目起始目录新建一个测试用例，通过打断点的形式进行测试，查看规则是否正确提取。 新建 test.py: 1234567891011121314# 引入命令行执行函数模块from scrapy.cmdline import executeimport sysimport os# 调试测试# 获取项目文件位置# 思路：获取当前位置文件的父文件目录path = os.path.dirname(os.path.abspath(__file__))# 设置项目的运行起始位置run_path = sys.path.append(path)# 执行spider命令进入调试的断点execute(['scrapy', 'crawl', 'source']) 执行命令中的列表参数就是我们启动项目输入的命令， debug 运行 test.py 就可以在自己设置的断点处查看当前数据的提取情况。 解析页面结合使用调试测试，就可以通过 xpath() 和 css() 提取数据，这里我们换一个方式，让提取信息更规整，使用 ItemLoader 实现配置化提取： 12345678910111213from vcbstudio.items import VcbstudioItemfrom scrapy.loader import ItemLoaderdef parse_item(self, response): loader = ItemLoader(item=VcbstudioItem(), response=response) loader.add_css('title', '.title-article h1 a::text') loader.add_css('date', '.label i.fa.fa-calendar::text') loader.add_css('image', '.thumbnail img::attr(\"src\")') loader.add_css('content', '.centent-article p::text') loader.add_css('source_url', '.dw-box.dw-box-download p a::attr(\"href\")') yield loader.load_item() 运行项目，至此，我们已经实现了站点文章信息的全部提取。 存储文件在管道中定义存储方法： 123456789101112131415161718192021222324252627import pymongofrom vcbstudio.items import VcbstudioItemclass MongoPipeline(object): def __init__(self, mongo_url, mongo_db): self.mongo_url = mongo_url self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_url=crawler.settings.get('MONGO_URL'), mongo_db=crawler.settings.get('MONGO_DB') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_url) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): if isinstance(item, VcbstudioItem): self.db[item.collection].save(dict(item)) return item 同时添加 MongoDB 配置参数到 settings.py: 12MONGO_URL = 'localhost'MONGO_DB = 'vcb-studio' 启用 Item Pipeline: 123ITEM_PIPELINES = &#123; 'vcbstudio.pipelines.MongoPipeline': 300,&#125; 图片下载Scrapy 还提供了专门处理下载的 Pipeline，包括文件下载和图片下载，同时支持异步和多线程，十分高效。 首先，定义文件存储路径： 1IMAGES_STORE = './images' 定义ImagePipeline: 内置的 ImagesPipeline 会默认读取 Item 的 image_urls 字段，并认为该字段是一个列表形式，它会遍历 Item 的 image_urls 字段，然后取出每个 URL 进行下载。 但是现在生成 Item 的图片链接的字段并不是 image_urls 字段， 所以为了实现下载，需要重新定义下载的部分逻辑。我们自定义一个 ImagePipeline ，继承内置的 ImagesPipeline ， 重写几个方法。 123456789101112131415class ImagePipeline(ImagesPipeline): def file_path(self, request, response=None, info=None): url = request.url file_name = url.split('/')[-1] return file_name def item_completed(self, results, item, info): image_path = [x['path'] for ok, x in results if ok] if not image_path: raise DropItem('Image Downloaded Failed.') return item def get_media_requests(self, item, info): for url in item['image']: yield Request(url) 设置启用： 1234ITEM_PIPELINES = &#123; 'vcbstudio.pipelines.MongoPipeline': 300, 'vcbstudio.pipelines.ImagePipeline': 301,&#125; 再次启动爬虫，就可以实现边抓取边下载图片了。 1scrapy crawl source","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"Scrapy","slug":"Python/Scrapy","permalink":"http://akashigakki.github.io/categories/Python/Scrapy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","permalink":"http://akashigakki.github.io/tags/Scrapy/"},{"name":"Spider","slug":"Spider","permalink":"http://akashigakki.github.io/tags/Spider/"},{"name":"爬虫","slug":"爬虫","permalink":"http://akashigakki.github.io/tags/爬虫/"}]},{"title":"Scrapy 实现豆瓣图片爬取","slug":"scrapy-douban/scrapy","date":"2019-08-18T16:00:00.000Z","updated":"2020-10-06T11:15:40.922Z","comments":true,"path":"2019/08/19/scrapy-douban/scrapy/","link":"","permalink":"http://akashigakki.github.io/2019/08/19/scrapy-douban/scrapy/","excerpt":"Scrapy 实现豆瓣图片爬取 使用 Scrapy 框架爬取豆瓣网站小姐姐图片资源（逃ﾚ(ﾟ∀ﾟ;)ﾍ=3=3=3）。","text":"Scrapy 实现豆瓣图片爬取 使用 Scrapy 框架爬取豆瓣网站小姐姐图片资源（逃ﾚ(ﾟ∀ﾟ;)ﾍ=3=3=3）。 准备工作 Scrapy 框架安装 1pip3 install scrapy 终端输入 scrapy 验证安装成功。 MongoDB 安装 1brew install mongodb 终端输入 mongo 验证安装成功。 PyMongo 安装 1pip3 install pymongo 验证安装： 123python3import pymongopymongo.version 创建项目首先，确定我们爬取的目标，我们以 豆瓣上 gakki 的所有图片为例，从 https://movie.douban.com/celebrity/1018562/photos/ 页面开始，爬取所有相关图片页的图片。然后开始创建项目： 创建一个 Scrapy 项目，项目初始文件可以直接用 scrpay 命令生成，命令如下： 1scrapy startproject gakkiDouban 创建 SpiderSpider 是自己定义的类， Scrapy 用它来从网页里抓取内容，并解析抓取的结果。 Spider 继承 Scrapy 提供的 Spider 类 scrapy.Spider，还要定义 Spider 的名称和起始请求，以及怎样处理爬取后的结果的方法。 使用命令行创建一个 Spider，命令如下： 12cd gakkiDoubanscrapy genspider images movie.douban.com/celebrity/1018562/photos/\\?start\\=0 进入刚才创建的文件夹，然后执行 genspider 命令。第一个参数是 Spider 的名称，第二个参数是网站的域名。这里为 ? 和 = 添加了转义字符。 创建 ItemItem 是保存爬取数据的容器，它的使用方法和字典类似。不过，相比字典，Item 多了额外的保护机制，可以避免拼写错误或者定义字段错误。 创建 Item 需要继承 scrapy.Item 类，并且定义类型为 scrapy.Field 的字段。观察目标网站，我们需要获取的内容有 url、page。 定义 Item，修改 item.py 如下： 12345import scrapyclass GakkidoubanItem(scrapy.Item): url = scrapy.Field() page = scrapy.Field() 这里定义了两个字段，接下来爬取时我们会使用到这个 Item。 解析 Response在创建 Spider 步骤时，我们看到有一个 parse 方法，它的参数 resposne 是 start_urls 里面的链接爬取后的结果。所以在 parse() 方法中，我们可以直接对 response 变量包含的内容进行解析，比如浏览器请求结果的网页源代码，或者进一步分析源代码的内容，或者找出结果中的链接而得到下一个请求。 这里我们先需要获得定义的字段内容 url 和 page： 12345678def parse(self, response): root = response.css('.article') page = root.css('.thispage::text').extract_first() urls = root.css('.cover') for uri in urls: url = uri.css('img::attr(\"src\")').extract()[0] 这里的 extract_first() 方法来获取第一个元素， extract() 方法获取整个列表。 使用 ItemItem 可以理解为一个字典，不过在声明的时候需要实例化，然后依次用刚才解析的结果赋值给 Item的每一个字段，最后将 Item 返回。 123456789101112from gakkiDouban.items import GakkidoubanItemdef parse(self, response): root = response.css('.article') item = GakkidoubanItem() item['page'] = root.css('.thispage::text').extract_first() urls = root.css('.cover') for uri in urls: item['url'] = uri.css('img::attr(\"src\")').extract()[0] yield item 后续 Request获取了页面内容抓取之后，我们还需要从当前页中找到信息生成下一个请求，这样循环往复迭代，实现整站的爬取。 12345678910111213def parse(self, response): root = response.css('.article') item = GakkidoubanItem() item['page'] = root.css('.thispage::text').extract_first() urls = root.css('.cover') for uri in urls: item['url'] = uri.css('img::attr(\"src\")').extract()[0] yield item next_url = response.css('.paginator .next a::attr(\"href\")').extract_first() url = response.urljoin(next_url) yield scrapy.Request(url=url, callback=self.parse) 这里我们获取了下一页的链接，然后调用 urljoin() 方法实现了下一个请求，这个方法在 URL 是相对地址时构造一个绝对地址，而如果是绝对地址又保持原样返回。 最后利用回调函数(callback)再次进入 pares()，就进入了下一页的爬取和解析。 运行在 settings.py 中设置 user-agent，伪装成浏览器： 1USER_AGENT ='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36' 这里因为域的问题修改一下 spider 文件，使其允许域名为豆瓣主目录，避免提取下一页时地址被过滤： 1234class ImagesSpider(scrapy.Spider): name = 'images' allowed_domains = ['movie.douban.com'] start_urls = ['https://movie.douban.com/celebrity/1018562/photos/] 终端进入项目爬虫目录运行： 1scrapy crawl images images 是我们上面自定义的 Spider 名称。 保存到文件现在运行完 Scpary 后，我们只能在控制台看到输出结果，如果要将结果保存下来改怎么做呢？ 如需保存成 Json 文件，可以执行如下命令： 1scrapy crawl images -o images.json 这样，运行完成之后，项目内多了一个 images.json 文件，包含了刚才抓取的所有内容。 如果需要以每个 Item 输入一行 Json ，输出后缀为 jl，为 jsonline 的缩写： 1scrapy crawl images -o images.jl 或者 1scrapy crawl images -o images.jsonlines 除了以上格式，还可以自定义其他输出，如 csv, xml, pickle, marshal 和 ftp 远程输出： 12345scrapy crawl images -o images.csvscrapy crawl images -o images.xmlscrapy crawl images -o images.picklescrapy crawl images -o images.marshalscrapy crawl images -o ftp://user:pass@ftp.example.com/path/to/images.csv 其中，ftp 输出需正确配置用户名、密码、地址、书城路径。 使用 Item Pipeline如果需要实现更复杂的操作，如将结果保存到数据库，筛选 item 等需要定义 Item Pipeline 来实现。 Item Pipeline 为项目管道，当 Item 生成后，它会自动被送到 Item Pipeline 进行处理，我们常用 Item Pipeline 来实现下面操作： 清理 HTML 数据 验证爬取数据，检查爬取字段 查重并丢弃重复内容 将爬取结果保存到数据库 要实现 Item Pipeline ，只需定义一个类并实现 process_item() 方法即可。启用 Item Pipeline 后，Item Pipeline 会自动调用这个方法。process_item() 方法必须返回包含数据的字典或 Item 对象，或者抛出 DropItem 异常。 实现如下： 12345678910111213141516171819202122232425import pymongoclass MongoPipeline(object): def __init__(self, mongo_url, mongo_db): self.mongo_url = mongo_url self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_url=crawler.settings.get('MONGO_URL'), mongo_db=crawler.settings.get('MONGO_DB') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_url) self.db = self.client[self.mongo_db] def process_item(self, item, spider): self.db[self.mongo_db].insert(dict(item)) return item def close_spider(self, spider): self.client.close() 定义好 MongoPipeline 之后，还需要在 settings.py 中使用它，需要定义 MongoDB 连接常量。 123456ITEM_PIPELINES = &#123; 'gakkiDouban.pipelines.MongoPipeline': 300,&#125;MONGO_URL = 'localhost'MONGO_DB = 'gakki_images' 在重新执行爬取，命令如下： 1scrapy crawl images 爬取完成之后， MongoDB 中就创建了一个 gakki_images 数据库和 gakki_images 集合。 一些自定义仔细分析豆瓣的 URL 我们会发现，以 https://img3.doubanio.com/view/photo/r/public/p747045173.jpg 为例，网站是通过字符串下标的第 37 位控制加载图片的大小的，豆瓣服务器的图片存储分为 m, l, r 等不同的格式，而 r 对应的就是 row，是存储的最高清的图片格式。 我们在所有图片页进行爬取，抓到的是 m 缩略图格式，现在需要将 URL 进行修改，获取原生的图片。 定义一个新的图片处理管道： 123456class SplitPipeline(object): def process_item(self, item, spider): url_split = list(item['url']) url_split[37] = 'r' item['url'] = ''.join(url_split) return item 同样，在 settings.py 中定义使用： 1234ITEM_PIPELINES = &#123; 'gakkiDouban.pipelines.SplitPipeline': 300, 'gakkiDouban.pipelines.MongoPipeline': 400,&#125; 再次执行爬取，就可以得到 row 豆瓣最高清格式的图片。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"Scrapy","slug":"Python/Scrapy","permalink":"http://akashigakki.github.io/categories/Python/Scrapy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","permalink":"http://akashigakki.github.io/tags/Scrapy/"},{"name":"Spider","slug":"Spider","permalink":"http://akashigakki.github.io/tags/Spider/"},{"name":"爬虫","slug":"爬虫","permalink":"http://akashigakki.github.io/tags/爬虫/"}]},{"title":"云服务器 ftp 的搭建和使用","slug":"centos-ftp/ftp-link","date":"2019-08-16T16:00:00.000Z","updated":"2020-10-06T11:15:40.729Z","comments":true,"path":"2019/08/17/centos-ftp/ftp-link/","link":"","permalink":"http://akashigakki.github.io/2019/08/17/centos-ftp/ftp-link/","excerpt":"云服务器 ftp 的搭建和使用 记录一下 CentOS 远程服务器上 ftp 的搭建和使用，实现上传和下载。","text":"云服务器 ftp 的搭建和使用 记录一下 CentOS 远程服务器上 ftp 的搭建和使用，实现上传和下载。 工作原理FTP 采用客户端/服务端的工作模式（C/S结构），通过 TCP 协议建立客户端和服务器之间的连接，但与其他大多数应用协议不同，FTP协议在客户端和服务端之间建立了两条通信链路，分别是控制链路和数据链路。 其中，控制链路负责 FTP 会话过程中 FTP 命令的发送和接收，数据链路则负责数据的传输。 FTP 会话包含了两个通道，控制通道和数据通道。 FTP 的工作有两种方式，一种是主动模式，一种是被动模式，以 FTPServer 为参照物，主动模式，服务器主动连接客户端传输，被动模式，等待客户端的的连接 。（无论是主动模式还是被动模式，首先的控制通道都是先建立起来的，只是在数据传输模式上的区别）。 环境准备vsftpd 是 linux 下的一款小巧轻快，安全易用的 FTP 服务器软件，首先我们需要安装它。 1yum install -y vsftpd 安装完成后进入文件查看： 1cd etc/vsftpd 相关配置文件： 主配置文件 /etc/vsftpd/vsftpd.conf 黑名单 /etc/vsftpd/ftpusers 里面的用户不允许访问 FTP 服务器 白名单 /etc/vsftpd/user_list 允许访问 FTP 服务器的用户列表 启动服务器 设置开机自启动 1systemctl enable vsftpd.service 启动 ftp 服务 1systemctl start vsftpd.service 查看 ftp 服务端口 1netstat -antup | grep ftp 开通服务器对应的 ftp 端口(21)，便可以使用 ftp 登录。 登录： 12345678# 连接到ftp服务器ftp 公网IP# 切换到pub目录cd pub/# 上传文件put etc/xxx/# 下载文件get xxx 配置 更改权限 更改 /var/ftp/pub 目录的权限，为 ftp 用户添加写权限，并重新加载配置文件 1234#更改/var/ftp/pub目录的权限chmod o+w /var/ftp/pub/ #重启ftp服务systemctl restart vsftpd.service 配置本地用户登录 本地用户登录就是指使用 Linux 操作系统中的用户账号和密码登录 ftp 服务器，vsftp 安装后默只支持匿名 ftp 登录，用户如果试图使用 Linux 操作系统中的账号登录服务器，将会被 vsftpd 拒绝 1234# 创建用户akashiuseradd akashi# 修改用户akashi的密码passwd akashi 回车后根据提示输入新密码完成创建。 修改 /etc/vsftpd/vsftpd.conf: 12anonymous enable=NOlocal_enable=YES 这样，就可以通过本地用户进行登录了。 一些参数说明 用户登陆控制 参数 说明 anonymous_enable=YES 接受匿名用户 no_anon_password=YES 匿名用户 login 时不询问口令 anon_root=(none) 匿名用户主目录 local_enable=YES 接受本地用户 local_root=(none) 本地用户主目录 用户权限控制 参数 说明 write_enable=YES 可以上传(全局控制) local_umask=022 本地用户上传文件的 umask file_open_mode=0666 上传文件的权限配合 umask 使用 anon_upload_enable=NO 匿名用户可以上传 anon_mkdir_write_enable=NO 匿名用户可以建目录 anon_other_write_enable=NO 匿名用户修改删除 chown_username=lightwiter 匿名上传文件所属用户名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/categories/Linux/"},{"name":"ftp","slug":"Linux/ftp","permalink":"http://akashigakki.github.io/categories/Linux/ftp/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/tags/Linux/"},{"name":"ftp","slug":"ftp","permalink":"http://akashigakki.github.io/tags/ftp/"},{"name":"远程连接","slug":"远程连接","permalink":"http://akashigakki.github.io/tags/远程连接/"}]},{"title":"CentOS 安装 Python3 环境","slug":"centos/centos","date":"2019-08-15T16:00:00.000Z","updated":"2020-10-06T11:15:40.729Z","comments":true,"path":"2019/08/16/centos/centos/","link":"","permalink":"http://akashigakki.github.io/2019/08/16/centos/centos/","excerpt":"CentOS 安装 Python3 环境 在云服务器下安装 Python3 环境，系统为 CentOS。","text":"CentOS 安装 Python3 环境 在云服务器下安装 Python3 环境，系统为 CentOS。 远程连接 通过 ssh 连接到远程服务器 1ssh -p 22 root@xx.xxx.xxx.xxx 连接到远程服务器，@后接服务器公网 IP 地址，回车后输入连接密码进行远程登录。 创建目录 CnetOS 默认安装了 Python2，可以通过 which python 找到它的安装位置。所以需要在开始前新建一个目录用于 Python3 的安装。 创建安装 Python3 环境目录 1sudo mkdir /usr/local/python3 源文件下载 下载源文件 1wget https://www.python.org/ftp/python/3.6.5/Python-3.7.4.tgz 解压缩包 1tar -xzvf Python-3.7.4.tgz 进入解压目录 1cd Python-3.7.4 编译安装 指定在创建的目录安装 1sudo ./configure --prefix=/usr/local/python3 编译安装 1sudo make &amp;&amp; sudo make install 至此，安装完成。在 /usr/local/python3 就可以看见 python3 的文件了。 设置软连接 为了区分 Python2 和 Python3，需要设置一个软连接让系统环境可以找到 Python3 并使用它。 软连接 python3: 1sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3 pip3: 1sudo ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 这样，两个版本就可以共存了，我们可以使用 python 来调用 python 环境，python3 来调用 python3 环境。 解决 yum Python 版本矛盾如果不幸出现了 yum 失效的情况，需要更改 yum 的配置文件和 urlgrabber-ext-down 文件，（使用以上方法安装一般不会出现失效的情况） 修改 yum 配置文件，将 python 版本指向以前的旧版本 1vim /usr/bin/yum 将第一行改成 #!/usr/bin/python2.7 修改 urlgrabber-ext-down 文件，更改 python 版本 1vim /usr/libexec/urlgrabber-ext-down 将第一行改成 #!/usr/bin/python2.7","categories":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/categories/Linux/"},{"name":"环境安装","slug":"Linux/环境安装","permalink":"http://akashigakki.github.io/categories/Linux/环境安装/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/tags/Linux/"},{"name":"环境安装","slug":"环境安装","permalink":"http://akashigakki.github.io/tags/环境安装/"}]},{"title":"Django Web 身份验证系统搭建（下）","slug":"django-web-2/learn-note-django-2","date":"2019-08-14T16:00:00.000Z","updated":"2020-10-06T11:15:40.731Z","comments":true,"path":"2019/08/15/django-web-2/learn-note-django-2/","link":"","permalink":"http://akashigakki.github.io/2019/08/15/django-web-2/learn-note-django-2/","excerpt":"Django Web 身份验证系统搭建（下） 接上一篇实现用户功能，完善数据库模型。","text":"Django Web 身份验证系统搭建（下） 接上一篇实现用户功能，完善数据库模型。 接上一节，这次我们需要创建一个新的应用程序，其中包含与处理用户账户相关的所有功能。还需要对模型稍加修改，让每个主题都归属于特定用户。 创建用户账户创建首先，使用 startapp 来创建一个名为 users 的应用程序： 1python3 manage.py startapp users 添加到 settings.py 中 这样，Django 将把应用程序 users 包含到项目中。 创建应用程序 users 的 URL首先，在项目层路由中(根目录的urls.py)设计 users 的 URL: 12345678from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('note/', include('learning_logs.urls')), path('users/', include('users.urls'))] 然后，新建应用层(users)的 urls.py，同样，在之后的页面路由中负责转发应用程序 users 的函数方法到视图层。 登录页面设计应用层的 URL1234567from django.urls import path, include# from django.contrib.auth.views import auth_loginfrom django.contrib.auth.views import LoginViewurlpatterns = [ path('login', LoginView.as_view(template_name='users/login.html')),] 注意，和之前不同的是，这一次我们没有设计视图层，而是将请求发送给 Django 的默认视图函数 LoginView，函数参数指明登录模板的位置。 模板在应用 users 下的路径建立模板： users =&gt; templates =&gt; users =&gt; login.html login.html: 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% if form.errors %&#125; &lt;p&gt;Your username and password didn't match. Please try again.&lt;/p&gt; &#123;% endif %&#125; &lt;form action=\"/users/login\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;button name=\"submit\"&gt;login&lt;/button&gt; &lt;input type=\"hidden\" name=\"next\" value=\"/note/index\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 链接到登录页面更改首页 index.html，链接到 login.html: 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; - &#123;% if user.is_authenticated %&#125; Hello, &#123;&#123; user.username &#125;&#125;. &#123;% else %&#125; &lt;a href=\"/users/login\"&gt;login&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;p&gt;Learning Log helps you keep track of your learning, for any topic you're learning about.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这时，可以使用管理员用户进行登录尝试，访问http://127.0.0.1:8000/users/login/ 进入登录页面。 注销现在需要提供一个让用户注销的途径，我们不用创建用于注销的页面，而是让用户单击一个链接完成注销并返回到主页。 为此，需要为链接定义一个 URL 模式，编写一个视图函数，并在首页 index.html 添加一个注销链接。 注销 URL12345678from django.urls import path, includefrom django.contrib.auth.views import LoginViewimport users.viewsurlpatterns = [ path('login', LoginView.as_view(template_name='users/login.html')), path('logout', users.views.logout_view)] 视图函数 logout_viewviews.py: 123456789from django.shortcuts import renderfrom django.http import HttpResponseRedirectfrom django.contrib.auth import logoutdef logout_view(request): \"\"\"注销用户\"\"\" logout(request) return HttpResponseRedirect('/note/index') 链接到注销视图在主页添加链接： index.html: 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; - &#123;% if user.is_authenticated %&#125; Hello, &#123;&#123; user.username &#125;&#125;. &#123;% else %&#125; &lt;a href=\"/users/login\"&gt;login&lt;/a&gt; &#123;% endif %&#125; &lt;a href=\"/users/logout\"&gt;logout&lt;/a&gt; &lt;/div&gt; &lt;p&gt;Learning Log helps you keep track of your learning, for any topic you're learning about.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注册页面 接下来就是创建一个让新用户可以注册的页面，我们使用 Django 提供的表单 UserCreationForm。 URL 模式123456789from django.urls import path, includefrom django.contrib.auth.views import LoginViewimport users.viewsurlpatterns = [ path('login', LoginView.as_view(template_name='users/login.html')), path('logout', users.views.logout_view), path('register', users.views.register)] 视图函数 register()views.py: 1234567891011121314151617181920212223242526from django.http import HttpResponseRedirectfrom django.contrib.auth import logout, login, authenticatefrom django.contrib.auth.forms import UserCreationFormdef register(request): \"\"\"注册新用户\"\"\" if request.method != 'POST': # 显示空的注册表单 form = UserCreationForm() else: # 处理填写好的表单 form = UserCreationForm(data=request.POST) if form.is_valid(): new_user = form.save() authenticate_user = authenticate( username=new_user.username, password=request.POST['password1'] ) login(request, authenticate_user) return HttpResponseRedirect('/note/index') context = &#123; 'form': form &#125; return render(request, 'users/register.html', context) 注册模板模板路径：users =&gt; templates =&gt; users =&gt; register.html register.html: 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Register&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; - &#123;% if user.is_authenticated %&#125; Hello, &#123;&#123; user.username &#125;&#125;. &lt;a href=\"/users/logout\"&gt;logout&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"/users/register\"&gt;register&lt;/a&gt; &lt;a href=\"/users/login\"&gt;login&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;form action=\"/users/register\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;button name=\"submit\"&gt;register&lt;/button&gt; &lt;input type=\"hidden\" name=\"next\" value=\"/note/index\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 链接到注册页面index.html: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; - &#123;% if user.is_authenticated %&#125; Hello, &#123;&#123; user.username &#125;&#125;. &lt;a href=\"/users/logout\"&gt;logout&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"/users/register\"&gt;register&lt;/a&gt; &lt;a href=\"/users/login\"&gt;login&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;p&gt;Learning Log helps you keep track of your learning, for any topic you're learning about.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 让用户拥有自己的数据 用户应该能够输入其专有的数据，因此我们将创建一个系统，确定各项数据所属的用户，再限制对页面的访问，让用户只能使用自己的数据。 我们需要修改模型 Topic，让每个主题都归属于特定用户。这也将影响条目，因为每个条目都属于特定的主题。 首先，限制对一些页面的访问。 使用 @login_required 限制访问 Django 提供了装饰器 @login_required，可以实现对于某些页面，只允许已经登录的用户访问它们。 限制对 topics 页面的访问 只允许已登录的用户请求 topics 页面： learning_logs/views.py: 123456789101112131415--snip--from django.contrib.auth.decorators import login_required--snip--def get_index_page(request): return render(request, 'learning_logs/index.html')@login_required()def get_topics_page(request): topics_list = Topic.objects.all() return render(request, 'learning_logs/topics.html', &#123; 'topics': topics_list &#125;)--snip-- login_required() 的代码检查用户是否已登录，仅当用户已登录时， Django 才会运行 get_topics_page() 的代码；如果用户未登录，就重定向到登录页面。 为实现这种重定向，我们需要修改 setting.py，让 Django 知道哪里去找登录页面： 在 setting.py 末尾添加: 1LOGIN_URL = '/users/login/' 全面限制对项目的访问 除主页(get_index_page()、注册页面(register())和注销页面(logout_view())，限制其他所有视图函数的页面访问。 将数据关联到用户现在，需要将数据关联到提交它们的用户。我们只需将最高层的数据关联到用户，这样更低层的数据会自动关联到用户。 下面来修改模型 Topic，在其中添加一个关联到用户的外键。这样以后，必须对数据库进行迁移，最后，对必要的视图进行修改，使其只显示与当前登录用户相关联的数据。 修改模型 toopic 只涉及两行： 1234567891011from django.db import modelsfrom django.contrib.auth.models import Userclass Topic(models.Model): text = models.CharField(max_length=200) date_added = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey(User, on_delete=models.CASCADE) def __str__(self): return self.text 导入模型 User，建立外键关系。 确定当前有哪些用户 迁移数据库 知道用户 ID 之后，就可以迁移数据库了。 1python3 manage.py makemigrations learning_logs 这里我们将既有的所有主题关联到了管理用户 akashi上（通过 ID），接下来使用这个值来迁移数据库： 1python3 manage.py migrate 只允许用户访问自己的主题当前，无论以哪一个用户身份登录，都可以看到所有的主题。现在，我们来改变这种情况，只向用户显示属于自己的主题。 在 views.py 中，对函数 get_topics_page() 做如下修改： 12345678@login_required()def get_topics_page(request): \"\"\"显示主题\"\"\" topics = Topic.objects.filter(owner=request.user).order_by('date_added') context = &#123; 'topics': topics &#125; return render(request, 'learning_logs/topics.html', context) 保护用户的主题现在，我们还没有对显示单个主题的页面访问进行限制，可以通过 URL 对不是当前用户的主题进行查看。 为修复这种问题，我们在视图函数 get_entry_page() 获取请求的条目前进行检查： 1234567891011121314from django.http import HttpResponseRedirect, Http404@login_required()def get_entry_page(request, topic_id): topic = Topic.objects.get(id=topic_id) # 确认请求的主题属于当前用户 if topic.owner != request.user: raise Http404 entries = topic.entry_set.order_by('-date_added') context = &#123; 'topic': topic, 'entries': entries &#125; return render(request, 'learning_logs/topic.html', context) 保护页面 edit_entry使用同样的方法，禁止用户通过 URL 来访问其他用户的条目： 12345678910111213141516171819202122232425@login_required()def edit_entry(request, entry_id): \"\"\"编辑既有条目\"\"\" entry = Entry.objects.get(id=entry_id) topic = entry.topic if topic.owner != request.user: raise Http404 if request.method != 'POST': # 初次请求，使用当前条目填充表单 form = EntryForm(instance=entry) else: # post提交的数据，对数据进行处理 form = EntryForm(instance=entry, data=request.POST) if form.is_valid(): form.save() return HttpResponseRedirect(('/note/topics/' + str(topic.id))) context = &#123; 'entry': entry, 'topic': topic, 'form': form &#125; return render(request, 'learning_logs/edit_entry.html', context) 将新主题关联到当前用户当前，用于添加新主题的页面存在问题，因为它没有将新主题关联到特定的用户。 以下修复问题： 1234567891011121314151617181920@login_required()def new_topic(request): \"\"\"添加新主题\"\"\" if request.method != 'POST': # 未提交数据：创建一个新表单 form = TopicForm() else: # POST提交的数据，对数据进行处理 form = TopicForm(request.POST) if form.is_valid(): new_topic = form.save(commit=False) new_topic.owner = request.user new_topic.save() # form.save() return HttpResponseRedirect('/note/topics') context = &#123; 'form': form &#125; return render(request, 'learning_logs/new_topic.html', context) 设置项目样式第三方应用程序 django-bootstrap3我们使用 django-bootstrap3 来将 Bootstrap 继承到项目中。这个应用程序下载必要的 Bootstrap 文件，将它们存放到项目的合适位置，让我们可以在项目的模板中使用样式设置指令。 为安装 django-bootstrap3，在活动的虚拟环境中执行如下命令： 1pip3 install django-bootstrap3 接下来，需要在 settings.py 中的 INSTALLED_APPS 中添加如下代码，在项目中包含应用程序 django-bootstrap3： 123456789101112131415161718INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'bootstrap3', 'learning_logs', 'users']# django-bootstrap3的设置BOOTSTRAP3 = &#123; 'include_jquery': True&#125; 主页样式 index 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Index&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default navbar-static-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\" &gt;&lt;/button&gt; &lt;a href=\"/note/index\" class=\"navbar-brand\"&gt;Learning Log&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;Hello, &#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/logout\"&gt;log out&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/users/register\"&gt;register&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/login\"&gt;log in&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Track Your Learning.&lt;/h1&gt; &lt;p&gt;Learning Log helps you keep track of your learning, for any topic you're learning about.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;h3&gt; &lt;a href=\"/users/register\"&gt;Register an account&lt;/a&gt; to make your own Learning Log, and list the topics you're learning about. &lt;/h3&gt; &lt;h3&gt;Whenever you learn something new about a topic, make an entry summarizing what you're learned.&lt;/h3&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 话题页样式 topics 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topics&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default navbar-static-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\" &gt;&lt;/button&gt; &lt;a href=\"/note/index\" class=\"navbar-brand\"&gt;Learning Log&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;Hello, &#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/logout\"&gt;log out&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/users/register\"&gt;register&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/login\"&gt;log in&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt;Topics&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;ul&gt; &#123;% for topic in topics %&#125; &lt;li&gt; &lt;h3&gt;&lt;a href=\"/note/topics/&#123;&#123; topic.id &#125;&#125;\"&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt;&lt;/h3&gt; &lt;/li&gt; &#123;% empty %&#125; &lt;li&gt;No topics have been added yet.&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;h3&gt;&lt;a href=\"/note/new_topic\"&gt;Add new topic&lt;/a&gt;&lt;/h3&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 条目页样式 topic 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topic&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default navbar-static-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\" &gt;&lt;/button&gt; &lt;a href=\"/note/index\" class=\"navbar-brand\"&gt;Learning Log&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;Hello, &#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/logout\"&gt;log out&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/users/register\"&gt;register&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/login\"&gt;log in&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h2&gt;Topic: &#123;&#123; topic &#125;&#125;&lt;/h2&gt; &lt;small&gt;Entries:&lt;/small&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;p&gt;&lt;a href=\"/note/new_entry/&#123;&#123; topic.id &#125;&#125;\"&gt;Add new entry&lt;/a&gt;&lt;/p&gt; &#123;% for entry in entries %&#125; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3&gt; &#123;&#123; entry.date_added | date:'M d, Y H:i' &#125;&#125; &lt;small&gt;&lt;a href=\"/note/edit_entry/&#123;&#123; entry.id &#125;&#125;\"&gt;Edit entry&lt;/a&gt;&lt;/small&gt; &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;&#123; entry.text | linebreaks &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% empty %&#125; &lt;li&gt;There are no entries for this topic yet.&lt;/li&gt; &#123;% endfor %&#125;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 新建话题 new_topic 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;New_Topic&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default navbar-static-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\" &gt;&lt;/button&gt; &lt;a href=\"/note/index\" class=\"navbar-brand\"&gt;Learning Log&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;Hello, &#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/logout\"&gt;log out&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/users/register\"&gt;register&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/login\"&gt;log in&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-herder\"&gt; &lt;h2&gt;Add a new topic:&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;form action=\"/note/new_topic\" method=\"post\" class=\"form\"&gt; &#123;% csrf_token %&#125; &#123;% bootstrap_form form %&#125; &#123;% buttons %&#125; &lt;button name=\"submit\" class=\"btn btn-primary\"&gt;add topic&lt;/button&gt; &#123;% endbuttons %&#125; &lt;/form&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 新建条目 new_entry 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;New_Entry&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default navbar-static-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\" &gt;&lt;/button&gt; &lt;a href=\"/note/index\" class=\"navbar-brand\"&gt;Learning Log&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;Hello, &#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/logout\"&gt;log out&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/users/register\"&gt;register&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/login\"&gt;log in&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-herder\"&gt; &lt;h2&gt;Add a new entry:&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;form action=\"/note/new_entry/&#123;&#123; topic.id &#125;&#125;\" method=\"post\" class=\"form\"&gt; &#123;% csrf_token %&#125; &#123;% bootstrap_form form %&#125; &#123;% buttons %&#125; &lt;button name=\"submit\" class=\"btn btn-primary\"&gt;add entry&lt;/button&gt; &#123;% endbuttons %&#125; &lt;/form&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 编辑条目 edit_entry 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Edit_Entry&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default navbar-static-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\" &gt;&lt;/button&gt; &lt;a href=\"/note/index\" class=\"navbar-brand\"&gt;Learning Log&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;Hello, &#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/logout\"&gt;log out&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/users/register\"&gt;register&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/users/login\"&gt;log in&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-herder\"&gt; &lt;h2&gt;Edit entry:&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;form action=\"/note/edit_entry/&#123;&#123; entry.id &#125;&#125;\" method=\"post\" class=\"form\"&gt; &#123;% csrf_token %&#125; &#123;% bootstrap_form form %&#125; &#123;% buttons %&#125; &lt;button name=\"submit\" class=\"btn btn-primary\"&gt;save changes&lt;/button&gt; &#123;% endbuttons %&#125; &lt;/form&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 注册 register 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Register&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h2&gt;Register an account.&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;form action=\"/users/register\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;% bootstrap_form form %&#125; &#123;% buttons %&#125; &lt;button name=\"submit\" class=\"btn btn-primary\"&gt;register&lt;/button&gt; &#123;% endbuttons %&#125; &lt;input type=\"hidden\" name=\"next\" value=\"/note/index\"&gt; &lt;/form&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 登录 login 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123;% load bootstrap3 %&#125;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Login&lt;/title&gt; &#123;% bootstrap_css %&#125; &#123;% bootstrap_javascript %&#125; &lt;style&gt; body &#123; font-family: \"plantc\", \"Source Han Serif\", serif; font-weight: bolder; text-decoration: none; &#125; footer &#123; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h2&gt;Log in to your account.&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;form action=\"/users/login\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;% bootstrap_form form %&#125; &#123;% buttons %&#125; &lt;button name=\"submit\" class=\"btn btn-primary\"&gt;log in&lt;/button&gt; &#123;% endbuttons %&#125; &lt;input type=\"hidden\" name=\"next\" value=\"/note/index\"&gt; &lt;/form&gt;&lt;/div&gt;&lt;footer class=\"footer\"&gt; &lt;h4&gt;Copyright &amp;copy; 2019 Akashi_Sai. All Rights Reserved.&lt;/h4&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://akashigakki.github.io/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://akashigakki.github.io/tags/Django/"},{"name":"项目部署","slug":"项目部署","permalink":"http://akashigakki.github.io/tags/项目部署/"}]},{"title":"Django Web 身份验证系统搭建（上）","slug":"django-web-1/learn-note-django-1","date":"2019-08-13T16:00:00.000Z","updated":"2020-10-06T11:15:40.730Z","comments":true,"path":"2019/08/14/django-web-1/learn-note-django-1/","link":"","permalink":"http://akashigakki.github.io/2019/08/14/django-web-1/learn-note-django-1/","excerpt":"Django Web 身份验证系统搭建上） 使用 Django 搭建一个用户注册和身份验证系统，最终实现多用户注册使用的便签系统。","text":"Django Web 身份验证系统搭建上） 使用 Django 搭建一个用户注册和身份验证系统，最终实现多用户注册使用的便签系统。 建立虚拟环境首先，为新项目建立一个目录，命名为 learning_log，进入目录并开始虚拟环境的搭建。 建立虚拟环境1mkvirtualenv -p python3 ll_env 激活虚拟环境1workon ll_env 安装 Django这里使用豆瓣源： 1pip3 install django -i https://pypi.douban.com/simple 在 Django 中创建项目1django-admin startproject learning_log . 使用命令新建一个 Django 项目，名为 learning_log，末尾的句点(.)让新项目使用合适的目录结构，这样开发完成之后可轻松地将应用程序部署到服务器上。 千万不要忘了句点，否则部署应用程序时会出现一些配置问题。 创建数据库1python3 manage.py migrate 启动项目1python3 manage.py runserver 创建应用程序保持项目启动的终端运行，重新打开一个终端，进入原项目目录，激活虚拟环境，创建应用程序： 首先，进入自己的项目目录再激活虚拟环境 12workon ll_envpython3 manage.py startapp learning_logs 定义模型使用 pycharm 打开项目，在应用中打开 models.py 定义模型： 123456789from django.db import modelsclass Topic(models.Model): text = models.CharField(max_length=200) date_added = models.DateTimeField(auto_now_add=True) def __str__(self): return self.text 激活模型在 settings.py 中添加程序： 修改数据库 修改数据库在 Django 中也称为迁移数据库，使用以下命令完成： 1python3 manage.py makemigrations learning_logs 执行迁移文件同步变更到数据库 1python3 manage.py migrate Admin 模块管理创建超级用户1python3 manage.py createsuperuser Username: akashiPassword: akashiadmin123 这里只是一个示例，可以自定义。 注册模型在应用程序下的 admin.py 进行注册： 123from learning_logs.models import Topicadmin.site.register(Topic) 打开管理页(http://127.0.0.1:8000/admin/)，尝试添加一些主题： Chess、RockClimbin 定义模型 Entry这时，我们希望可以在学习笔记中添加定义条目的笔记记录，每个条目都与特定的主题相关联，这种关系被称为多对一关系，即多个条目可以关联到同一个主题。 我们再添加模型 Entry: 12345678910class Entry(models.Model): topic = models.ForeignKey(Topic, on_delete=models.CASCADE) text = models.TextField() date_added = models.DateTimeField(auto_now_add=True) class Meta: verbose_name_plural = 'entries' def __str__(self): return self.text[:50] + \"...\" 这里我们在 Entry 类中嵌套了 Meta 类， Meta 存储用于管理模型的额外信息，我们让它能够设置一个特殊属性，让 Django 在需要时使用 Entries 来表示多个条目。如果没有这个类， Django 将使用 Entrys 来表示多个条目。 迁移模型 Entry12python3 manage.py makemigrations learning_logspython3 manage.py migrate 注册模型12345from django.contrib import adminfrom learning_logs.models import Topic, Entryadmin.site.register(Topic)admin.site.register(Entry) 同样，完成后添加一些记录在数据库中。 创建网页使用 Django 创建网页一般分为三个阶段： 定义URL、编写视图和编写模板。 映射 URL首先，确定页面的存放路径：learning_logs =&gt; templates =&gt; learning_logs =&gt; index.html 根据路径，将项目层的 urls.py 路由到应用层： 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('note/', include('learning_logs.urls'))] 在应用层新建 urls.py，然后路由到对应的方法： 12345678from django.urls import path, includeimport learning_logs.viewsurlpatterns = [ path('index', learning_logs.views.get_index_page)] 编写视图views.py: 12345from django.shortcuts import renderdef get_index_page(request): return render(request, 'learning_logs/index.html') 编写模板index.html: 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Learning Log&lt;/p&gt; &lt;p&gt;Learning Log helps you keep track of your learning, for any topic you're learning about.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这样，通过http://127.0.0.1:8000/note/index便可以访问。 创建其他网页同样，确定页面存放路径：learning_logs =&gt; templates =&gt; learning_logs =&gt; topics.html 映射 URL项目层路由使用同一个，无需添加。 下面设计应用层路由： 1234567from django.urls import path, includeimport learning_logs.viewsurlpatterns = [ path('index', learning_logs.views.get_index_page), path('topics', learning_logs.views.get_topics_page)] 实现视图层views.py: 12345def get_topics_page(request): topics_list = Topic.objects.all() return render(request, 'learning_logs/topics.html', &#123; 'topics': topics_list &#125;) 实现模板topic.html: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topics&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Topics&lt;/p&gt; &lt;ul&gt; &#123;% for topic in topics %&#125; &lt;li&gt;&#123;&#123; topic &#125;&#125;&lt;/li&gt; &#123;% empty %&#125; &lt;li&gt;No topics have been added yet.&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现特定主题的页面 路由 learning_logs =&gt; templates =&gt; learning_logs =&gt; topic.html 12345678from django.urls import path, includeimport learning_logs.viewsurlpatterns = [ path('index', learning_logs.views.get_index_page), path('topics', learning_logs.views.get_topics_page), path('topics/&lt;int:topic_id&gt;', learning_logs.views.get_entry_page)] 视图方法 12345678ef get_entry_page(request, topic_id): topic = Topic.objects.get(id=topic_id) entries = topic.entry_set.order_by('-date_added') context = &#123; 'topic': topic, 'entries': entries &#125; return render(request, 'learning_logs/topic.html', context) 模板 topics.html: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topics&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Topics&lt;/p&gt; &lt;ul&gt; &#123;% for topic in topics %&#125; &lt;li&gt;&lt;a href=\"/note/topics/&#123;&#123; topic.id &#125;&#125;\"&gt;&#123;&#123; topic &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% empty %&#125; &lt;li&gt;No topics have been added yet.&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; topic.html: 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topics&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Topic: &#123;&#123; topic &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Entries:&lt;/p&gt; &lt;ul&gt; &#123;% for entry in entries %&#125; &lt;li&gt; &lt;p&gt;&#123;&#123; entry.date_added &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; entry.text &#125;&#125;&lt;/p&gt; &lt;/li&gt; &#123;% empty %&#125; &lt;li&gt;There are no entries for this topic yet.&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用户添加新主题导入表单模块123456789101112from django import formsfrom .models import Topicclass TopicForm(forms.ModelForm): class Meta: model = Topic fields = ['text'] labels = &#123; 'text': '' &#125; URL 设计123456789from django.urls import path, includeimport learning_logs.viewsurlpatterns = [ path('index', learning_logs.views.get_index_page), path('topics', learning_logs.views.get_topics_page), path('topics/&lt;int:topic_id&gt;', learning_logs.views.get_entry_page), path('new_topic', learning_logs.views.new_topic)] 视图函数123456789101112131415161718192021from django.http import HttpResponseRedirectfrom .forms import TopicFormdef new_topic(request): \"\"\"添加新主题\"\"\" if request.method != 'POST': # 未提交数据：创建一个新表单 form = TopicForm() else: # POST提交的数据，对数据进行处理 form = TopicForm(request.POST) if form.is_valid(): form.save() return HttpResponseRedirect('/note/topics') context = &#123; 'form': form &#125; return render(request, 'learning_logs/new_topic.html', context) 模板new_topic.html: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topics&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Add a new topic:&lt;/p&gt; &lt;/div&gt; &lt;form action=\"/note/new_topic\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;button name=\"submit\"&gt;add topic&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在 topics.html 添加链接: 123&lt;div&gt; &lt;a href=\"/note/new_topic\"&gt;Add a new topic&lt;/a&gt;&lt;/div&gt; 用户添加新条目添加新条目表单123456789101112131415from .models import Topic, Entryclass EntryForm(forms.ModelForm): class Meta: model = Entry fields = ['text'] labels = &#123; 'text': '' &#125; widgets = &#123; 'text': forms.Textarea(attrs=&#123; 'cols': 80 &#125;) &#125; URL 设计12345678910from django.urls import path, includeimport learning_logs.viewsurlpatterns = [ path('index', learning_logs.views.get_index_page), path('topics', learning_logs.views.get_topics_page), path('topics/&lt;int:topic_id&gt;', learning_logs.views.get_entry_page), path('new_topic', learning_logs.views.new_topic), path('new_entry/&lt;int:topic_id&gt;', learning_logs.views.new_entry)] 视图函数1234567891011121314151617181920from .forms import TopicForm, EntryFormdef new_entry(request, topic_id): \"\"\"在特定的主题下添加新条目\"\"\" topic = Topic.objects.get(id=topic_id) if request.method != 'POST': form = EntryForm() else: form = EntryForm(data=request.POST) if form.is_valid(): new_entry = form.save(commit=False) new_entry.topic = topic new_entry.save() return HttpResponseRedirect(('/note/topics/' + str(topic_id))) context = &#123; 'topic': topic, 'form': form &#125; return render(request, 'learning_logs/new_entry.html', context) 模板new_entry: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topics&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Add a new entry:&lt;/p&gt; &lt;/div&gt; &lt;form action=\"/note/new_entry/&#123;&#123; topic.id &#125;&#125;\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;button name=\"submit\"&gt;add entry&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; topic.html: 添加链接： 1234... &lt;div&gt; &lt;a href=\"/note/new_entry/&#123;&#123; topic.id &#125;&#125;\"&gt;Add a new entry&lt;/a&gt;&lt;/div&gt; 编辑条目URL 设计1234567891011from django.urls import path, includeimport learning_logs.viewsurlpatterns = [ path('index', learning_logs.views.get_index_page), path('topics', learning_logs.views.get_topics_page), path('topics/&lt;int:topic_id&gt;', learning_logs.views.get_entry_page), path('new_topic', learning_logs.views.new_topic), path('new_entry/&lt;int:topic_id&gt;', learning_logs.views.new_entry), path('edit_entry/&lt;int:entry_id&gt;', learning_logs.views.edit_entry)] 视图函数1234567891011121314151617181920212223from learning_logs.models import Topic, Entrydef edit_entry(request, entry_id): \"\"\"编辑既有条目\"\"\" entry = Entry.objects.get(id=entry_id) topic = entry.topic if request.method != 'POST': # 初次请求，使用当前条目填充表单 form = EntryForm(instance=entry) else: # post提交的数据，对数据进行处理 form = EntryForm(instance=entry, data=request.POST) if form.is_valid(): form.save() return HttpResponseRedirect(('/note/topics/' + str(topic.id))) context = &#123; 'entry': entry, 'topic': topic, 'form': form &#125; return render(request, 'learning_logs/edit_entry.html', context) 模板edit_entry.html: 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Edit_Entry&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/topics/&#123;&#123; topic.id &#125;&#125;\"&gt;Topic - &#123;&#123; topic &#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Edit entry:&lt;/p&gt; &lt;/div&gt; &lt;form action=\"/note/edit_entry/&#123;&#123; entry.id &#125;&#125;\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;button name=\"submit\"&gt;save changes&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; topic.html: 链接到页面 edit_entry: 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Topic&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"/note/index\"&gt;Learning Log&lt;/a&gt; - &lt;a href=\"/note/topics\"&gt;Topics&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Topic: &#123;&#123; topic &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;Entries:&lt;/p&gt; &lt;ul&gt; &#123;% for entry in entries %&#125; &lt;li&gt; &lt;p&gt;&#123;&#123; entry.date_added &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; entry.text &#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;a href=\"/note/edit_entry/&#123;&#123; entry.id &#125;&#125;\"&gt;Edit entry&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &#123;% empty %&#125; &lt;li&gt;There are no entries for this topic yet.&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=\"/note/new_entry/&#123;&#123; topic.id &#125;&#125;\"&gt;Add a new entry&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 至此，项目已经具备了需要的大部分功能。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://akashigakki.github.io/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://akashigakki.github.io/tags/Django/"},{"name":"项目部署","slug":"项目部署","permalink":"http://akashigakki.github.io/tags/项目部署/"}]},{"title":"Vuejs 整理笔记","slug":"vuejs/vue","date":"2019-08-12T16:00:00.000Z","updated":"2020-10-06T11:15:40.927Z","comments":true,"path":"2019/08/13/vuejs/vue/","link":"","permalink":"http://akashigakki.github.io/2019/08/13/vuejs/vue/","excerpt":"Vue.js 整理笔记 Vue.js 是一套用于构建用户界面的轻量级的MVVM渐进式前端框架，通过简单的 API 提供高效的数据绑定和灵活的组件系统。","text":"Vue.js 整理笔记 Vue.js 是一套用于构建用户界面的轻量级的MVVM渐进式前端框架，通过简单的 API 提供高效的数据绑定和灵活的组件系统。 基础语法创建第一个 Vue 实例1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue.js&lt;/title&gt; &lt;!-- 在head中引入Vue.js的支持 --&gt; &lt;script src=\"./vue.js\"&gt;&lt;/script&gt; &lt;!-- 也可以引用CDN库 --&gt; &lt;!-- &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.22/dist/vue.js\"&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; //双括号绑定数据 &lt;div id=\"root\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;script&gt; // 创建一个Vue实例并作数据绑定 new Vue(&#123; el: '#root', data: &#123; msg: 'Hello Vue!' &#125; &#125;) // 原生JS写法 // var dom = document.getElementById(\"root\"); // dom.innerHTML = \"HELLO!\"; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; el：是 element 的缩写，指要操作或绑定的元素 data：写需要操作改变的内容。 注意：学 javascript 时，很多时候都是操作 DOM 的模式，而 vue 则更多是操作数据的双向绑定。 挂载点、模板与实例 挂载点： 需要操作的元素。例如：&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 并在实例中通过 el: &#39;#app&#39; 进行数据的双向绑定。 Vue只会去处理挂载点下的内容。 模板： 挂载点内部的内容我们把它叫做模板内容。也可以将模板在实例中编写，不过渲染时要加上 H5 标签例如： 1234567891011&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#root', template: '&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;h1&gt;', data: &#123; msg: 'Hello Vue!' &#125; &#125;)&lt;/script&gt; Vue 实例： 自动根据 el，template，data 数据生成最终的效果。最后放在挂载点之中。 Vue 实例中的数据、事件和方法 插值法: 插值表达式 双大括号 指令 v-text 和 v-html 监听事件指令 v-on 属性绑定指令 v-bind 表单输入绑定指令 v-model 计算属性 条件渲染：v-if 和 v-show v-text: 12345678910111213&lt;div id=\"root\"&gt; &lt;div v-text=\"content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#root', data: &#123; msg: 'Hello Vue!', content: '&lt;h2&gt;HEOOL!!!&lt;/h2&gt;' &#125; &#125;) &lt;/script&gt; 输出：&lt;h2&gt;HEOOL!!!&lt;/h2&gt; v-html: 123456789101112&lt;div id=\"root2\"&gt; &lt;div v-html=\"content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app2 = new Vue(&#123; el: '#root2', data: &#123; content: '&lt;h2&gt;Hello!!!&lt;/h2&gt;' &#125; &#125;) &lt;/script&gt; v-on:监听事件 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;!-- v-on:click绑定点击事件 --&gt; &lt;div v-on:click='handleClick'&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; content: 'Hello', &#125;, // 执行方法 methods: &#123; handleClick: function() &#123; // 通过操作实例里面的数据，Vue会自动更新。不需要操作DOM this.content = 'Vue!' &#125; &#125; &#125;) &lt;/script&gt; v-on:可以简写为@，即v-on:click等价于@click Vue 中的属性绑定和双向数据绑定 v-bind：属性绑定 123456789101112&lt;div id=\"app2\"&gt; &lt;div v-bind:title='title'&gt;HELLO WORLD!&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app2 = new Vue(&#123; el: '#app2', data: &#123; title: 'This is hello world' &#125; &#125;) &lt;/script&gt; v-bind:可以简写为：，即v-bind:title等价于:title v-model：双向数据绑定 12345678910111213&lt;div id=\"app3\"&gt; &lt;input type=\"text\" v-model='content'&gt; &lt;div v-text='content'&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app3 = new Vue(&#123; el: '#app3', data: &#123; content: 'This is content' &#125; &#125;) &lt;/script&gt; 当 input 框中的数据改变，div 中 content 的内容也会相应的发生改变。 Vue 中的计算属性和侦听器 计算属性： 1234567891011121314151617181920&lt;div id=\"app4\"&gt; 姓：&lt;input type=\"text\" v-model='firstName'&gt; 名：&lt;input type=\"text\" v-model='lastName'&gt; &lt;div&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app4 = new Vue(&#123; el: '#app4', data: &#123; firstName: '', lastName: '' &#125;, computed: &#123; fullName: function() &#123; return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt; 侦听器： 1234567891011121314151617181920212223242526272829303132&lt;div id=\"app4\"&gt; 姓：&lt;input type=\"text\" v-model='firstName'&gt; 名：&lt;input type=\"text\" v-model='lastName'&gt; &lt;div&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app4 = new Vue(&#123; el: '#app4', data: &#123; firstName: '', lastName: '', count: 0 &#125;, // 计算属性 computed: &#123; fullName: function() &#123; return this.firstName + ' ' + this.lastName &#125; &#125;, // 侦听器 watch: &#123; firstName: function() &#123; this.count++ &#125;, lastName: function() &#123; this.count++ &#125; &#125; &#125;) &lt;/script&gt; v-if、v-show 和 v-for 指令 v-if：控制 DOM 存在与否 123456789101112131415161718&lt;div id=\"app5\"&gt; &lt;div v-if='show'&gt;Hello&lt;/div&gt; &lt;button @click='handleClick'&gt;Toggle&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app5 = new Vue(&#123; el: '#app5', data: &#123; show: true &#125;, methods: &#123; handleClick: function() &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt; v-show：控制 DOM 的显示与否 123456789101112131415161718&lt;div id=\"app5\"&gt; &lt;div v-show='show'&gt;Hello&lt;/div&gt; &lt;button @click='handleClick'&gt;Toggle&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app5 = new Vue(&#123; el: '#app5', data: &#123; show: true &#125;, methods: &#123; handleClick: function() &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt; 区别：v-if 是直接将 div 在 DOM 中移除；而 v-show 是通过 display：none 来达到隐藏，DOM 结构依然存在。 v-for：循环显示 123456789101112131415161718192021222324252627&lt;div id=\"app5\"&gt; &lt;div v-show='show'&gt;Hello&lt;/div&gt; &lt;button @click='handleClick'&gt;Toggle&lt;/button&gt; &lt;ul&gt; &lt;!-- 方法一 --&gt; &lt;!-- &lt;li v-for='item in list' v-text='item'&gt;&lt;/li&gt; --&gt; &lt;!-- 方法二 --&gt; &lt;li v-for='(item, index) of list' :key='index'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app5 = new Vue(&#123; el: '#app5', data: &#123; show: true, list: [ 1, 2, 3 ] &#125;, methods: &#123; handleClick: function() &#123; this.show = !this.show; &#125; &#125; &#125;) &lt;/script&gt; Vue 中的组件 使用 Vue 中的组件开发一个 TodoList todolist 功能开发Add: 123456789101112131415161718192021222324&lt;!-- TodoList --&gt;&lt;div id=\"app6\"&gt; &lt;input v-model='inputValue'&gt; &lt;button @click='handleSubmit'&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;li v-for='item in list'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app6', data: &#123; inputValue: 'TODO', list: [] &#125;, methods: &#123; handleSubmit: function() &#123; this.list.push(this.inputValue); this.inputValue = '' &#125; &#125; &#125;)&lt;/script&gt; TodoList 中组件的拆分 全局组件： 1234567891011 ... &lt;ul&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ul&gt; ...&lt;script&gt; // 创建全局组件 Vue.components('todo-item', &#123; template: '&lt;li&gt;item&lt;/li&gt;' &#125;)&lt;/script&gt; 局部组件： 1234567891011121314151617181920212223242526272829&lt;script&gt; // 创建全局组件 // Vue.components('todo-item', &#123; // template: '&lt;li&gt;item&lt;/li&gt;' // &#125;) // 局部组件 var TodoItem = &#123; template: '&lt;li&gt;item&lt;/li&gt;' &#125; new Vue(&#123; el: '#app6', // 声明（注册）局部组件 components: &#123; 'todo-item' : TodoItem &#125;, data: &#123; inputValue: 'TODO', list: [] &#125;, methods: &#123; handleSubmit: function() &#123; this.list.push(this.inputValue); this.inputValue = '' &#125; &#125; &#125;)&lt;/script&gt; 父组件向子组件传参 123456789101112131415161718192021222324252627282930313233343536&lt;!-- TodoList --&gt;&lt;div id=\"app6\"&gt; &lt;input v-model='inputValue'&gt; &lt;button @click='handleSubmit'&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-item v-for='(item, index) of list' :key='index' :content='item' &gt;&lt;/todo-item&gt; &lt;!-- 以属性形式传参:content --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; // 创建全局组件 Vue.component('todo-item', &#123; // 子组件接收父组件传进来的参数 props: ['content'], template: '&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;' &#125;) new Vue(&#123; el: '#app6', data: &#123; inputValue: 'TODO', list: [] &#125;, methods: &#123; handleSubmit: function() &#123; this.list.push(this.inputValue); this.inputValue = '' &#125; &#125; &#125;)&lt;/script&gt; 实现TosoList的删除功能 子组件向父组件通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- TodoList --&gt;&lt;div id=\"app6\"&gt; &lt;input v-model='inputValue'&gt; &lt;button @click='handleSubmit'&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-item v-for='(item, index) of list' :key='index' :content='item' :index='index' @delete='handleDlete' &gt;&lt;/todo-item&gt; &lt;!-- 以属性形式传参:content --&gt; &lt;!-- 父组件监听子组件delete事件，并执行handleDlete方法 --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; // 创建全局组件 Vue.component('todo-item', &#123; // 子组件接收父组件传进来的参数 props: ['content', 'index'], template: '&lt;li @click=\"handleClick\"&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;', methods: &#123; handleClick: function() &#123; // 发布订阅模式，子组件发布事件，父组件订阅方法 this.$emit('delete', this.index); // 调用$emit方法，触发一个delete自定义事件传入index值 &#125; &#125; &#125;) new Vue(&#123; el: '#app6', data: &#123; inputValue: 'TODO', list: [] &#125;, methods: &#123; handleSubmit: function() &#123; this.list.push(this.inputValue); this.inputValue = '' &#125;, handleDlete: function(index) &#123; // 实现删除功能 this.list.splice(index, 1); &#125; &#125; &#125;)&lt;/script&gt; Vue-cli（脚手架工具）的使用脚手架的使用 在考虑到在大型项目中的可维护性，真实的 Vue 项目开发过程中，我们会借助 Webpack 的打包工具，帮助构建大型项目的开发目录。Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。 安装 node 和 npm 环境 官网https://nodejs.org/en/download/下载安装 node，npm 会附带安装 终端node -v,npm -v查看是否成功，打印出版本号则为安装成功。 安装使用淘宝 npm 镜像，加快访问速度 官网http://npm.taobao.org/ 终端命令行输入npm install -g cnpm --registry=https://registry.npm.taobao.org 之后的 npm 命令可以用 cnpm 进行替换，速度上会快一点 在终端进行全局安装 Vue-cli 1npm install -g vue-cli 创建一个基于Webpack模板的新项目 1vue init webpack my-project 涉及项目名、项目描述、作者默认可随意，项目构建选 Runtime + Compiler、是否安装 vue-router视情况而定、代码检查工具ESLint、单元测试工具暂时可以选NO、然后选择 npm 安装 进入项目，安装依赖 123cd my-projectcnpm install cnpm run dev 组件化开发 TodoList main.js： 1234567891011import Vue from 'vue'import TodoList from './TodoList'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', components: &#123; TodoList &#125;, template: '&lt;TodoList/&gt;'&#125;) TodoList.vue： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1 class=\"title\"&gt;Todo Something&lt;/h1&gt; &lt;input v-model=\"inputValue\" @keyup.enter=\"handleSubmit\"&gt; &lt;button @click=\"handleSubmit\"&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-item v-for=\"(item, index) of list\" :key=\"index\" :content=\"item\" :index=\"index\" @delete=\"handleDelete\" &gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TodoItem from './components/TodoItem'export default &#123; name: 'App', components: &#123; 'todo-item': TodoItem &#125;, data () &#123; return &#123; inputValue: '', list: [] &#125; &#125;, methods: &#123; handleSubmit: function() &#123; if (this.inputValue) &#123; this.list.push(this.inputValue); this.inputValue = '' &#125; &#125;, handleDelete: function(index) &#123; this.list.splice(index, 1); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;.title &#123; color: #42b983;&#125;button &#123; background: #42b983;&#125;&lt;/style&gt; components.TodoItem.vue: 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=\"todoitem\"&gt; &lt;li @click=\"handleDelete\"&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['content', 'index'], methods: &#123; handleDelete: function () &#123; this.$emit('delete', this.index) &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 至此，已经将原项目改为组件化的形式。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"},{"name":"前端框架","slug":"前端框架","permalink":"http://akashigakki.github.io/tags/前端框架/"}]},{"title":"Django 项目搭建及分页功能实现","slug":"django-page/django","date":"2019-08-11T16:00:00.000Z","updated":"2020-10-06T11:15:40.730Z","comments":true,"path":"2019/08/12/django-page/django/","link":"","permalink":"http://akashigakki.github.io/2019/08/12/django-page/django/","excerpt":"Django 项目搭建及分页功能实现 利用 Django 框架实现一个简易 Web Blog","text":"Django 项目搭建及分页功能实现 利用 Django 框架实现一个简易 Web Blog Django 安装 安装 1pip3 install django 确认安装成功： 1django-admin 出现提示信息，则安装成功。 或 1python3 -m django --version 输出正确版本信息，则证明安装成功。 项目搭建Django 项目 初始化项目 1django-admin startproject django_introduction 运行项目 1python3 manage.py runserver 可以通过终端提示 http://127.0.0.1:8000/ 进行访问： 项目目录 settings.py 项目配置文件 BASE_DIR 项目根目录 SECRET_KEY 安全码，项目自动生成 DEBUG 调试，true 和 false 可选 ALLOWED_HOSTS 配置允许的地址 INSTALLED_APPS 已安装应用，自己创建的应用需要在这里配置 MIDDLEWARE 中间件即 Django 自带的工具集 ROOT_URLCONF 指向 RUL 的路径 TEMPLATES 模板配置 WSGI_APPLICATION DATABASES 数据库配置，默认是 db.sqlite3 AUTH_PASSWORD_VALIDATORS 密码认证 LANGUAGE_CODE 语言 TIME_ZONE 时区 STATIC_URL 静态文件配置地址 urls.py 项目路由配置文件 manage.py 项目管理文件 manage.py 是与项目进行交互的命令行工具集的入口 wsgi.py python 服务器网关接口，项目与服务器通信的接口 __init__.py 声明模块的文件，默认内容为空 Django 应用 Djanog 项目与应用是一对多的关系，一个 Django 应用可以包含一组配置和若干个 Django 应用，Django 应用是一个可重用的 Python 软件包。 创建应用 1python3 manage.py startapp blog 添加应用名到 setting.py 中的 INSTALLED_APPS 1'blog.apps.BlogConfig' 参考应用目录 blog =&gt; apps.py =&gt; BlogConfig 应用目录 views.py 视图处理 models.py 定义应用模型 admin.py 定义 admin 模块管理对象 apps.py 声明应用 tests.py 编写应用测试用例 urls.py （自行创建）管理应用路由 对视图和路由的理解实例 编写视图函数 views.py 123456from django.shortcuts import renderfrom django.http import HttpResponsedef hello_world(request): return HttpResponse('hello world!') 编写路由配置 配置应用层次路由 在 blog 应用下创建 urls.py 文件： 12345678from django.urls import path, include# 引入刚才实现的视图文件import blog.views# 如果函数存在，则转发至对应路由位置urlpatterns = [ path('hello_world', blog.views.hello_world)] 配置项目层次路由 在项目的 urls.py 文件中实现： 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('blog/', include('blog.urls'))] 这时，启动项目服务器， 1python3 manage.py runserver 就可以在路由http://127.0.0.1:8000/blog/hello_world 访问。 模型(Model) 在 Django 中我们以创建类的形式来创建数据表,对数据库的操作，就是对类和类的对象的操作，即 ORM Model 定义在 blog 应用的 models.py 中定义： 1234567891011121314from django.db import modelsclass Article(models.Model): # 文章唯一ID article_id = models.AutoField(primary_key=True) # 文章标题 title = models.TextField() # 文章摘要 brief_content = models.TextField() # 文章内容 content = models.TextField() # 文章发布日期 publish_date = models.DateTimeField(auto_now=True) Model 迁移 通过模型的迁移将模型定义保存到数据库 创建模型变更的迁移文件 1python3 manage.py makemigrations 执行迁移文件同步变更到数据库 1python3 manage.py migrate Django shell使用命令可以进入 Django shell 环境 Python shell 用于交互式 Python 编程， Django shell也类似，它继承 Django 项目环境。 临时性操作使用 Djaogo shell 更加方便，它方便开发、调试、 Debug 1python3 manage.py shell 基本使用 python manage.py shell from blog.model import Article Article.object.all() Admin 模块 Django 的后台管理工具，可以读取定义的模型元数据，提供强大的管理使用页面。 管理页面的一般功能：认证用户、显示管理模型、校验输入等。由于管理页面是基础设施中的重要部分，功能又太过于统一，创建太过繁琐，所以 Django 提供了一个强大的 Admin 模块。 创建创建管理员用户 1pthon3 manage.py createsuperuser Username: akashi(自定义)Email: (选填)Password: akashiadmin123 登录页面进行管理 启动服务器(python3 manage.py runserver)，可以在http://127.0.0.1:8000/admin/登录进行访问。 将模型注册到 admin 在 blog/admin.py 中： 1234from django.contrib import adminfrom blog.models import Articleadmin.site.register(Article) 文章列表显示标题 在 models.py 定义一个函数，添加返回值： 12def __str__(self): return self.title 重新启动服务： python3 manage.py runserver，便可以返回文章的标题。 Django 视图和模板Template 模板系统的表现形式是文本，用于编写页面表现内容，做到了页面表现形式和表现内容分离。 定义了特有的标签占位符： 变量 1&#123;&#123;变量&#125;&#125; for 循环 12&#123;% for x in list %&#125;&#123;% endfor %&#125; if-else 循环 123&#123;% if %&#125;&#123;% else %&#125;&#123;% endif %&#125; 使用模板系统渲染博客页面 实现博客首页 新建页面存放路径：blog =&gt; templates =&gt; blog =&gt; index.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;My Blog&lt;/title&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;header class=\"container page-header\"&gt; &lt;h1&gt;My blog &lt;small&gt; —— by akashi&lt;/small&gt; &lt;/h1&gt;&lt;/header&gt;&lt;div class=\"container page-body\"&gt; &lt;div class=\"col-md-9\" role=\"main\"&gt; &lt;div class=\"body-main\"&gt; &#123;% for article in article_list %&#125; &lt;div&gt; &lt;h3&gt;&#123;&#123; article.title &#125;&#125;&lt;/h3&gt; &lt;p&gt;&#123;&#123; article.brief_content &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\" role=\"complementary\"&gt; &lt;div&gt; &lt;h3&gt;最新文章&lt;/h3&gt; &#123;% for article in article_list %&#125; &lt;h5&gt;&lt;a href=\"#\"&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;&lt;/h5&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在 views.py 中编辑返回方法： 123456def get_index_page(request): all_article = Article.objects.all() # 渲染模板数据返回 return render(request, 'blog/index.html', &#123; 'article_list': all_article &#125;) 配置路由，在应用路由 urls.py 中添加： 1path('index', blog.views.get_index_page), 之后便可以在 http://127.0.0.1:8000/blog/index 进行访问。 博客详情页 依照首页的步骤，先规划页面路径：blog =&gt; templates =&gt; blog =&gt; detail.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;&#123; current_article.title &#125;&#125;&lt;/title&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;header class=\"container page-header\"&gt; &lt;h3&gt;&#123;&#123; current_article.title &#125;&#125;&lt;/h3&gt;&lt;/header&gt;&lt;div class=\"container page-body\"&gt; &lt;div class=\"body-main\"&gt; &lt;p&gt; &#123;&#123; current_article.content &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法定义： 1234567def get_detail_page(request): current_article = Article.objects.all()[0] section_list = current_article.content.split('\\n') return render(request, 'blog/detail.html', &#123; 'current_article': current_article, 'section_list': section_list &#125;) 路由配置： 1path('detail', blog.views.get_detail_page) 实现文章详情页页面跳转 文章跳转 重新规划 URL，传入 article_id 作为参数： 1path('detail/&lt;int:article_id&gt;', blog.views.get_detail_page) 同时，在视图层以形参的方式传入： 1234567def get_detail_page(request, article_id): current_article = Article.objects.get(article_id=article_id) section_list = current_article.content.split('\\n') return render(request, 'blog/detail.html', &#123; 'current_article': current_article, 'section_list': section_list &#125;) 这样，就可以指定 id 进行文章跳转。 实现超链接跳转 index.html: 1234567891011121314151617&lt;div class=\"body-main\"&gt; &#123;% for article in article_list %&#125; &lt;div&gt; &lt;h3&gt; &lt;a href=\"/blog/detail/&#123;&#123; article.article_id &#125;&#125;\"&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt; &lt;/h3&gt; &lt;p&gt;&#123;&#123; article.brief_content &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt;...&lt;div&gt; &lt;h3&gt;最新文章&lt;/h3&gt; &#123;% for article in article_list %&#125; &lt;h5&gt;&lt;a href=\"/blog/detail/&#123;&#123; article.article_id &#125;&#125;\"&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;&lt;/h5&gt; &#123;% endfor %&#125;&lt;/div&gt; 实现文章上下篇跳转首先，在 detail.html 中添加翻页标签： 12345678&lt;div class=\"container\"&gt; &lt;nav aria-label=\"...\"&gt; &lt;ul class=\"pager\"&gt; &lt;li&gt;&lt;a href=\"blog/detail/&#123;&#123; previous_article.article_id &#125;&#125;\"&gt;上一篇：&#123;&#123; previous_article.title &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"blog/detail/&#123;&#123; next_article.article_id &#125;&#125;\"&gt;下一篇：&#123;&#123; next_article.title &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 然后，在 views.py 中添加需要的变量，并添加逻辑： 123456789101112131415161718192021222324252627282930def get_detail_page(request, article_id): current_article = None previous_article = None next_article = None all_article = Article.objects.all() for index, article in enumerate(all_article): if index == 0: previous_index = 0 next_index = index + 1 elif index == len(all_article) - 1: previous_index = index - 1 next_index = index else: previous_index = index - 1 next_index = index + 1 if article.article_id == article_id: current_article = article previous_article = all_article[previous_index] next_article = all_article[next_index] section_list = current_article.content.split('\\n') return render(request, 'blog/detail.html', &#123; 'current_article': current_article, 'section_list': section_list, 'previous_article': previous_article, 'next_article': next_article &#125;) 这样，就实现了上一页，下一页的跳转。 实现分页功能首页，也是在 index.html 添加分页标签： 123456789101112131415161718192021&lt;div class=\"container body-footer clo-md-4 col-md-offset-3\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"#\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 然后，设计 URL 并获取分页的值： 设计 URL 如下： http://127.0.0.1:8000/blog/index?page=9 获取： 12345678910111213def get_index_page(request): all_article = Article.objects.all() page = request.GET.get('page') if page: page = int(page) else: # 赋一个默认值 page = 1 # 渲染模板数据返回 return render(request, 'blog/index.html', &#123; 'article_list': all_article &#125;) 使用 Django 分页组件 导入： 12# 引入分页组件from django.core.paginator import Paginator 获取当前页、上一页、下一页并实现逻辑： 1234567891011121314151617181920212223242526272829303132333435def get_index_page(request): all_article = Article.objects.all() page = request.GET.get('page') if page: page = int(page) else: # 赋一个默认值 page = 1 # 实例化分页组件 # 传入文章列表和分页数量 paginator = Paginator(all_article, 2) # 获取分页数 page_num = paginator.num_pages # 获取当前页 page_article_list = paginator.page(page) # 判断是否有下一页 if page_article_list.has_next(): next_page = page + 1 else: next_page = page # 判断是否有上一页 if page_article_list.has_previous(): previous_page = page - 1 else: previous_page = page # 渲染模板数据返回 return render(request, 'blog/index.html', &#123; 'article_list': page_article_list, 'page_num': range(1, page_num + 1), 'current_page': page, 'previous': previous_page, 'next': next_page &#125;) 同时，修改分页链接： 12345678910111213141516171819&lt;div class=\"container body-footer clo-md-4 col-md-offset-3\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"/blog/index?page=&#123;&#123; previous &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% for num in page_num %&#125; &lt;li&gt;&lt;a href=\"/blog/index?page=&#123;&#123; num &#125;&#125;\"&gt;&#123;&#123; num &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;li&gt; &lt;a href=\"/blog/index?page=&#123;&#123; next &#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/div&gt; 这样，就完成了分页功能。 实现最近文章列表通过 order_by 查询并切片获取最新文章列表返回： 12345678910111213141516171819202122232425262728293031323334353637383940def get_index_page(request): all_article = Article.objects.all() # - 表示倒序排序 top3_article_list = Article.objects.order_by('-publish_date')[:3] page = request.GET.get('page') if page: page = int(page) else: # 赋一个默认值 page = 1 # 实例化分页组件 # 传入文章列表和分页数量 paginator = Paginator(all_article, 2) # 获取分页数 page_num = paginator.num_pages # 获取当前页 page_article_list = paginator.page(page) # 判断是否有下一页 if page_article_list.has_next(): next_page = page + 1 else: next_page = page # 判断是否有上一页 if page_article_list.has_previous(): previous_page = page - 1 else: previous_page = page # 渲染模板数据返回 return render(request, 'blog/index.html', &#123; 'article_list': page_article_list, 'page_num': range(1, page_num + 1), 'current_page': page, 'previous': previous_page, 'next': next_page, 'top3_article_list': top3_article_list &#125;) 修改前端链接： 12345678&lt;div class=\"col-md-3\" role=\"complementary\"&gt; &lt;div&gt; &lt;h3&gt;最新文章&lt;/h3&gt; &#123;% for article in top3_article_list %&#125; &lt;h5&gt;&lt;a href=\"/blog/detail/&#123;&#123; article.article_id &#125;&#125;\"&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;&lt;/h5&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/div&gt; 这样，最新文章获取也完成了。 至此，完成了简易博客的全部功能。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://akashigakki.github.io/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://akashigakki.github.io/tags/Django/"}]},{"title":"MongoDB 之可视化工具推荐 —— adminMongo","slug":"mongo_admin/adminMongo","date":"2019-08-09T16:00:00.000Z","updated":"2020-10-06T11:15:40.741Z","comments":true,"path":"2019/08/10/mongo_admin/adminMongo/","link":"","permalink":"http://akashigakki.github.io/2019/08/10/mongo_admin/adminMongo/","excerpt":"MongoDB 之可视化工具推荐 —— adminMongo 最近学习 MongoDB 发现了一款好用的可视化工具 —— adminMongo，记录一下基本使用。","text":"MongoDB 之可视化工具推荐 —— adminMongo 最近学习 MongoDB 发现了一款好用的可视化工具 —— adminMongo，记录一下基本使用。 简介adminMongo 是一个跨平台用户界面(GUI)，用于处理所有 MongoDB 连接/数据库需求。 adminMongo 连接信息(包括用户名/密码)以未加密的方式存储在配置文件中，因此不建议在没有适当安全性考虑的情况下在生产或面向公共的服务器上运行此应用程序。 github 地址： https://github.com/mrvautin/adminMongo 安装 克隆 git 仓库到本地 选取合适的文件目录下终端运行： 1git clone https://github.com/mrvautin/adminMongo 进入目录 1cd adminMongo 安装依赖 1cnpm install 终端提示需要安装包和升级可按具体情况运行： 12npm xxx # 看具体缺少哪些包，分别进行安装npm update # 进行升级 启动 1cnpm start 这时，程序已经启动，并且监听本地的 1234 端口，我们可以打开浏览器进行访问。 注意：以上 cnpm 为 npm 的国内淘宝镜像源，速度比较快，如果没有配置可以使用 npm 对 cnpm 进行替换即可；或者输入以下命令进行安装使用： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 访问启动后的地址 http://localhost:1234 localhost 即本地 IP: 127.0.0.1 1234 表示程序监听的端口号 进入地址之后，需要填写连接名称和地址，连接名称可任意命名，这里填入 localhost，地址为：mongodb://127.0.0.1:12017 12017 为 MongoDB 默认监听的端口号 如果提示连接错误，可以尝试以 mongodb://localhost 进行连接 确认之后点击添加连接。 连接 MongoDB 添加之后，跳转到连接界面，点击连接进入 MongoDB 数据库： 这个时候就可以看见本地所有的 MongoDB 数据库了： 可以随意的进行查询和编辑了：","categories":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/categories/数据库/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"http://akashigakki.github.io/categories/数据库/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://akashigakki.github.io/tags/MongoDB/"},{"name":"可视化工具","slug":"可视化工具","permalink":"http://akashigakki.github.io/tags/可视化工具/"}]},{"title":"Virtualenv 虚拟环境搭建","slug":"python_Virtualenv/env","date":"2019-08-09T16:00:00.000Z","updated":"2020-10-06T11:15:40.829Z","comments":true,"path":"2019/08/10/python_Virtualenv/env/","link":"","permalink":"http://akashigakki.github.io/2019/08/10/python_Virtualenv/env/","excerpt":"Virturalenv 虚拟环境搭建 在 Python 的开发中，我们可能会遇到这这样一种情况，当前的项目依赖是某一个 python3 的版本，而另一个项目却是依赖一个 python2 的版本(同一种情况也可能发生在 Diango 中)，这种情况下，在本地同时开发和维护两个版本就会造成版本冲突，virturalenv 就可以解决以上问题。","text":"Virturalenv 虚拟环境搭建 在 Python 的开发中，我们可能会遇到这这样一种情况，当前的项目依赖是某一个 python3 的版本，而另一个项目却是依赖一个 python2 的版本(同一种情况也可能发生在 Diango 中)，这种情况下，在本地同时开发和维护两个版本就会造成版本冲突，virturalenv 就可以解决以上问题。 VirtualEnv 可以搭建虚拟且独立的 python 运行环境, 使得单个项目的运行环境与其它项目独立起来。同时也可以用于在一台机器上创建多个独立的 python 运行环境， VirtualEnvWrapper 为前者提供了一些便利的命令行上的封装。 安装1pip3 install virtualenv 查看安装版本来确认安装： 1virtualenv --version 使用豆瓣源 有时使用官方源安装第三方库会出现下载过慢或者超时的情况，这时候可以尝试使用国内的源进行安装。 临时使用 1pip3 install pythonModuleName -i https://pypi.douban.com/simple 永久使用 需要找到 python 的安装路径，然后找到 Lib/site-packages\\pip\\commands 下的 search.py 文件，发现里面有如下两行代码: 12from pip.models import PyPIdefault=PyPI.pypi_url, 可以看出来 PyPI.pypi_url 是从 moudels 模块里导入的，所以要找到 moudels 模板，该模块位于上一级目录，打开 moudels 里面的 index.py 文件: 1PyPI = Index('https://pypi.python.org/') 修改 https://pypi.python.org/ 为 https://pypi.douban.com/simple 新建 virtualenv 环境新建虚拟环境1virtualenv env-test 这样，我们就创建了一个名为 env-test 的虚拟环境。 当然，也可以指定安装依赖的 python 版本，使用参数 -p 进行指定： 1virtualenv -p python3 py-test 激活进入虚拟环境，进入 bin 目录，使用 source activate 激活虚拟环境，当然也可以一步到位： 1source env-test/bin/activate 这样，就激活了当前的虚拟环境，做到了与其他 Python 项目的环境进行隔离，可以自行安装需要的依赖进行开发了。 Windows 用户进入 Script 目录，运行 activite.bat 进行激活。 退出虚拟环境只需运行 1deactivate 同样， Windows 用户需要执行脚本退出，运行 deactivate.bat 退出环境。 安装 virtualenvwrapper Virtaulenvwrapper 是 virtualenv 的扩展包管理工具，可以更方便地新增，删除，复制，切换虚拟环境。 安装1pip3 install virtualenvwrapper 安装完成后，需要对 virtualenvwrapper 进行配置: 12export WORKON_HOME=~/Envs // 虚拟环境存储路径source /usr/local/bin/virtualenvwrapper.sh // 执行命令封装包 由于每次都需要执行这两部操作，我们可以将其写入终端的配置文件中。例如，如果使用 bash，则添加到 ~/.bashrc 中；如果使用 zsh，则添加到 ~/.zshrc 中。这样每次启动终端的时候都会自动运行，执行之后 virtualenvwrapper 就可以用啦。 写入配置之后执行生效， 1source ~/.zshrc 这里要看自己本机的配置情况，我使用的是 zsh，所以执行 source ~/.zshrc。 使用现在，可以使用 virtualenvwrapper 新建一个虚拟环境： 1mkvirtualenv env-pytest 激活环境 1workon env-pytest workon 不带参数可以列出本机所有的虚拟环境: 1workon 所有的命令可使用：virtualenvwrapper --help 进行查看，这里列出几个常用的： 创建基本环境：mkvirtualenv [环境名] 删除环境：rmvirtualenv [环境名] 激活/切换环境：workon [环境名] 退出环境：deactivate 列出所有环境：workon 或者 lsvirtualenv -b 查询子虚拟环境列表：lsvirtualenv -b 查看当前环境已经安装的 Python 安装包：lssitepackages","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"http://akashigakki.github.io/tags/虚拟环境/"},{"name":"env","slug":"env","permalink":"http://akashigakki.github.io/tags/env/"}]},{"title":"Mac 终端美化方案","slug":"mac_prettify/oh-my-zsh","date":"2019-08-08T16:00:00.000Z","updated":"2020-10-06T11:15:40.740Z","comments":true,"path":"2019/08/09/mac_prettify/oh-my-zsh/","link":"","permalink":"http://akashigakki.github.io/2019/08/09/mac_prettify/oh-my-zsh/","excerpt":"Mac 终端美化方案 配合 iTerm2 + zsh + oh-my-zsh 打造一个 Mac 终端美化计划。","text":"Mac 终端美化方案 配合 iTerm2 + zsh + oh-my-zsh 打造一个 Mac 终端美化计划。 以下是最终效果： 使用 iTerm2 安装 1brew cask install iterm2 下载完成之后，打开软件，进入设置(Preferences) =&gt; Porfile =&gt; 可以选择颜色(colors)、字体(text)等。 这样就可以使用 iTerm2 代替 Mac 默认终端(terminal)。除了强大的功能，所谓颜值就是第一生产力。 使用 zshshell 的类型有很多种，Mac 和 Linux 默认使用的是 bash。虽然 bash 也足够使用，但远没有 zsh 强大，界面也不够酷炫，并不是最好的选择。 而 zsh 功能极其强大，但是配置复杂，直到出现了开源项目 oh my zsh，只需简单的配置，就可以使用。 Mac 下默认安装了 zsh，但不是最新版 查看当前使用的 shell: 1echo $SHELL 查看安装的 shell: 1cat /etc/shells 查看 zsh 的版本： 1zsh --version 更新 zsh: 1brew install zsh 添加到 path： 1echo &apos;export PATH=&quot;/usr/local/opt/ncurses/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile 切换为 zsh 1chsh -s /bin/zsh 重启终端，即可使用 zsh。 安装 oh my zsh以下提供三种方式，任选其一： 使用 git 1git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 使用 curl 1sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 使用 wget 1sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 安装完成以后，默认 Shell 的 ~/.bashrc 文件默认不再加载了，替代的是 ~/.zlogin 和 ~/.zshrc。所以如果在 ~/.bashrc 里配置了某些设置，需要把她们复制到 ~/.zshrc 中。 或者执行： 12echo 'source ~/.bashrc' &gt;&gt; ~/.zshrcecho 'source ~/.bash_profile' &gt;&gt; ~/.zshrc 备份配置文件（可省略） 1cp ~/.zshrc ~/.zshrc.orig 主题配置oh my zsh 提供了数十种主题，相关文件在 ~/.oh-my-zsh/themes 目录下，你可以自己选择，也可以自己编写主题。 参考主题列表：https://github.com/robbyrussell/oh-my-zsh/wiki/themes 在 .zshrc 里找到 ZSH_THEME，就可以设置主题了，默认主题是：ZSH_THEME=&quot;robbyrussell&quot; ZSH_THEME=&quot;random&quot;，主题设置为随机，这样我们每打开一个窗口，都会随机在默认主题中选择一个。 这里推荐两款常用的颜值比较高的主题： agnoster 和 ys 字体安装 1git clone https://github.com/supermarin/powerline-fonts.git 将该仓库克隆到本地，然后进入工程目录的 Monaco 目录，双击后缀名为 .otf 的字体文件即可完成该字体的安装。安装该字体的原因主要是为了和 Oh-My-Zsh 的 agnoster、powerlevel9k 主题相兼容，如果不安装该字体，那么后面安装 powerlevel9kn 主题后会出现乱码。 agnoster 最终效果： 插件设置oh my zsh 项目提供了完善的插件体系，相关的文件在 ~/.oh-my-zsh/plugins 目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在 .zshrc 里配置，找到 plugins 关键字，你就可以加载自己的插件了，系统默认加载 git，你可以在后面追加内容，如下： 1plugins=(git zsh-autosuggestions zsh-syntax-highlighting) 安装 zsh-autosuggestions 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 添加至 plugins 安装 zsh-syntax-highlighting 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 添加至 plugins 安装 incr.zsh 1wget http://mimosa-pudica.net/src/incr-0.2.zsh 将此插件放到 oh-my-zsh 目录的插件库下： 在 ~/.zshrc 文件末尾加上插件 1echo 'source ~/.oh-my-zsh/plugins/incr/incr*.zsh' &gt;&gt; ~/.zshrc 更新配置： 1source ~/.zshrc 主题安装 克隆该仓库到 oh-my-zsh 用户自定义主题目录 1git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 修改 ~/.zshrc 配置文件，配置该主题 1ZSH_THEME=\"powerlevel9k/powerlevel9k\" 生效配置 1source ~/.zshrc 以上，配置完成。还有更多配置、效果随缘更新。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"终端","slug":"终端","permalink":"http://akashigakki.github.io/tags/终端/"},{"name":"美化","slug":"美化","permalink":"http://akashigakki.github.io/tags/美化/"}]},{"title":"Homebrew 日常使用","slug":"brew/homebrew","date":"2019-08-06T16:00:00.000Z","updated":"2020-10-06T11:15:40.729Z","comments":true,"path":"2019/08/07/brew/homebrew/","link":"","permalink":"http://akashigakki.github.io/2019/08/07/brew/homebrew/","excerpt":"Homebrew Homebrew 是一款 Mac OS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。","text":"Homebrew Homebrew 是一款 Mac OS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 包管理工具顾名思义就是程序软件包的安装管理工具， Linux 上有 apt, apt-get, yum 等包管理系统，Mac OS 也有一个优秀的包管理工具，它就是 Homebrew。 当然，Windows 也有类似的管理工具，推荐 Scoop，你可以在这里学习使用。 那么回到今天的主题，这里是 Homebrew 的官网地址：https://brew.sh/ 安装和使用在安装 Homebrew 之前，需要将 Xcode Command Line Tools 安装完成，这样就可以使用基于 Xcode Command Line Tools 编译的 Homebrew 1xcode-select --install 安装打开终端，输入以下命令，输入密码，完成安装： 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Homebrew 是基于 ruby 的，命令都是通过 ruby 脚本运行，不过不用担心，Mac OS 默认安装了 ruby 环境，可以直接使用命令。 确认安装成功： 1brew -v 终端打印出安装版本信息，则证明安装成功。 你也可以查询帮助信息： 1brew -h 卸载如果你想进行卸载 终端输入命令，输入密码，等待卸载完成： 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" 基本使用常用命令 brew install [package]：安装包 brew uninstall [package]：卸载包 brew outdated：列出过时的软件 brew upgrade：更新过时的软件(全部或指定) brew update：升级 homebrew 在服务器端上的包目录 brew list：列出所有安装的包 brew clean up：清理旧版本缓存 brew search [package]: 安装包检索 brew info [package]：安装包信息检索 安装任意包1brew install [package] eg: 使用 Homebrew 安装 node 1brew install node 卸载任意包如果你想进行卸载： 1brew uninstall [package] eg: 使用 Homebrew 卸载 Python 1brew uninstall python 查询可用包1brew search [package] 当不确定是否存在可用的安装包，可以尝试查询，例如我们查询是否存在 wget: 1brew search wget 如果可以查询到相关信息，就可以根据查询到的名称进行安装使用。 查询安装列表查看本机通过 Homebrew 安装的包: 1brew list 查询任意包信息1brew list [backage] 这里查询 git 的相关信息： 1brew info git Homebrew Cask Homebrew Cask可以优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。 这里我们尝试安装 Chrome。 首先，确认是否存在： 1brew search chrome 等待搜索完成，我们可以发现，在 casks 一栏有 google-chrome 选项，那么接下来就进行安装： 1brew cask install google-chrome 更多安装和使用你可以自己去尝试和发现。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"包管理工具","slug":"包管理工具","permalink":"http://akashigakki.github.io/tags/包管理工具/"},{"name":"Homebrew","slug":"Homebrew","permalink":"http://akashigakki.github.io/tags/Homebrew/"}]},{"title":"MongoDB 初探","slug":"mondodb/mongodb","date":"2019-08-06T16:00:00.000Z","updated":"2020-10-06T11:15:40.741Z","comments":true,"path":"2019/08/07/mondodb/mongodb/","link":"","permalink":"http://akashigakki.github.io/2019/08/07/mondodb/mongodb/","excerpt":"MongoDB 初探 MongoDB 是由 C++ 语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。","text":"MongoDB 初探 MongoDB 是由 C++ 语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。 准备工作安装这里使用 Mac OS 的包管理工具 Homebrew 进行下载安装，其他系统请自行搜索正确安装姿势。 1brew install mongodb 然后创建一个新文件夹 /data/db，用于存放 MongoDB 数据。 注意：默认 MongoDB 数据文件是放到根目录 data/db 文件夹下,如果没有这个文件,需要自行创建。 启动1brew services start mongodb 或者： 1sudo mongodb 停止、重启停止: 1brew services stop mongodb 重启: 1brew serbices restart mongodb 可视化工具 推荐两个可视化工具。 RoboMongo/Robo 3T https://robomongo.org/ Studio 3T https://studio3t.com/ 简介和使用 MongoDB 是一个非关系型的数据库，什么叫非关系型？就是把数据直接放进一个大仓库，不标号、不连线、单纯的堆起来。传统数据库由于受到各种关系的累赘，各种数据形式的束缚，特有的约束和关联成为性能瓶颈，难以处理海量数据以及超高并发的业务场景。为了应对海量数据的存储，出现了非关系型数据库，它不支持外键，不支持事务，不支持数据类型约定，就这样松散的数据结构，成就了数据量的扩展。 面向集合的存储在 MongoDB 中，一个数据库包含多个集合，类似于 MySQL 中一个数据库包含多个表；一个集合包含多个文档，类似于 MySQL 中一个表包含多条数据。 可以把集合记为表，文档记为一条记录。 这样命名是有原因的，因为 MongoDB 没有行列统一的表格式排列，而是采用一个大仓库的形式将所有数据包纳其中。文档也一样，它是一段自由独立的数据，受外部限制少，所以区别于关系型数据库的记录。 数据库 一个 MongoDB 可以创建多个数据库 使用 show dbs 可以查询所有数据库的列表 执行 db 命令则可以查看当前数据库对象或者集合 运行 use 命令可以连接到指定的数据库 注意：数据库名可以是任何字符，但是不能有空格、点号和 $ 字符。 下面实际操作一次，在启动了 MongoDB 服务以后，在终端运行 mongo 可以进入 MongoDB 环境。 1mongo 接下来我们查看所有的数据库列表： 1show dbs 使用 use 命令创建数据库 1use test 查询当前的数据库对象 1db 再次查看所有数据库 1show dbs 列出的所有数据库中看不到 test 或者显示 test(empty) ，因为 test 为空，里面没有任何东西，MongoDB 不显示或显示 test(empty)。 销毁数据库 1db.dropDatabase() 这样，刚刚创建的数据库就被销毁了。 使用 exit 退出 MongoDB 环境 1exit 集合集合就是一组文档的组合，就相当于是 关系数据库中的表，在 MongoDB 中可以存储不同的文档结构的文档。 例如： 1&#123;\"user\": \"akashi\"&#125; &#123;\"idol\": \"nogizaka\", \"member\": \"asuka\"&#125; 上面的两个文档就可以存储在同一个集合中，在关系型数据库中是很难实现上述数据结构的，要么需要定义大量的字段，对于一些字段名不确定的属性，关系型数据库会更加力不从心。 文档文档是 MongoDB 的核心，类似于关系型数据库的每一条数据，多个键及其关联的值放在一起就是文档。在 Mongodb 中使用一种类 json 的 bson 存储数据，bson 数据可以理解为在 json 的基础上添加了一些 json 中没有的数据类型。 文档的逻辑关系 例如有以下两个文档： 1234567891011121314# user文档&#123; \"name\": \"akashi\", \"age\": 22, \"sex\": \"male\"&#125;# address文档&#123; \"building\": \"22 A, Indiana Apt\", \"pincode\": 123456, \"city\": \"chengdu\", \"state\": \"sichuan\"&#125; 嵌入式关系: 1234567891011121314151617&#123; \"name\": \"akashi\", \"age\": 22, \"sex\": \"male\", \"address\": [&#123; \"building\": \"22 A, Indiana Apt\", \"pincode\": 123456, \"city\": \"chengdu\", \"state\": \"sichuan\" &#125;,&#123; \"building\": \"170 A, Acropolis Apt\", \"pincode\": 456789, \"city\": \"beijing\", \"state\": \"beijing\" &#125;]&#125; 引用式关系: 将两个文档分开，通过引用文档的_id 字段来建立关系。 12345678&#123; \"name\": \"akashi\", \"age\": 22, \"sex\": \"male\", \"address_ids\": [ ObjectId(\"52ffc4a5d85242602e000000\") #对应address文档的id字段 ]&#125; 在实际应用的时候，嵌入式 关系比较适合 一对一 的关系，引用式 关系比较适合 一对多 或者 多对多 的情况。 原数据数据库的信息存储在集合中，他们统一使用系统的命名空间：DBNAME.system.*。 DBNAME 可用 db 或数据库名替代： DBNAME.system.namespaces ：列出所有名字空间 DBNAME.system.indexs ：列出所有索引 DBNAME.system.profile ：列出数据库概要信息 DBNAME.system.users ：列出访问数据库的用户 DBNAME.system.sources ：列出服务器信息 集合的创建和删除 创建集合 在数据库 test 中创建一个集合 users: 12use testdb.createCollection(&quot;users&quot;) 查看创建的集合： 1show collections 删除集合 删除刚刚创建的集合 users: 1db.users.drop() 查看是否删除成： 1show collections 向集合中插入数据 使用 insert() 插入数据时，如果 users 集合没有创建会自动创建。 123456789db.users.insert([ &#123; \"name\": \"akashi\", \"email\": \"akashisai@163.com\" &#125;, &#123; \"name\": \"asuka\", \"email\": \"asuka@163.com\" &#125;]) 使用 save() 插入数据时，如果 users 集合没有创建会自动创建。 1234db.users.save(&#123; \"name\": \"akashi\", \"email\": \"akashi_sai@163.com\"&#125;) insert 和 save 的区别：insert 是插入，侧重于新增一个记录的含义；save 是保存，可以保存一个新的记录，也可以保存对一个记录的修改。因此，insert 不能插入一条已经存在的记录，如果已经有了一条记录(以主键为准)，insert 操作会报错，而使用 save 指令则会更新原记录。 阶段小结到这里我们大致了解了非关系型数据库和关系型数据库的差异，现在我们来做一个阶段小结。 关系型数据库的结构一般是 数据库database =&gt; 表table =&gt; 字段field，就像下面这样： 而非关系型数据库的结构一般是 数据库database =&gt; 集合collection =&gt; 文档document，像下面这样： 在充分理解差异之后，才能很好的将两者区分开来，不至于混淆。 数据查询find()语法如下： 1db.COLLECTION_NAME.find() 以之前创建的 users 集合为例： 查询所有文档 查询数据，不加任何参数默认返回所有数据记录 1db.users.find() 添加查询条件 1db.users.find(&#123;&quot;name&quot;: &quot;akashi&quot;&#125;) pretty() pretty() 可以使查询输出的结果更美观。 1db.users.find().pretty() 如果你想让 mongo shell 始终以 pretty 的方式显示返回数据，可以通过下面的指令实现（退出环境，在终端输入）： 1echo \"DBQuery.prototype._prettyShell = true\" &gt;&gt; ~/.mongorc.js 这样就把默认的显示方式设置为 pretty 了。 AND MongoDB 不需要类似于其他数据库的 AND 运算符，当 find() 中传入多个键值对时，MongoDB 就会将其作为 AND 查询处理。 用法： 1db.mycol.find(&#123; key1: value1, key2: value2 &#125;) OR MongoDB 中，OR 查询语句以 $or 作为关键词，用法如下： 12345db.users.find(&#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ]&#125;) 更多$gt 表示大于、$lt 表示小于、$gte 表示大于等于、$lte 表示小于等于、$ne 表示不等于。 可以这样记忆： 表达式 意义 描述 gt： 大于 greater than lt： 小于 less than gte： 大于或等于 greater than equal lte： 小于或等于 less than equal 文档基本操作删除数据库语法： db.dropDatabase()：删除数据库 在当前数据库对象下执行语句，即可删除数据库。 12345# 使用 db 查询当前数据库对象db# 删除当前数据库db.dropDatabase 创建集合语法： createCollection(name,options)：创建集合 参数描述: name：创建的集合名称 options：是一个作为初始化的文档(可选) 之前我们创建过无参数的集合，下面我们尝试创建一个带参数的集合： 1db.createCollection(&quot;user&quot;, &#123; capped : 1, autoIndexId : 1, size : 6142800, max : 10000 &#125; ) #带参数 参数描述： capped：类型为 Boolean，如果为 true 则创建一个固定大小的集合，当其条目达到最大时可以自动覆盖以前的条目。在设置其为 true 时也要指定参数大小；注意：固定集合的数据不能被修改，只能查找 =&gt; 删除 =&gt; 再插入； autoIndexId：类型为 Boolean，默认为 false，如果设置为 true，则会在 _id 字段上自动创建索引； size：如果 capped 为 true 则需要指定，指定参数的最大值，单位为 byte； max：指定最大的文档数。 在 Mongodb 中也可以不用创建集合，因为在创建文档的时候也会自动的创建集合。 删除集合语法： db.COLLECTION.drop()：删除集合 以下我们依然以之前创建的 test 数据库为例： 123use test # 选择数据库show collections # 查看集合列表db.users.drop() # 删除test数据库下的users集合 插入文档语法： db.COLLECTION_NAME.insert(document)：插入文档 我们以下面的例子实际演示： 123456789101112131415# 先定义文档user = ([ &#123; \"user_id\": 1, \"name\": \"akashi\", \"email\": \"akashisai@163.com\" &#125;, &#123; \"user_id\": 2, \"name\": \"asuka\", \"email\": \"asuka@163.com\" &#125;])# 创建集合test的同时，插入文档数据db.test.insert(user) 更新文档语法： db.COLLECTION_NAME.update(SELECTION_CRITERIA,UPDATED_DATA)：更新文档 我们将 user_id=1 文档中 email 进行更新： 1234567db.test.update(&#123; \"user_id\": 1&#125;, &#123; $set:&#123; \"email\": \"akashi_sai@163.com\" &#125;&#125;) 查询更新效果： 1db.test.find() 括号内第一个参数标识查找的内容的条件，第二个参数标识更新后的数据 默认的 update 函数只对一个文档更新，如果想作用所有文档，则需要加入 multi:true 1234567891011db.test.update(&#123; \"user_id\": 1, \"name\": \"akashi\", \"email\": \"akashisai.163.com\"&#125;, &#123; $set:&#123; \"email\": \"akashi_sai@163.com\" &#125;&#125;, &#123; \"multi\": true&#125;) 替换文档语法： db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})：替换已存在的文档 123456db.test.save(&#123; \"_id\" : ObjectId(\"5d4ba3240d800ad42ba1f8b8\"), \"user_id\": 2, \"name\": \"sito_asuka\", \"email\": \"sito_asuka@163.com\"&#125;) 前面提到过一下 save 的用法，它在存入数据的过程中，如果数据存在(通过主键_di进行区分)，则会替换原来的数据，如果不存在，则会新建一条数据。 我们也可以使用它插入一条文档： 12345db.test.save(&#123; &quot;user_id&quot;: 3, &quot;name&quot;: &quot;gakki&quot;, &quot;email&quot;: &quot;gakki@163.com&quot;&#125;) 删除文档语法： db.COLLECTION_NAME.remove(DELECTION_CRITERIA)：删除文档 其实 remove 函数的参数跟 update 函数的第一个参数一样，相当于查找条件，注意，不要误删！ 123db.test.remove(&#123; &quot;name&quot;: &quot;gakki&quot;&#125;) 删除后可以用查找命令确认数据: 1db.test.find() 查询、索引与聚合查询语句 find()语法： db.COLLECTION_NAME.find(Parameter) 已经使用过好多次了，这里不再介绍。 条件操作符 $gt：大于$lt：小于$gte：大于等于$lte：小于等于 $type:[key]: 可选的 key 值如下： 1: 双精度型(Double)2: 字符串(String)3: 对象(Object)4: 数组(Array)5: 二进制数据(Binary data)7: 对象 ID(Object id)8: 布尔类型(Boolean)9: 数据(Date)10: 空(Null)11: 正则表达式(Regular Expression)13: JS 代码(Javascript)14: 符号(Symbol)15: 有作用域的 JS 代码(JavaScript with scope)16: 32 位整型数(32-bit integer)17: 时间戳(Timestamp)18: 64 位整型数(64-bit integer)-1: 最小值(Min key)127: 最大值(Max key) 1db.test.find(&#123;&quot;name&quot;: &#123;$type:2&#125;&#125;) 上面的命令是用于查找 name 是字符串的文档记录，它等同于下面的命令： 1db.test.find(&#123;&quot;name&quot;: &#123;$type:&apos;string&apos;&#125;&#125;) limit() 与 skip() 读取指定数量的数据记录 limit()。 1db.test.find().limit(1) 读取一条记录，默认是排在最前面的那一条被读取。 读取时跳过指定数量的数据记录 skip()。 1db.test.find().limit(1).skip(1) 当然，还可以添加 find 的查找条件的参数，以便进行更精确的查找。 排序 sort() 标识升序和降序，其中升序用 1 表示，降序用 -1 表示。 语法： db.COLLECTION_NAME.find().sort({KEY:1|-1}) 1db.test.find().sort(&#123;&quot;user_id&quot;:-1&#125;) 索引 ensureIndex() 索引通常能够极大的提高查询的效率，如果没有索引，MongoDB 在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可能要花费几十秒甚至几分钟，这无疑对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库集合中一个文档或多个文档的值进行排序的一种结构。 语法： db.COLLECTION_NAME.ensureIndex({KEY:1|-1}) 同样 1 代表升序，-1 代表降序 1db.test.ensureIndex(&#123;&quot;name&quot;: 1&#125;) ensureIndex() 的可选参数： 参数 类型 描述 background Boolean 建立索引要不要阻塞其他数据库操作，默认为 false unique Boolean 建立的索引是否唯一，默认 false name string 索引的名称，若未指定，系统自动生成 dropDups Boolean 建立唯一索引时，是否删除重复记录，默认 flase sparse Boolean 对文档不存在的字段数据不启用索引，默认 false expireAfterSeconds integer 设置集合的生存时间，单位为秒 v index version 索引的版本号 weights document 索引权重值，范围为 1 到 99999 default-language string 默认为英语 language_override string 默认值为 language 1db.test.ensureIndex(&#123;&quot;user_id&quot;:1,&quot;name&quot;:1&#125;,&#123;background:1&#125;) 聚合 aggregate()语法： 12345db.COLLECTION_NAME.aggregate(&#123; $match:&#123;x:1&#125;, &#123;limit:NUM&#125;, $group:&#123;_id:$age&#125;&#125;) 这些参数都可选： $match：查询，跟 find 一样； $limit：限制显示结果数量； $skip：忽略结果数量； $sort：排序； $group：按照给定表达式组合结果。 聚合表达式 名称 描述 $sum 计算总和 $avg 计算平均值 min 和 min 和 max 计算最小值和最大值 $push 在结果文档中插入值到一个数组 $addToSet 在结果文档中插入值到一个数组，但不创建副本 $first 根据资源文档的排序获取第一个文档数据 $last 根据资源文档的排序获取最后一个文档数据 管道 MongoDB 的聚合管道将 MongoDB 文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。 聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match 使用 MongoDB 的标准查询操作。 $limit：用来限制 MongoDB 聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/categories/数据库/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"http://akashigakki.github.io/categories/数据库/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://akashigakki.github.io/tags/MongoDB/"}]},{"title":"SQL 基础笔记","slug":"SQL/mysql","date":"2019-08-02T16:00:00.000Z","updated":"2020-10-06T11:15:40.721Z","comments":true,"path":"2019/08/03/SQL/mysql/","link":"","permalink":"http://akashigakki.github.io/2019/08/03/SQL/mysql/","excerpt":"SQL 基础笔记 对 SQL 语句的基础复习","text":"SQL 基础笔记 对 SQL 语句的基础复习 开始学习之前，我们需要正确安装 MySQL， 各系统的安装稍有差异，这里不另行赘述，自行百度正确的安装姿势。以下内容以我的环境为主： 系统：Mac OS 包管理工具：Homebrew MySQL 版本：8.0.16 连接 MySQL确认正确安装在终端输入 1mysql --version 若可以正确打印安装的 MySQL 版本，则安装成功 启动/终止服务Mac 下使用 Homebrew 包管理工具可以运行 1brew services start mysql 和 1brew services restart mysql 其他系统可以尝试 1net start mysql5 和 1net stop mysql5 或者是 1service mysql start 和 1service mysql stop 来进行启动和关闭服务。 连接到服务器确保服务启动状态下终端运行 1mysql -uroot -p 以上命令 mysql 代表客户端命令，-u 后边跟连接数据库的用户，这里是 root，-p 表示输入密码，回车后输入密码即可。MySQL 默认用户为 root，密码为空，如果没有修改，直接回车就可以连接到 MySQL 服务器，也可以使用下面的命令实现快速登录： 1mysql -uroot DDL 语句 数据定义语言，简单来说，就是对数据库的内部对象进行创建、删除、修改等操作的语言。 创建数据库语法： 1CREATE DATABASE dbname; 现在，我们来创建一个数据库 demo: 1create database demo; 注意，如果数据库名称已存在，系统将不再允许创建同名的数据库，这时，我们可以删除已存在的数据库或另取一个名称再创建。 这样，一个数据库就创建成功了。我们可以通过以下命令查看： 1show databases; // 不要忘了分号(;) 注意，是 databases 不是 database；还有 sql 以分号结束。 查看数据库之后，可以选择要操作的数据库，使用命令： 1USE dbname; 这里我们查看刚刚创建的数据库 demo: 1use demo; 然后再查看数据库中创建的所有数据表： 1show tables; 因为我们创建的是一个空数据库，里面还没有表。 删除数据库语法： 1DROP DATABASE dbnaem; 这里我们删除刚创建的 demo 数据库： 1drop database demo; 创建表语法： 12345CREATE TABLE tablename( name type constraints, name type constraints, ....); constraints （约束）可以为空，不写就行。一般的约束条件有：主键约束（primary key），外键约束（foreign key），唯一约束（unique），非空约束（not null）和默认值（default） 约束 描述 主键约束（primary key） 主键约束列不允许重复，也不允许出现空值。相当于唯一约束+非空约束，每个表最多只允许一个主键 外键约束（foreign key） 外键约束是保证一个或两个表之间的参照完整性，外键是构建于一个表的两个字段或是两个表的两个字段之间的参照关系 唯一约束（unique） 指定table的列或列组合不能重复，保证数据的唯一性 非空约束（not null） 确保当前列的值不为空值 默认值（default） 可以设置一个当前字段的默认值 现在我们实际创建一个新的表，首先，创建一个数据库: 1create database emp; 然后，使用它： 1use emp; 接下来，就是创建表： 1create table emp(ename varchar(10), hiredate date, sal decimal(10, 2), deptno int(2)); 这时，我们便创建了一张新表（emp)，我们可以查看表的定义： 1DESC tablename; 即 1desc emp; 如果需要更全面的表信息，可以使用 SQL 语句： 1SHOW CREATE TABLE tablename \\G; 我们来尝试一下： 1show create table emp \\G 这里的”\\G“的含义是使记录能够按照字段竖向排列，以便更好地显示内容，也可以选择不写，不过一旦选择传入，切记是大写的，不然无效。 删除表语法： 1DROP TABLE tablename; 可自行尝试。 修改表 对于已经创建好的表，尤其是已经有大量数据的表，如果需要做一些结构上的改变，可以先将表删除（drop），然后再重新定义表，这样做没有问题，但是就必须重新对数据进行加载，因此，大多数情况下，表结构的更改都使用 alter table 语句，以下是一些常用命令。 修改表类型 语法如下： 1ALTER TABLE tablename MODIFY [COLUMN] column_definition [FIRST|AFTER col_name]; 接下来我是实际进行尝试： 1alter table emp modify ename varchar(20); 重新查看表结构，可以发现我们把 ename 字段的类型从 varchar(10) 修改成了 varchar(20)。 1desc emp; 增加表字段 语法如下： 1ALTER TABLE tablename ADD [COLUMN] column_definition [FIRST|AFTER col_name]; 例如，我们增加一个字段 age，类型为 int(3)： 1alter table emp add age int(3); 可以自己利用desc语句查看一下表结构的变化。 删除表字段 语法如下： 1ALTER TABLE tablename DROP [COLUMN] col_name; 以下，我们删除 age 字段： 1alter table emp drop age; 自行查看表结构的变化。 更改字段名 语法如下： 1ALTER TABLE tablename CHANGE [COLUMN] old_col_name column_definition [FIRST|AFTER col_name]; 我们先将刚才删除的字段添加回来： 1alter table emp add age int(3); 然后修改名称为 age_1，同时修改字段类型为 int(4): 1alter table emp change age age_1 int(4); 查看表结构的变化： 1desc emp; 注意：change 和 modify 都可以修改表的定义，不同的是 change 后面需要写两次列名，但 change 的优点是可以修改列名称， modify 则不能。 修改字段排列顺序 前面介绍的方法都有一个可选项， first|after cloumn_name，这个选项可以修改字段在表中的位置。 add 默认是加在表的最后位置，change 和 modify 默认不会改变字段的位置。 下面我们将添加 birth 字段在 ename 之后： 1alter table emp add birth date after ename; 自行查看。 更改表名 语法如下： 1ALTER TABLE tablename RENAME [TO] new_name; 我们将表名 emp 改为 emp1: 1alter table emp reanme emp1; 查看变化： 1show tables; DML 语句 DML 即数据操作语句，是指对数据库中表记录的操作，主要包括插入(insert)、更新(update)、删除(delete)和查询(select)，是开发人员日常使用最频繁的操作。 开始之前，先将表进行调整，将表名改回 emp，并且删除 age_1 字段： 12alter table emp1 rename emp;alter table emp drop age_1; 插入记录语法如下： 1INSERT INTO tablename (field_1, field_2,..., field_n) VALUES(value_1, value_2,...,value_n); 实际尝试： 1insert into emp (ename, birth, hiredate, sal, deptno) values('akashi', '1997-09-28', '2019-08-01', '5000', 01); 也可以不指定字段名，但是 value 后面的顺序要和字段的排列顺序一致： 1insert into emp values('asuka', '1998-08-10', '2019-08-01', '5000', 1); 可以通过以下语法进行查看插入情况： 1select * from emp; 更新记录语法如下： 1UPDATE tablename SET field_1 = value_1, field_2 = value_2,...,field_n = value_n [WHERE CONDITION] 例如: 1update emp set sal = '6000' where ename = 'asuka'; 查看： 1select * from emp; 删除记录语法如下： 1DELETE FROM tablename [WHERE CONDITION] 例如： 1delete from emp where ename = 'akashi'; 使用别名的一个参考例子： 1delete a, b from emp a, dept b where a.depton = b.depton and a.depton = 3; 查询记录其实上面有使用过最基础的查询，语法如下： 1SELECT * FROM tablename [WHERE CONDITION] 即： 1select * from emp; * 表示全部，等价于： 1select ename, birth, hiredate, sal, deptno from emp; 注意：考虑到性能和效率问题，在大型的数据库查询中，并不提倡使用 * 来查询，要养成良好的习惯。 查询不重复的记录 有时候需要将表中的记录去掉重复后显示出来，可以用 distinct 关键字来实现。 一个例子： 1select distinct depno from emp; 条件查询 在很多情况下，不需要查询全部记录，而只是需要根据限定条件来查询一部分的数据，用 where 来实现。 一个例子： 1select ename, birth, hiredate, sal, deptno from emp where deptno = 1; 排序和限制 当需要取出按照某个字段进行排序后的记录结果集，可以使用关键字 order by 来实现。 语法如下： 1SELECT * FROM tablename [WHERE CONDITION] [ORDEY BY field_1 [DESC|ASC],...,field_2 [DESC|ASC]] 其中，desc 和 asc 排序顺序关键字， desc 表示按照字段进行降序排序， asc 表示升序排序，如果不写，默认是升序。 一个例子： 1select ename, birth, hiredate, sal, deptno from emp order by sal; 稍微再复杂一点：(先按部门升序，再按奖金降序排序) 1select ename, birth, hiredate, sal, deptno from emp order by deptno, sal desc; 对于排序后的记录，如果只希望显示部分，可以使用 limit 关键字。 语法如下： 1SELECT ... [LIMIT offset_start, row_count] 其中， offset_start 表示记录的起始偏移量， row_count 表示显示的行数。默认起始偏移量为 0，这时，实际显示的就是前 n 条记录。 具体例子： 1select ename, birth, hiredate, sal, deptno from emp order by sal limit 3; 这里显示了 3 条记录。 另一个例子： 1select ename, birth, hiredate, sal, deptno from emp order by sal limit 1, 3; 表示排序后从第2条记录开始，显示3条记录。 limit 经常和 order by 一起配合使用，来进行记录的分页显示。 聚合 语法如下： 123456SELECT [field_1, field_2,...,field_n] fun_nameFROM tablenaem[WHERE where_contition][GROUP BY field_1, field_2,...field_n[WITH ROLLUP]][HAVING where_contition] 参数说明： fun_naem 表示要做的聚合参数，也就是聚合函数，常用的有 sum-求和, count(*)-记录数, max-最大值, min-最小值。 group by 关键字表示要进行分类聚合的字段。 with rollup 是可选字段（在[]里面表示可选参数），表明是否对分类聚合后的结果进行再汇总。 having 关键字表示对分类后的结果再进行条件的过滤。 注意：having 和 where 的区别在于， having 是对聚合后的结果进行再过滤，而 where 是在聚合前就对记录进行过滤， 如果逻辑允许，我们尽可能的用 where 先过滤记录， 因为这样结果集会减小，提高聚合效率，最后再根据情况看是否用 having 进行再过滤。 统计人数大于 1 的部门： 1select deptno count(1) from emp group by deptno having count(1) &gt; 1; 再看一些具体的函数： 1select sum(sal), max(sal), min(sal) from emp; 表连接 当需要同时显示多个表中的字段时，就可以通过表连接来实现。表连接分为外连接和内连接，他们最主要的区别是，内连接仅选出两张表中相互匹配的记录；而外连接会选出其他不匹配的记录。我们最常用的是内连接。 一个例子(内连接)： 1select ename, deptname from emp.dept where emp.deptno = dept.deptno; 外连接又分为左连接和右连接： 左连接： 包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录。 右连接： 包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录。 左连接： 1select ename, deptname from emp left join dept on emp.deptno = dept.deptno; 右连接： 1select ename, deptname from emp right join emp on dept.deptno = emp.deptno; 两者效果相同，可以相互转化。 子查询 有些情况下，查询时需要的条件是另外一个 select 语句的结果，这个时候，就需要子查询。用于子查询的关键字主要包括： in, not in, =, !=, exists, not exists 等。 一个例子： 1select * from emp where deptno in (select deptno from dept); 如果子查询的记录唯一，还可以用 = 代替 in: 1select * from emp where deptno = (select deptno from dept); 记录联合 我们常常需要将两个表的数据按一定的查询条件查询出来以后，将结果合并到一起显示出来，这时候，需要 union 和 union all 关键字来实现。 语法如下： 123456SELECT * FROM t1UNION | UNION ALLSELECT * FROM t2...UNION | UNION ALLSELECT * FROM tn union 和 union all 的主要区别是 union all 是直接把结果合并在一起，而 union 是在 union all 的基础上进行了一次 distinct，去除了重复的记录。 一个例子： 123select deptno from empunion allselect deptno from dept; 去重： 123select deptno from empunion select deptno from dept; DCL 语句 DCL 即数据控制语句，主要是DBA用来管理系统中的对象权限时使用，一般开发人员很少使用。 创建数据库用户，添加权限1create user 'akashi'@'localhost' identified by '123'; 1grant select, insert on emp.* to 'akashi'@'localhost'; 收回权限1revoke insert on emp.* from 'akashi'@'localhost'; 实战一些实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768-- 1. 查询第三个字母为A的员工记录select ename from emp where ename like '__A%';-- 2. 输出员工人数大于等于5的部门select deptno, count(empno) from emp group by deptno having count(empno) &gt;= 5;-- 3. 以部门编号为统计单位，统计(聚合函数)select deptno, count(empno), max(sal), min(sal), avg(sal)from empgroup by deptno;-- 4. 查询没有奖金的员工信息-- select * from emp where comm = 'NULL'select * from empwhere comm = 0 or comm is NULL;-- 如果字段为空，字段置零，如果为零，同样置零select * from emp where ifnull(comm, 0) = 0;-- 5. 不重复的部门编号select distinct deptno from emp-- 6. 查询工资和奖金的和大于2000的员工信息(注意：奖金为空时，不参与运算)select * from emp where ifnull(sal, 0) + ifnull(comm, 0) &gt; 2000-- 7. 公式化：分页查询，n为开始的下标，m为显示的个数select * from emp limit n, m;-- select * from emp limit （当前页码数-1）* 每页显示条数, 每页显示条数(实时分页，不再利用缓存，满足高并发的数据实时变化)select * from emp limit （index-1）* pageSize, pageSize;-- 8. 添加-- 语法规则：-- 主键（自增长）-- 字段的类型-- 字段的长度-- 日期（表单传入（应用程序）、系统传入、数据库获取）-- 实体间的依赖关系-- 添加字段顺序insert into emp(empno, ename, job, hiredate, sal, comm, deptno) values(9999, 'AKASHI', 'STUDENT', now(), 5000.56, 1000, 40);insert into emp(ename, job, hiredate, sal, comm, deptno) values('AKASHI', 'STUDENT', now(), 5000.56, 1000, 40);delete from emp where empno = 10000;-- 增删改===&gt; 注意事务的提交和回滚-- 所有的关系型数据库，存在自动提交和手动提交；Oracle需要手动提交，MySQL自动提交，无需commit，rollback；-- 9. 删除-- 考虑临界值-- 先检索语句确认是否满足要求，再删除select * from emp where sal &gt;= 800 and sal &lt;= 3000;delete from emp where sal &gt;= 800 and sal &lt;= 3000;delete from emp where sal between 800 and 3000;-- 10. 更新-- 先检索-- 考虑非空update emp set sal = ifnull(sal, 0) + 1000, comm = ifnull(comm, 0) + 500where ifnull(comm,0) = 0;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://akashigakki.github.io/tags/MySQL/"}]},{"title":"正则匹配食用指南","slug":"Regular/regex","date":"2019-08-01T16:00:00.000Z","updated":"2020-10-06T11:15:40.720Z","comments":true,"path":"2019/08/02/Regular/regex/","link":"","permalink":"http://akashigakki.github.io/2019/08/02/Regular/regex/","excerpt":"正则匹配 正则表达式是处理字符串的强大工具，它有自己的特定语法结构，可以实现字符串的检索、替换、匹配验证等功能。","text":"正则匹配 正则表达式是处理字符串的强大工具，它有自己的特定语法结构，可以实现字符串的检索、替换、匹配验证等功能。 在线正则表达式测试工具 https://regex101.com/ https://regexper.com/ http://tool.oschina.net/regex/ 常用匹配规则 模式 规则 \\w 匹配字母、数字及下划线 \\W 匹配不是字母、数字及下划线的字符 \\s 匹配任意空白字符，等价于[\\t\\n\\r\\f] \\S 匹配任意非空白字符 \\d 匹配任意数字，等价于[0-9] \\D 匹配任意非数字的字符 \\A 匹配字符串开头 \\Z 匹配字符串结尾，如果存在换行，只匹配到换行前的字符串结束 \\z 匹配字符串结尾，如果存在换行，同时还会匹配换行符 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配一行字符串的开头 $ 匹配一行字符串的结尾 . 匹配任意字符，除了换行符 [...] 用来表示一组字符，单独列出，如[amk]，匹配a、m或k [^...] 匹配不在[]中的字符，如[^abc]，匹配除了a、b、c以外的字符 * 匹配0个或多个表达式 + 匹配1个或多个表达式 ? 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面的表达式 {n,m} 匹配n到m次由前面正则表达式定义的片段，贪婪方式 alb 匹配a或b () 匹配括号内的表达式，也表示一个组 以上看不懂也没关系，接下来逐一用实例介绍。 . 表示匹配任意单个字符 代替任意一个字符，并且匹配多次 *（贪婪） 表示匹配任意0个或多个字符 以下匹配到所有的字符a，匹配多次： a* [] 表示匹配括号中的任意字符 以下匹配到任意0到9的数字，匹配多次： [0-9] 123456789eg:[abc] 匹配字符a、b或者c [a-z] 匹配任何字母 [0-9] 匹配任何数字 [0-9]* 匹配任何数量的任何数字 [a-z]* 匹配任何数量的任何字母 ^ 表示匹配字符或字符串开头，有时还会匹配文档的起始位置 以下匹配以abc开头的字符串，匹配一次： ^abc $ 表示匹配字符或字符串的结尾 以下匹配以a结尾的字符串，匹配一次： a$ +（懒惰） 表示匹配任意1个或多个字符 以下匹配1个或多个a，匹配多次： a+ ?（占有） 表示匹配任意0个或1个字符 以下匹配0个或1个a，匹配多次： a? {n} 表示重复n次 以下匹配重复2次的a，匹配多次： a{2} {n,m} 表示重复n到m次 以下匹配重复2到3次的a，匹配多次： a{2,3} a|b 表示匹配a或b 以下匹配到a或b，匹配多次： a|b () 表示分组 \\b 表示匹配任意字符边界 以下匹配在边界的a（前面或后面出现空格），匹配多次： \\ba\\b \\d 表示匹配任意数字 以下匹配到任意一个数字，匹配多次： \\d \\w 表示匹配数字、字母及下划线 以下匹配任意数字、字母、下划线，匹配多次： \\w \\s 表示匹配空格 以下匹配任意空格，匹配多次： 一些实例Email^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ URL[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 密码 以字母开头，长度在6~18之间，只能包含字母、数字和下划线 ^[a-zA-Z]\\w{5,17}$ 日期格式^\\d{4}-\\d{1,2}-\\d{1,2}","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://akashigakki.github.io/tags/正则匹配/"}]},{"title":"Emmet 使用指南","slug":"Emmet/emmet","date":"2019-07-29T16:00:00.000Z","updated":"2020-10-06T11:15:40.718Z","comments":true,"path":"2019/07/30/Emmet/emmet/","link":"","permalink":"http://akashigakki.github.io/2019/07/30/Emmet/emmet/","excerpt":"Emmet 使用指南 Emment 是一个可以极大程度提高前端开发效率的工具。它提供了一种十分简练的语法规则，生成对应的 HTML 结构和 CSS 代码。","text":"Emmet 使用指南 Emment 是一个可以极大程度提高前端开发效率的工具。它提供了一种十分简练的语法规则，生成对应的 HTML 结构和 CSS 代码。 语法规则 首先，你需要记住的是键入缩写后使用 Tab 键进行自动补全，生成完整的 HTML 标签。 输入 ! 或者 html:5 按下 tab 键就可以生成一个基本的 HTML 结构： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;!-- 语言设置 --&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- 默认字符集 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 设置默认缩放 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 兼容IE8设置 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 当然，一个最简单的文档结构还可以更简化： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Emmet&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 接下来，便可以进行更多的探索，以下以 E 指代一个 HTML 标签，通过 Emmet 语法，可以实现： 12345678E 代表HTML标签。E#id 代表id属性。E.class 代表class属性。E[attr=foo] 代表某一个特定属性。E&#123;foo&#125; 代表标签包含的内容是foo。E&gt;N 代表N是E的子元素。E+N 代表N是E的同级元素。E^N 代表N是E的上级元素。 一个比较综合的例子： 1#page&gt;div.logo+ul#navigation&gt;li*5&gt;a&#123;Item $&#125; 按下 tab 你就会得到： 12345678910&lt;div id=\"page\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;ul id=\"navigation\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;Item 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Item 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Item 3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Item 4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;Item 5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 基础用法元素(标签) 键入标签名称，按下 tab 键，就会得到对应的标签元素。 1div 1&lt;div&gt;&lt;/div&gt; 1h3 1&lt;h3&gt;&lt;/h3&gt; class 使用点(.)生成 class 属性。 1div.page 1&lt;div class=\"page\"&gt;&lt;/div&gt; 1p.info 1&lt;p class=\"info\"&gt;&lt;/p&gt; 1.header 1&lt;div class=\"header\"&gt;&lt;/div&gt; 注意：默认不写前面的标签会自动生成一个 div 标签。 id 使用 # 生成 id 标签。 1div.footer 1&lt;div id=\"footer\"&gt;&lt;/div&gt; 一个比较复杂的例子： 1div#header+div.page+div#footer.class1.class2.class3 123&lt;div id=\"header\"&gt;&lt;/div&gt;&lt;div class=\"page\"&gt;&lt;/div&gt;&lt;div id=\"footer\" class=\"class1 class2 class3\"&gt;&lt;/div&gt; a 使用 : 可以生成一些特殊的属性。 1234567891011121314151617181920212223a:link =&gt; &lt;a href=\"http://\"&gt;&lt;/a&gt;a:blank =&gt; &lt;a href=\"http://\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;/a&gt;inp =&gt; &lt;input type=\"text\" name=\"\" id=\"\"&gt;input =&gt; &lt;input type=\"text\"&gt;input:b 或者 input:button =&gt; &lt;input type=\"button\" value=\"\"&gt;input:c 或者 input:checkbox =&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;input:email =&gt; &lt;input type=\"email\" name=\"\" id=\"\"&gt;input:f 或者 input:file =&gt; &lt;input type=\"file\" name=\"\" id=\"\"&gt;input:h 或者 input:hidden =&gt; &lt;input type=\"hidden\" name=\"\"&gt;input:p 或者 input:password =&gt; &lt;input type=\"password\" name=\"\" id=\"\"&gt;input:r =&gt; &lt;input type=\"radio\" name=\"\" id=\"\"&gt;input:s 或者 input:submit =&gt; &lt;input type=\"submit\" value=\"\"&gt;form =&gt; &lt;form action=\"\"&gt;&lt;/form&gt;form:get =&gt; &lt;form action=\"\" method=\"get\"&gt;&lt;/form&gt;form:post =&gt; &lt;form action=\"\" method=\"post\"&gt;&lt;/form&gt;label =&gt; &lt;label for=\"\"&gt;&lt;/label&gt;select =&gt; &lt;select name=\"\" id=\"\"&gt;&lt;/select&gt;select:d =&gt; &lt;select name=\"\" id=\"\" disabled=\"disabled\"&gt;&lt;/select&gt;bq =&gt; &lt;blockquote&gt;&lt;/blockquote&gt;btn 或者 button =&gt; &lt;button&gt;&lt;/button&gt;btn:d =&gt; &lt;button disabled=\"disabled\"&gt;&lt;/button&gt;btn:r =&gt; &lt;button type=\"reset\"&gt;&lt;/button&gt;btn:s =&gt; &lt;button type=\"submit\"&gt;&lt;/button&gt; 子标签生成 使用 &gt; 生成子标签。 1div&gt;ul&gt;li 12345&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 同级标签生成 使用 + 生成同级标签。 1div+p+bq 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt; 父级标签生成 使用 ^ 生成父级标签。 1div+div&gt;p&gt;span+em 1234&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt; 一个实例： 1div+div&gt;p&gt;span+em^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt; 更复杂一点的用法： 1div+div&gt;p&gt;span+em^^^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;/blockquote&gt; 乘法 使用 * 生成多个标签。 1ul&gt;li*3 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 分组 使用 () 进行分组。 1div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 一个比较复杂的例子： 1(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 属性 使用 [] 自定义属性 1a[href='#' data-title='customer' target='_blank'] 1&lt;a href=\"#\" data-title=\"customer\" target=\"_blank\"&gt;&lt;/a&gt; 编号 使用 $ 进行编号 1ul&gt;li.item$*3 12345&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt;&lt;/ul&gt; 可以$连续使用多个用零填充数字： 1ul&gt;li.item$$$*3 12345&lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt;&lt;/ul&gt; 使用 @ 修改器，可以改变编号起始值。 @N 改变起始值： 1ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt;&lt;/ul&gt; 文本 使用 {} 添加文本。 1a&#123;Click me&#125; 1&lt;a href=\"\"&gt;Click me&lt;/a&gt; 进阶用法随机填充文本 在开发的过程中，常有需要一些文本填充位置占位。 Emmet 内置了 Lorem Ipsum 功能来实现。loremN 或者 lipsumN ，N 表示生成的单词数，正整数。 1lorem 1Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas iusto, incidunt, est facilis quisquam possimus, aliquid provident aperiam sunt numquam a et. Asperiores distinctio explicabo quibusdam accusamus nesciunt, eius autem! 1(p&gt;lorem4)*3 或者： 1p*3&gt;lorem4 123&lt;p&gt;Lorem ipsum dolor sit.&lt;/p&gt;&lt;p&gt;Voluptatibus cumque quisquam facere!&lt;/p&gt;&lt;p&gt;Error incidunt fugiat explicabo?&lt;/p&gt;","categories":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"开发技巧","slug":"开发技巧","permalink":"http://akashigakki.github.io/tags/开发技巧/"}]},{"title":"H5 笔记整理","slug":"html5/HTML5","date":"2019-07-28T16:00:00.000Z","updated":"2020-10-06T11:15:40.740Z","comments":true,"path":"2019/07/29/html5/HTML5/","link":"","permalink":"http://akashigakki.github.io/2019/07/29/html5/HTML5/","excerpt":"H5 笔记整理 整理复习 H5 的基础内容。","text":"H5 笔记整理 整理复习 H5 的基础内容。 将 HTML5 元素定义为块元素 HTML5 定义了 8 个新的 HTML 语义（semantic） 元素。所有这些元素都是 块级 元素。 通过设置 CSS 的 display 属性值为 block，让旧版本的浏览器正确显示这些元素： 123header, section, footer, aside, nav, main, article, figure &#123; display: block; &#125; 为 HTML 添加新元素通过设置块级元素，还可以自定义 HTML 新元素： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Custom&lt;/title&gt; &lt;script&gt; document.createElement(\"ele\"); &lt;/script&gt; &lt;style&gt; ele &#123; display: block; background-color: yellow; padding: 50px; font-family: 'plantc' &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ele&gt;自定义元素&lt;/ele&gt;&lt;/body&gt;&lt;/html&gt; HTML5 新元素 &lt;canvas&gt; 新元素 标签 描述 &lt;canvas&gt; 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 新多媒体元素 标签 描述 &lt;audio&gt; 定义音频内容 &lt;video&gt; 定义视频（video 或者 movie） &lt;source&gt; 定义多媒体资源 &lt;video&gt; 和 &lt;audio&gt; &lt;embed&gt; 定义嵌入的内容，比如插件。 &lt;track&gt; 为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道。 新表单元素 标签 描述 &lt;datalist&gt; 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 &lt;keygen&gt; 规定用于表单的密钥对生成器字段。 &lt;output&gt; 定义不同类型的输出，比如脚本的输出。 新的语义和结构元素 HTML5 提供了新的元素来创建更好的页面结构： 标签 元素 &lt;article&gt; 定义页面独立的内容区域。 &lt;aside&gt; 定义页面的侧边栏内容。 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向设置。 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮 &lt;details&gt; 用于描述文档或文档某个部分的细节 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含 details 元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;footer&gt; 定义 section 或 document 的页脚。 &lt;header&gt; 定义了文档的头部区域 &lt;mark&gt; 定义带有记号的文本。 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。 &lt;nav&gt; 定义导航链接的部分。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;ruby&gt; 定义 ruby 注释（中文注音或字符）。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。 &lt;rp&gt; 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 &lt;section&gt; 定义文档中的节（section、区段）。 &lt;time&gt; 定义日期或时间。 &lt;wbr&gt; 规定在文本中的何处适合添加换行符。 需要记住经常使用的标签：&lt;article&gt;, &lt;aside&gt;, &lt;footer&gt;, &lt;header&gt;, &lt;nav&gt;, &lt;section&gt;。 HTML5 Canvas &lt;canvas&gt; 标签定义图形，是一个图形容器，用于图形的绘制，通过脚本 (通常是JavaScript)来完成。 创建一个画布（Canvas）注意: 默认情况下 &lt;canvas&gt; 元素没有边框和内容。 1&lt;canvas id=\"canvas\" style=\"border: 1px solid black\"&gt;&lt;/canvas&gt; 使用 JavaScript 来绘制图像canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成： 1234567// 找到canvas元素var c = document.getElementById(\"canvas\");// 创建context对象var ctx = c.getContext(\"2d\");// 设置颜色和填充方式ctx.fillStyle = \"red\";ctx.fillRect(0, 0, 150, 150); getContext(&quot;2d&quot;) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。 fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。 Canvas 坐标canvas 是一个二维网格。 canvas 的左上角坐标为(0,0)` fillRect(0, 0, 150, 150) 意为从(0,0)左上角开始，填充一个150*150的矩形。画布默认为300*150，如果超出了画布大小，最大以画布为界，溢出部分隐藏。 Canvas 路径使用canvas画线： moveTo(x,y) 定义线条开始坐标 lineTo(x,y) 定义线条结束坐标 123456var c = document.getElementById(\"canvas\");var ctx = c.getContext(\"2d\");// 定义开始坐标(0,0)，结束坐标(200,100)，然后使用stroke() 方法绘制线条ctx.moveTo(0, 0);ctx.lineTo(200, 100);ctx.stroke(); 在canvas中绘制圆形： 1arc(x, y, r, start, stop) 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Circle&lt;/title&gt; &lt;style&gt; #circle &#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"circle\" width=\"200px\" height=\"200px\"&gt;&lt;/canvas&gt;&lt;script&gt; // 创建context对象 var ctx = document.getElementById(\"circle\").getContext(\"2d\"); // 开始一条路径，或重置当前的路径 ctx.beginPath(); // 设置线条宽度 ctx.lineWidth = \"2\"; // 设置线条颜色 ctx.strokeStyle = \"pink\"; // 绘制圆 arc(x, y, r, start, stop) ctx.arc(100, 100, 90, 0, 2*Math.PI); ctx.stroke();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Canvas 文本使用 canvas 绘制文本，重要的属性和方法如下： font 定义字体 fillText(text, x, y) 在 canvas 上绘制实心的文本 strokeText(text, x, y) 在 canvas 上绘制空心的文本 实心的文本： 1234var c = document.getElementById(\"canvas\");var ctx = c.getContext(\"2d\");ctx.font = \"30px Arial\";ctx.fillText(\"Akashi\", 10, 50); 空心的文本： 1234var c = document.getElementById(\"canvas\");var ctx = c.getContext(\"2d\");ctx.font = \"30px Arial\";ctx.strokeText(\"Akashi\", 10, 50); Canvas 渐变 createLinearGradient(x, y, x1, y1) 创建线条渐变 createRadialGradient(x, y, r, x1 , y1, r1) 创建一个径向/圆渐变 在使用渐变对象时，必须使用两种或两种以上的停止颜色，addColorStop() 方法指定颜色停止，参数使用坐标来描述，可以是 0 至 1 。 线性渐变： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Gradient&lt;/title&gt; &lt;style&gt; #canvas &#123; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; var ctx = document.getElementById(\"canvas\").getContext(\"2d\"); // 创建 var grd = ctx.createLinearGradient(0, 0, 200, 200); grd.addColorStop(0, \"red\"); grd.addColorStop(1, \"white\"); // 填充 ctx.fillStyle = grd; ctx.fillRect(0, 0, 300, 150)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 径向\\圆渐变： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Gradient&lt;/title&gt; &lt;style&gt; #gradient &#123; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"gradient\"&gt;&lt;/canvas&gt;&lt;script&gt; var ctx = document.getElementById(\"gradient\").getContext(\"2d\"); var grd = ctx.createRadialGradient(150, 75, 0, 150, 75, 100); grd.addColorStop(0, \"red\"); grd.addColorStop(1, \"white\"); ctx.fillStyle = grd; ctx.fillRect(0, 0, 300, 150);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML5 内联 SVG HTML5 支持内联 SVG。 什么是 SVG？SVG 指可伸缩矢量图形 (Scalable Vector Graphics)SVG 用于定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失SVG 是万维网联盟的标准 SVG 优势与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于： SVG 图像可通过文本编辑器来创建和修改SVG 图像可被搜索、索引、脚本化或压缩SVG 是可伸缩的SVG 图像可在任何的分辨率下被高质量地打印SVG 可在图像质量不下降的情况下被放大 Canvas 与 SVG 的比较 Canvas SVG 依赖分辨率 不依赖分辨率 不支持事件处理器 支持事件处理器 弱的文本渲染能力 最适合带有大型渲染区域的应用程序（比如谷歌地图） 能够以 .png 或 .jpg 格式保存结果图像 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 不适合游戏应用 HTML5 拖放（Drag 和 Drop）设置元素可拖放1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Drag_Drop&lt;/title&gt; &lt;style&gt; img &#123; width: 100px; height: auto; border: 1px solid black; margin: 10px; &#125; #container &#123; border: 1px solid black; width: 120px; min-height: 170px; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt;&lt;/div&gt; &lt;img id=\"asuka\" src=\"./asuka.jpg\" alt=\"asuka\" draggable=\"true\" ondragstart=\"drag(event)\"&gt;&lt;script&gt; function allowDrop(event) &#123; event.preventDefault(); &#125; function drag(event) &#123; event.dataTransfer.setData(\"Text\", event.target.id); &#125; function drop(event) &#123; event.preventDefault(); var data = event.dataTransfer.getData(\"Text\"); event.target.appendChild(document.getElementById(data)); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 首先，要设置元素是可以被拖放的，把 draggable 属性设置为 true ： 1&lt;img draggable=\"true\"&gt; 定义元素被拖动时事件 ondragstart setData() ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。 dataTransfer.setData() 方法设置被拖数据的数据类型和值： 123function drag(ev) &#123; ev.dataTransfer.setData(\"Text\", ev.target.id);&#125; 设置元素拖放后事件ondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： 1ev.preventDefault() 进行放置当放置被拖数据时，会发生 drop 事件 12345function drop(ev) &#123; ev.preventDefault(); var data = ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data));&#125; 注释： 调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(&quot;Text&quot;) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 被拖数据是被拖元素的 id (&quot;asuka&quot;) 把被拖元素追加到放置元素（目标元素）中 HTML5 Video(视频)12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Video&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id=\"video\" width=\"500px\" controls&gt; &lt;source src=\"./gakki.mp4\" type=\"video/mp4\"&gt; &lt;/video&gt; &lt;div&gt; &lt;button onclick=\"playControl()\"&gt;播放/暂停&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var video = document.getElementById(\"video\"); function playControl() &#123; if (video.paused) &#123; video.play(); &#125; else &#123; video.pause(); &#125; &#125;&lt;/script&gt;&lt;/html&gt; 可选属性 属性 值 描述 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 height pixels 设置视频播放器的高度。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 muted muted 如果出现该属性，视频的音频输出为静音。 poster URL 规定视频正在下载时显示的图像，直到用户点击播放按钮。 preload auto metadata none 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay“，则忽略该属性。 src URL 要播放的视频的 URL。 width pixels 设置视频播放器的宽度。 HTML5 Audio (音频)12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Audio&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;audio id=\"audio\" controls&gt; &lt;source src=\"./aimer.mp3\"&gt; &lt;/audio&gt; &lt;div&gt; &lt;button onclick=\"playControl()\"&gt;播放/暂停&lt;/button&gt; &lt;/div&gt;&lt;script&gt; var audio = document.getElementById(\"audio\"); // 设置自动播放 audio.play(); function playControl() &#123; if (audio.paused) &#123; audio.play(); &#125; else &#123; audio.pause(); &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可选属性 属性 值 描述 autoplay autoplay 如果出现该属性，则音频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示音频控件（比如播放/暂停按钮）。 loop loop 如果出现该属性，则每当音频结束时重新开始播放。 muted muted 如果出现该属性，则音频输出为静音。 preload auto metadata none 规定当网页加载时，音频是否默认被加载以及如何被加载。 src URL 规定音频文件的 URL。 HTML5 语义元素 语义元素可以清楚地描述标签的意义，方便开发者的开发和浏览器的识别。 &lt;section&gt; &lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 &lt;article&gt; &lt;article&gt; 标签定义独立的内容。 &lt;nav&gt; &lt;nav&gt; 标签定义导航链接的部分。 &lt;aside&gt; &lt;aside&gt; 标签定义页面主区域内容之外的内容（比如侧边栏）。 &lt;header&gt; &lt;header&gt;元素描述了文档的头部区域，主要用于定义内容的介绍展示区域。 &lt;footer&gt; &lt;footer&gt; 元素描述了文档的底部区域。 &lt;figure&gt; 和 &lt;figcaption&gt; &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figure&gt; 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 &lt;figcaption&gt; 标签定义 &lt;figure&gt; 元素的标题. &lt;figcaption&gt; 元素应该被置于 “figure“ 元素的第一个或最后一个子元素的位置。","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://akashigakki.github.io/categories/前端/HTML/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"H5","slug":"H5","permalink":"http://akashigakki.github.io/tags/H5/"}]},{"title":"Highmaps 地图数据可视化","slug":"highmap/highmaps","date":"2019-07-26T16:00:00.000Z","updated":"2020-10-06T11:15:40.739Z","comments":true,"path":"2019/07/27/highmap/highmaps/","link":"","permalink":"http://akashigakki.github.io/2019/07/27/highmap/highmaps/","excerpt":"Highmaps Highmaps 是继承自 Highcharts 的专门用于地图的图表插件。Highmaps 除了根据值展示地理区域色块外，还支持线段（可以表示公路，河流等）、点（城市，兴趣点等）等其他地理元素。","text":"Highmaps Highmaps 是继承自 Highcharts 的专门用于地图的图表插件。Highmaps 除了根据值展示地理区域色块外，还支持线段（可以表示公路，河流等）、点（城市，兴趣点等）等其他地理元素。 加载js文件1&lt;script src=\"https://img.hcharts.cn/highmaps/highmaps.js\"&gt;&lt;/script&gt; 如果需要和Highcharts 一起使用，则是引入 map.js 即可 12&lt;script src=\"https://img.hcharts.cn/highcharts/highcharts.js\"&gt;&lt;/script&gt;&lt;script src=\"https://img.hcharts.cn/highmaps/modules/map.js\"&gt;&lt;/script&gt; 加载地图数据文件 以下以加载中国地图为例： 通过加载 js 文件加载地图数据直接以 script 标签的形式加载文件，对应的取地图数据的方法是： 1234&lt;script src=\"https://data.jianshukeji.com/geochina/china.js\"&gt;&lt;/script&gt;&lt;script&gt; var mapdata = Highcharts.maps['cn/china'];&lt;/script&gt; 其中 Highcharts.maps[&#39;cn/china&#39;] 可以通过查看文件获得。 通过加载 json 文件加载地图数据由于跨域问题，所以加载 json 时需要用到 jsonp，这里直接用我们提供的接口即可 123$.getJSON('https://data.jianshukeji.com/jsonp?filename=geochina/china.json&amp;callback=?', function(data) &#123; var mapdata = data;&#125;); 地图数据集查询：https://img.hcharts.cn/mapdata/ 初始化地图123456// 初始化地图var map = Highcharts.mapChart('container', &#123; series: [&#123; mapData: mapdata, &#125;]&#125;); 加载数据并与地图关联加载地图数据并初始化图表后，可以将业务数据配置在 series.data 中，格式如下： 123456789101112series: [&#123; mapData: mapdata, data: [&#123; name: '北京', value: 2000, rank: 1 &#125;,&#123; name: '上海', value: 1500, rank: 2 &#125;]&#125;] 需要注意的是，设置完数据后，我们还需要指定数据与地图数据的关联属性，即 joinBy，例如： 12345678910111213series: [&#123; mapData: mapdata, data: [&#123; name: '北京', value: 2000, rank: 1 &#125;, &#123; name: '上海', value: 1500, rank: 2 &#125;], joinBy: 'name'&#125;] 这样，一个简单的中国地图图表数据就创建好了。 js 加载地图数据实例展示12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;China_Map&lt;/title&gt; &lt;!-- 引入 js 依赖 --&gt; &lt;script src=\"https://img.hcharts.cn/highcharts/highcharts.js\"&gt;&lt;/script&gt; &lt;script src=\"https://img.hcharts.cn/highmaps/modules/map.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt;&lt;!-- 通过 js 加载地图数据 --&gt;&lt;script src=\"https://data.jianshukeji.com/geochina/china.js\"&gt;&lt;/script&gt;&lt;script&gt; var mapdata = Highcharts.maps['cn/china']; // 初始化地图 var map = Highcharts.mapChart('container', &#123; // 添加标题 title: &#123; text: \"China_Map\" &#125;, // 图表配置 series: [&#123; mapData: mapdata, data: [&#123; name: '北京', value: 2000, rank: 1 &#125;, &#123; name: '上海', value: 1500, rank: 2 &#125;], joinBy: 'name' &#125;], // 去除水印 credits: &#123; enabled: false &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; json 加载地图数据实例展示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;China_Map&lt;/title&gt; &lt;!-- 引入 js 依赖 --&gt; &lt;script src=\"https://img.hcharts.cn/highcharts/highcharts.js\"&gt;&lt;/script&gt; &lt;script src=\"https://img.hcharts.cn/highmaps/modules/map.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\"&gt;&lt;/div&gt;&lt;!-- 通过 js 加载地图数据 --&gt;&lt;script src=\"https://data.jianshukeji.com/geochina/china.js\"&gt;&lt;/script&gt;&lt;!-- 加载 jQuery 依赖 --&gt;&lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;script&gt; $.getJSON('https://data.jianshukeji.com/jsonp?filename=geochina/china.json&amp;callback=?', function(mapdata) &#123; var map = Highcharts.mapChart('main', &#123; title: &#123; text: 'China_Map' &#125;, series: [&#123; mapData: mapdata, name: 'value', data: [&#123; city: '北京', value: 2000, rank: 1 &#125;,&#123; city: '上海', value: 1500, rank: 2 &#125;,&#123; city: '四川', value: '1300', rank: 3 &#125;,&#123; city: '重庆', value: '1300', rank: 3 &#125;,&#123; city: '广东', value: 1200, rank: 4 &#125;], joinBy: ['name', 'city'] &#125;], credits: &#123; enabled: false &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 尝试创建一个世界地图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Map_World&lt;/title&gt; &lt;script src=\"https://img.hcharts.cn/highcharts/highcharts.js\"&gt;&lt;/script&gt; &lt;script src=\"https://img.hcharts.cn/highmaps/modules/map.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt;&lt;!-- 地图数据集参考：https://img.hcharts.cn/mapdata/ --&gt;&lt;script src=\"https://img.hcharts.cn/mapdata/custom/world-eckert3-highres.js\"&gt;&lt;/script&gt;&lt;script&gt; var mapdata = Highcharts.maps['custom/world-eckert3-highres']; var map = Highcharts.mapChart('container', &#123; title: &#123; text: 'World_Map' &#125;, series: [&#123; mapData: mapdata, name: 'Country', data: [&#123; name: 'China', value: 1230 &#125;,&#123; name: 'United States of America', value: 1235 &#125;,&#123; name: 'Australia', value: 1245 &#125;,&#123; name: 'Russia', value: 1256 &#125;], joinBy: 'name' &#125;], credits:&#123; enabled:false &#125;, mapNavigation: &#123; enabled: true, // 开启地图导航器，默认是 false enableButtons: true, // 是否启用缩放按钮 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"},{"name":"Charts","slug":"前端/JavaScript/Charts","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/Charts/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"},{"name":"charts","slug":"charts","permalink":"http://akashigakki.github.io/tags/charts/"}]},{"title":"JQuery DOM 操作（下）","slug":"basic-jquery-dom-2/DOM","date":"2019-07-25T16:00:00.000Z","updated":"2020-10-06T11:15:40.727Z","comments":true,"path":"2019/07/26/basic-jquery-dom-2/DOM/","link":"","permalink":"http://akashigakki.github.io/2019/07/26/basic-jquery-dom-2/DOM/","excerpt":"JQuery DOM 操作（下）捕获 jQuery 拥有可操作 HTML 元素和属性的强大方法。","text":"JQuery DOM 操作（下）捕获 jQuery 拥有可操作 HTML 元素和属性的强大方法。 获取内容 text() 设置或返回所选元素的文本内容 html() 设置或返回所选元素的内容（包括 HTML 标记） 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;get value&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"text\"&gt; &lt;p&gt;这里是文本内容&lt;/p&gt; &lt;/div&gt; &lt;button id=\"btn-1\"&gt;text&lt;/button&gt; &lt;button id=\"btn-2\"&gt;html&lt;/button&gt;&lt;script&gt; $(function() &#123; $(\"#btn-1\").click(function() &#123; text = $(\"#text\").text(); console.log(text); &#125;); $(\"#btn-2\").click(function() &#123; html = $(\"#text\").html(); console.log(html); &#125;) &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; val() 设置或返回表单字段的值 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;get val&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" value=\"akashi\"&gt; &lt;button id=\"btn\"&gt;val&lt;/button&gt;&lt;script&gt; $(function() &#123; $(\"#btn\").click(function() &#123; value = $(\"input\").val(); console.log(value); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 获取属性 attr() 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;get attr&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"https://akashi_sai.gitee.io/\"&gt;点击访问&lt;/a&gt; &lt;button id=\"btn\"&gt;attribute&lt;/button&gt;&lt;script&gt; $(function() &#123; $(\"#btn\").click(function() &#123; attribute = $(\"a\").attr(\"href\"); console.log(attribute); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置 通过之前的四个方法，设置内容和属性。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;title&gt;set value&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"text-1\"&gt;这里是一个段落&lt;/p&gt; &lt;p id=\"text-2\"&gt;这里是另外一个段落&lt;/p&gt; &lt;input type=\"text\" value=\"akashi\"&gt; &lt;div&gt; &lt;button id=\"btn-1\"&gt;set text&lt;/button&gt; &lt;button id=\"btn-2\"&gt;set html&lt;/button&gt; &lt;button id=\"btn-3\"&gt;set val&lt;/button&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"#btn-1\").click(function() &#123; $(\"#text-1\").text(\"set text\"); &#125;); $(\"#btn-2\").click(function() &#123; $(\"#text-2\").html(\"set &lt;b&gt;html&lt;/b&gt;\"); &#125;) $(\"#btn-3\").click(function() &#123; $(\"input\").val(\"asuka\"); &#125;) &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;title&gt;set attr&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"https://akashi_sai.gitee.io/\"&gt;访问博客&lt;/a&gt; &lt;button&gt;set attr&lt;/button&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"a\").attr(&#123; \"href\": \"https://akashigakki.github.io/\", \"title\": \"GitHub Blog\" &#125;); title = $(\"a\").attr(\"title\"); $(\"a\").html(title); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 添加元素添加新的HTML元素 append() jQuery append() 方法在被选元素的结尾插入内容（仍在该元素的内部）。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;append&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;append&lt;/button&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;Item_1&lt;/li&gt; &lt;li&gt;Item_2&lt;/li&gt; &lt;li&gt;Item_3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"ul\").append(\"&lt;li&gt;追加列表项&lt;/li&gt;\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; prepend() jQuery prepend() 方法在被选元素的开头插入内容。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;prepend&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;prepend&lt;/button&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;Item_1&lt;/li&gt; &lt;li&gt;Item_2&lt;/li&gt; &lt;li&gt;Item_3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"ul\").prepend(\"&lt;li&gt;追加列表项&lt;/li&gt;\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; after() jQuery after() 方法在被选元素之后插入内容。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;after&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;after&lt;/button&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;Item_1&lt;/li&gt; &lt;li&gt;Item_2&lt;/li&gt; &lt;li&gt;Item_3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"ul\").after(\"&lt;li&gt;追加列表项&lt;/li&gt;\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; before() jQuery before() 方法在被选元素之前插入内容。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;before&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;before&lt;/button&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;Item_1&lt;/li&gt; &lt;li&gt;Item_2&lt;/li&gt; &lt;li&gt;Item_3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"ul\").before(\"&lt;li&gt;追加列表项&lt;/li&gt;\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：append()和prepend()方法添加新元素是在选中元素的内部，而after()和before()方法添加新元素是在选中元素的外部（元素之后或元素之前）。 删除元素删除元素/内容 remove() 删除被选元素（及其子元素） 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;remove&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #container &#123; background-color: yellow; text-align: center; margin: 5px; padding: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击删除元素&lt;/button&gt; &lt;div id=\"container\"&gt; &lt;p&gt;这里是元素内容&lt;/p&gt; &lt;p&gt;这里是元素内容&lt;/p&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"#container\").remove(); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; empty() 从被选元素中删除子元素 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;empty&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #container &#123; background-color: yellow; text-align: center; margin: 5px; padding: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击清空元素&lt;/button&gt; &lt;div id=\"container\"&gt; &lt;p&gt;这里是元素内容&lt;/p&gt; &lt;p&gt;这里是元素内容&lt;/p&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"#container\").empty(); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 过滤被删除的元素1$(\"p\").remove(\".part\"); 删除了class名为part的段落（p），如果存在class名不是part的段落，则不会被删除。 CSS类 addClass() 向被选元素添加一个或多个类 1234$(\"button\").click(function()&#123; $(\"h1, h2, p\").addClass(\"yellow\"); $(\"div\").addClass(\"important\");&#125;); 也可以同时添加多个类： 123$(\"button\").click(function()&#123; $(\"body div:first\").addClass(\"important blue\");&#125;); removeClass() 从被选元素删除一个或多个类 123$(\"button\").click(function()&#123; $(\"h1, h2, p\").removeClass(\"yellow\");&#125;); toggleClass() 对被选元素进行添加/删除类的切换操作 123$(\"button\").click(function()&#123; $(\"h1,h2,p\").toggleClass(\"yellow\");&#125;); css() 设置或返回样式属性 css()方法语法： 1css(\"propertyname\", \"value\"); 1$(\"p\").css(\"background-color\",\"yellow\"); 也可以同时设置多个： 1$(\"p\").css(&#123;\"background-color\":\"yellow\", \"font-size\":\"200%\"&#125;); 尺寸 jQuery 提供多个处理尺寸的重要方法： width() width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 innerWidth() innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() innerHeight() 方法返回元素的高度（包括内边距）。 outerWidth() outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() outerHeight() 方法返回元素的高度（包括内边距和边框）。 遍历 jQuery 遍历，意为移动，用于根据其相对于其他元素的关系来查找（或选取）HTML元素。 通过jQuery遍历，可以从当前元素开始，在家族树中向上移动（祖先），向下移动（子孙），水平移动（同胞），这种移动被称为对DOM树进行遍历： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;parent&lt;/title&gt; &lt;style&gt; * &#123; border: 1px solid pink; list-style: none; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div &lt;ul&gt;ul &lt;li&gt;li &lt;span&gt;span&lt;/span&gt; &lt;/li&gt; &lt;li&gt;li &lt;b&gt;b&lt;/b&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery 祖先 通过 jQuery，可以向上遍历 DOM 树，以查找元素的祖先。 parent() 方法 parent() 方法返回被选元素的直接父元素。该方法只会向上一级对 DOM 树进行遍历 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;parent&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div * &#123; border: 1px solid pink; list-style: none; margin: 15px; padding: 5px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div（祖父元素） &lt;ul&gt;ul（父元素） &lt;li&gt;li（当前选中元素） &lt;span&gt;span（子孙元素）&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"li\").parent().css(&#123; \"border\": \"2px solid yellow\" &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; parents()方法 parents() 方法返回被选元素的所有祖先元素，一直到文档根元素。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;parents&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div * &#123; border: 1px solid pink; list-style: none; margin: 15px; padding: 5px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div（祖父元素） &lt;ul&gt;ul（父元素） &lt;li&gt;li（当前选中元素） &lt;span&gt;span（子孙元素）&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"li\").parents().css(&#123; \"border\": \"2px solid yellow\" &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; parentsUntil()方法 parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;parentsUntil&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div * &#123; border: 1px solid pink; list-style: none; margin: 15px; padding: 5px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div（祖父元素） &lt;ul&gt;ul（父元素） &lt;li&gt;li（当前选中元素） &lt;span&gt;span（子孙元素）&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"li\").parentsUntil(\"body\").css(&#123; \"border\": \"2px solid yellow\" &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery 子孙 children() 方法 children() 方法返回被选元素的所有直接子元素。该方法只会向下一级对 DOM 树进行遍历。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;children&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div * &#123; border: 1px solid pink; list-style: none; margin: 15px; padding: 5px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div（祖父元素） &lt;ul&gt;ul（父元素） &lt;li&gt;li（当前选中元素） &lt;span&gt;span（子孙元素） &lt;b&gt;&lt;/b&gt; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"li\").children().css(&#123; \"border\": \"2px solid yellow\" &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; find() 方法 find() 方法返回被选元素的后代元素，一直到最后一个。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;children&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div * &#123; border: 1px solid pink; list-style: none; margin: 15px; padding: 5px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div（祖父元素） &lt;ul&gt;ul（父元素） &lt;li&gt;li（当前选中元素） &lt;span&gt;span（子孙元素） &lt;b&gt;&lt;/b&gt; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"li\").find(\"*\").css(&#123; \"border\": \"2px solid yellow\" &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当然，也可以对返回的标签进行过滤，来返回固定的标签。 12345$(function() &#123; $(\"li\").find(\"span\").css(&#123; \"border\": \"2px solid yellow\" &#125;);&#125;); jQuery 同胞 siblings() 方法 siblings() 方法返回被选元素的所有同胞元素。 123$(function() &#123; $(\"h2\").siblings();&#125;); 同时，也可以传入参数来过滤同胞元素进行搜索。 123$(function()&#123; $(\"h2\").siblings(\"span\");&#125;); 方法 用途 next() 返回被选元素的下一个同胞元素。该方法只返回一个元素 nextAll() 返回被选元素的所有跟随的同胞元素 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素 prev() 返回被选元素的前一个同胞元素。该方法只返回一个元素 prevAll() 返回被选元素的所有之前的同胞元素 prevUntil() 返回介于两个给定参数之间的所有之前的同胞元素 jQuery 过滤 遍历-过滤，缩小搜索元素的范围。 first() 方法 first() 方法返回被选元素的首个元素。 123$(function() &#123; $(\"p\").first();&#125;); last() 方法 last() 方法返回被选元素的最后一个元素。 123$(function() &#123; $(\"p\").last();&#125;); eq() 方法 eq() 方法返回被选元素中带有指定索引号的元素。 索引号从 0 开始，因此首个元素的索引号是 0 而不是 1 。下面的例子选取第二个 &lt;p&gt; 元素（索引号 1）： 123$(function() &#123; $(\"p\").eq(1);&#125;); filter() 方法 filter() 方法允许规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 下面的例子返回带有类名 “title“ 的所有 &lt;p&gt; 元素： 123$(function() &#123; $(\"p\").filter(\".title\");&#125;); not() 方法 not() 方法返回不匹配标准的所有元素。 提示：not() 方法与 filter() 相反。 123$(function() &#123; $(\"p\").not(\".title\");&#125;); jQuery AJAX AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。 AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，可以使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON ，同时可以把这些外部数据直接载入网页的被选元素中。 jQuery load() 方法 load() 方法从服务器加载数据，并把返回的数据放入被选元素中。 语法: 1$(selector).load(URL, data, callback); URL 为必须参数，指定加载文件的路径。 data 为可选参数，规定与请求一同发送的查询字符串键/值对集合。 callback 回调函数，规定方法完成后执行的函数名称。 jQuery get() / post()两种在客户端和服务器端进行请求-响应的常用方法： DET 和 POST Get 从指定的资源请求数据 Post 向指定的资源提交要处理的数据 $.get() 方法 $.get() 方法通过 HTTP GET 请求从服务器上请求数据。 语法： 1$.get(URL, callback); $.post() 方法 $.post() 方法通过 HTTP POST 请求向服务器提交数据。 语法: 1$.post(URL, data, callback); 实例： 12345678910$.ajax(&#123; type: 'get', async: false, cache: false, dataType: 'json', url: 'xxx.xxx.com', success: function (res) &#123; // 获取成功后的处理函数 &#125;&#125;); jQuery JSONP Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 要理解跨域，先要了解一下“同源策略”。所谓同源是指，域名，协议，端口相同。所谓“同源策略“，简单的说就是基于安全考虑，当前域不能访问其他域的东西。 同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。 参考实现","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"}]},{"title":"Highcharts 数据可视化","slug":"highcharts/highcharts","date":"2019-07-25T16:00:00.000Z","updated":"2020-10-06T11:15:40.739Z","comments":true,"path":"2019/07/26/highcharts/highcharts/","link":"","permalink":"http://akashigakki.github.io/2019/07/26/highcharts/highcharts/","excerpt":"Highcharts Highcharts 是一个用纯JavaScript编写的一个图表库， 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表","text":"Highcharts Highcharts 是一个用纯JavaScript编写的一个图表库， 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表 获取Highcharts CDN获取 https://code.highcharts.com.cn/index.html 官网获取资源包 https://www.highcharts.com.cn/download npm、bower等第三方包管理工具下载 npm: https://www.highcharts.com.cn/docs/install-from-npm bower: https://www.highcharts.com.cn/docs/install-from-bower 引入Highcharts1&lt;script src=\"http://cdn.highcharts.com.cn/highcharts/highcharts.js\"&gt;&lt;/script&gt; 创建一个简单的图表 引入CDN的JS文件 初始化函数 Highcharts.chart 来创建图表 该函数接受两个参数，第一个参数是 DOM 容器的 Id，第二个参数是图表配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Highcharts_Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 图表容器 DOM --&gt; &lt;div id=\"container\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;!-- 引入 highcharts.js --&gt; &lt;script src=\"http://cdn.highcharts.com.cn/highcharts/highcharts.js\"&gt;&lt;/script&gt; &lt;script&gt; // 图表配置 var options = &#123; chart: &#123; type: 'bar' //指定图表的类型，默认是折线图（line） &#125;, title: &#123; text: 'Highcharts_Demo' // 标题 &#125;, xAxis: &#123; categories: ['苹果', '香蕉', '橙子'] // x 轴分类 &#125;, yAxis: &#123; title: &#123; text: '吃水果个数' // y 轴标题 &#125; &#125;, series: [&#123; // 数据列 name: 'Akashi', // 数据列名 data: [1, 0, 4] // 数据 &#125;, &#123; name: 'Asuka', data: [5, 7, 3] &#125;], credits:&#123; enabled:false // 去除右下角水印 &#125; &#125;; // 图表初始化函数 var chart = Highcharts.chart('container', options); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 去除水印 去除右下角水印链接，只需要在highcharts.js中修改 123credits:&#123; enabled:false&#125;；","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"},{"name":"Charts","slug":"前端/JavaScript/Charts","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/Charts/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"},{"name":"charts","slug":"charts","permalink":"http://akashigakki.github.io/tags/charts/"}]},{"title":"Python编程 - 测试代码","slug":"python_11_test/test","date":"2019-07-23T16:00:00.000Z","updated":"2020-10-06T11:15:40.826Z","comments":true,"path":"2019/07/24/python_11_test/test/","link":"","permalink":"http://akashigakki.github.io/2019/07/24/python_11_test/test/","excerpt":"十一、代码测试11.1 测试函数 学习测试之前，需要有测试的代码。下面编写一个简单的函数。","text":"十一、代码测试11.1 测试函数 学习测试之前，需要有测试的代码。下面编写一个简单的函数。 name_function.py 123def get_formatted_name(first, last): full_name = first + \" \" + last return full_name names.py 1234567891011121314from name_function import get_formatted_nameprint(\"Enter 'q' at any time to quit.\")while True: first = input(\"\\nPlease give me a first name: \") if first == 'q': break last = input(\"Please give me a last name: :\") if last == 'q': break formatted_name = get_formatted_name(first, last) print(\"Full name: \" + formatted_name) 单元测试和测试用例 Python标准库中的模块unittest提供了代码测试工具。单元测试用于核实函数的某个方面没有问题；测试用例是一组单元测试，这些单元测试一起核实函数在各种情况z下的行为都符合要求。 可通过的测试 创建测试用例的语法需要一段时间才能习惯，但测试用例创建以后，再添加针对函数的单元测试就很简单了。 为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承 unittest.TestCase的类，并编写一系列方法对函数行为的不同方面进行测试。 test_name_function.py 123456789101112import unittestfrom name_function import get_formatted_nameclass NamesTestCase(unittest.TestCase): \"\"\" 测试name_function.py \"\"\" def test_name_function(self): formatted_name = get_formatted_name('akashi', 'sai') self.assertEqual(formatted_name, 'akashi sai')unittest.main() 运行： 首先，导入了unittest模块和测试函数；创建一个NameTestCase的类，可以随便命名，需要继承unittest.TestCase；编写函数测试，注意，在测试函数中，所有test_打头的方法都会自动运行。 之后使用了一个断言方法，unittest类的功能之一。断言方法用来核实得到的结果是否与期望的结果一致。 不能通过的测试 修改函数，让其可以出来中间名。先故意不做判断让其一般情况不能通过，查看结果。 123def get_formatted_name(first, middle, last): full_name = first + \" \" + middle + \" \" + last return full_name 传入的值不变，查看输出： 其中，E指出测试用例中有一个单元测试导致了错误。 测试未通过时怎么办 测试未通过，意味着编写的代码有错，因此需要修改导致测试不能通过的代码，而不是修改测试。 name_function.py 123456def get_formatted_name(first, last, middle = ''): if middle: full_name = first + \" \" + middle + \" \" + last else: full_name = first + \" \" + last return full_name 这样，根据不同的情况，有中间名和没有，函数都可以进行处理了，测试就自然可以通过了。 添加新测试 再添加一个测试，用来测试包含中间名的。这时就会发现继续添加函数测试就十分简单和方便了。 1234567891011121314151617import unittestfrom name_function import get_formatted_nameclass NamesTestCase(unittest.TestCase): \"\"\" 测试name_function.py \"\"\" def test_name_function(self): formatted_name = get_formatted_name('akashi', 'sai') self.assertEqual(formatted_name, 'akashi sai') def test_middle_name_function(self): \"\"\" 测试包含中间名的姓名 \"\"\" formatted_name = get_formatted_name('portgas', 'ace', 'D') self.assertEqual(formatted_name, 'portgas D ace')unittest.main() 11.2 测试类 各种断言方法 方法 用途 assertEqual(a, b) 核实 a == b assertNotEqual(a, b) 核实 a != b assertTrue(x) 核实 x 为 True assertFalse(x) 核实x为False assertIn(item, list) 核实item在lisst中 assertNotIn(item, list) 核实item不在list中 一个要测试的类 sruvey.py 12345678910111213141516class AnonymousSurvey(): def __init__(self, question): self.question = question self.responses = [] def show_question(self): print(self.question) def store_response(self, new_response): self.responses.append(new_response) def show_results(self): print(\"Survey results: \") for response in self.responses: print(\"- \" + response) 编写简单的使用程序 language_survey.py 12345678910111213141516171819from survey import AnonymousSurvey# 定义一个问题，并创建一个表示调查的AnonymousSurvey对象question = \"What language did you first learn to speak?\"my_survey = AnonymousSurvey(question)# 显示问题并存储答案my_survey.show_question()print(\"Enter 'q' at any time to quit.\\n\")while True: response = input(\"Language: \") if response == 'q': break my_survey.store_response(response)# 显示调查结果print(\"\\nThank you to everyone who participated in the survey!\")my_survey.show_results() 测试AnonymousSurvey类 test_survey.py 12345678910111213import unittestfrom survey import AnonymousSurveyclass TestAnonymousSurvey(unittest.TestCase): def test_store_single_response(self): question = \"What language did you first learn to speak?\" my_survey = AnonymousSurvey(question) my_survey.store_response('English') self.assertIn('English', my_survey.responses)unittest.main() 当用户提供三个答案时： 1234567891011121314151617181920212223import unittestfrom survey import AnonymousSurveyclass TestAnonymousSurvey(unittest.TestCase): def test_store_single_response(self): question = \"What language did you first learn to speak?\" my_survey = AnonymousSurvey(question) my_survey.store_response('English') self.assertIn('English', my_survey.responses) def test_store_three_response(self): question = \"What language did you first learn to speak?\" my_survey = AnonymousSurvey(question) responses = ['English', 'Spanish', 'Mandarin'] for response in responses: my_survey.store_response(response) for response in responses: self.assertIn(response, my_survey.responses)unittest.main() 当然，我们还可以继续提高效率。 方法setUp() unittest.TestCase类包含方法setUp()，让我们只需创建这些对象一次，并在每个测试方法中使用它们。如果在TestCast类中包含了方法 setUp()，Python会先运行它，然后再运行各个以test_打头的方法。 12345678910111213141516171819202122232425import unittestfrom survey import AnonymousSurveyclass TestAnonymousSurvey(unittest.TestCase): def setUp(self): question = \"What language did you first learn to speak?\" self.my_survey = AnonymousSurvey(question) self.responses = ['English', 'Spanish', 'Mandarin'] def test_store_single_response(self): self.my_survey.store_response(self.responses[0]) self.assertIn(self.responses[0], self.my_survey.responses) def test_store_three_response(self): for response in self.responses: self.my_survey.store_response(response) for response in self.responses: self.assertIn(response, self.my_survey.responses)unittest.main() 注意：运行测试用例时，每完成一个单元测试，Python都打印一个字符：通过测试时打印一个句点(.)；测试引发错误时打印一个E；测试导致断言失败打印一个F。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"JQuery DOM 操作（上）","slug":"basic-jquery-dom-1/JQuery_DOM","date":"2019-07-22T16:00:00.000Z","updated":"2020-10-06T11:15:40.727Z","comments":true,"path":"2019/07/23/basic-jquery-dom-1/JQuery_DOM/","link":"","permalink":"http://akashigakki.github.io/2019/07/23/basic-jquery-dom-1/JQuery_DOM/","excerpt":"JQuery DOM 操作（上）什么是JQuery jQuery是一个轻量级的JavaScript库，它极大地简化了JavaScript编程。","text":"JQuery DOM 操作（上）什么是JQuery jQuery是一个轻量级的JavaScript库，它极大地简化了JavaScript编程。 jQuery包含以下功能： HTML元素选取 HTML元素操作 CSS操作 HTML事件函数 JavaScript特效和动画 HTML DOM遍历和修改 AJAX Utilities 使用 官网下载导入 https://jquery.com/download/ CDN 载入jQuery https://www.bootcdn.cn/jquery/ 语法 jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： 1$(selector).action() 通过美元符号($)定义jQuery。 文档就绪事件 为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。如果在文档没有完全加载之前就运行函数，操作可能失败。 123$(document).ready(function()&#123; // 函数体&#125;); 简洁写法： 123$(function() &#123; // 函数体&#125;); 选择器 jQuery选择器可以快速选择HTML元素进行操作。 元素选择器 基于元素名选取元素 12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").hide(); &#125;);&#125;); id(#)选择器 基于id选取元素 12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#test\").hide(); &#125;);&#125;); class(.)选择器 基于class选取元素 12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\".test\").hide(); &#125;);&#125;); 事件 事件，即页面对访问者的响应。 常见DOM事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover 事件方法 点击事件click() 123$(\"p\").click(function()&#123; $(this).hide();&#125;); 双击事件dblclick() 123$(\"p\").dblclick(function()&#123; $(this).hide();&#125;); 鼠标进入mouseenter() 鼠标离开mouseleave() 按下鼠标mousedown() 松开鼠标mouseup() 光标悬停hover() 元素获得焦点focus() 元素失去焦点blur() 使用方式大体相同，具体实现效果根据需求使用。 jQuery效果显示/隐藏 通过 jQuery，可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Show and Hide&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这里是显示/隐藏的文字。&lt;/p&gt; &lt;button id=\"show\"&gt;显示&lt;/button&gt; &lt;button id=\"hide\"&gt;隐藏&lt;/button&gt;&lt;script&gt; $(function() &#123; // 隐藏 $(\"#hide\").click(function() &#123; $(\"p\").hide(); &#125;); // 显示 $(\"#show\").click(function() &#123; $(\"p\").show(); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法： 123$(selector).hide(speed,callback);$(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Show &amp;&amp; Hide&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这里是显示/隐藏的文字。&lt;/p&gt; &lt;button&gt;Hide&lt;/button&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"p\").hide(1000, alertHandle); &#125;); function alertHandle() &#123; alert(\"文字被隐藏！\"); &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过 jQuery，还可以使用 toggle() 方法来切换 hide() 和 show() 方法。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Show &amp;&amp; Hide&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这里是显示/隐藏的文字。&lt;/p&gt; &lt;button&gt;Show/Hide&lt;/button&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"p\").toggle(1000); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 淡入淡出 fadeIn() jQuery fadeIn() 用于淡入已隐藏的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Fade&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; display: none; margin: 30px; &#125; #red &#123; background-color: red; &#125; #orange &#123; background-color: orange; &#125; #yellow &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;Control&lt;/button&gt; &lt;div id=\"red\"&gt;&lt;/div&gt; &lt;div id=\"orange\"&gt;&lt;/div&gt; &lt;div id=\"yellow\"&gt;&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"#red\").fadeIn(); $(\"#orange\").fadeIn(\"slow\"); $(\"#yellow\").fadeIn(1200); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法: 1$(selector).fadeIn(speed,callback); fadeOut() jQuery fadeOut() 方法用于淡出可见元素。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Fade&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; margin: 30px; &#125; #red &#123; background-color: red; &#125; #orange &#123; background-color: orange; &#125; #yellow &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;Control&lt;/button&gt; &lt;div id=\"red\"&gt;&lt;/div&gt; &lt;div id=\"orange\"&gt;&lt;/div&gt; &lt;div id=\"yellow\"&gt;&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"#red\").fadeOut(); $(\"#orange\").fadeOut(\"slow\"); $(\"#yellow\").fadeOut(1200); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法: 1$(selector).fadeOut(speed,callback); fadeToggle() jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。 如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。 如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Fade&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; margin: 30px; &#125; #red &#123; background-color: red; &#125; #orange &#123; background-color: orange; &#125; #yellow &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;Control&lt;/button&gt; &lt;div id=\"red\"&gt;&lt;/div&gt; &lt;div id=\"orange\"&gt;&lt;/div&gt; &lt;div id=\"yellow\"&gt;&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"#red\").fadeToggle(); $(\"#orange\").fadeToggle(\"slow\"); $(\"#yellow\").fadeToggle(1200); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法: 1$(selector).fadeToggle(speed,callback); fadeTo() jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Fade&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; margin: 30px; &#125; #red &#123; background-color: red; &#125; #orange &#123; background-color: orange; &#125; #yellow &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;Control&lt;/button&gt; &lt;div id=\"red\"&gt;&lt;/div&gt; &lt;div id=\"orange\"&gt;&lt;/div&gt; &lt;div id=\"yellow\"&gt;&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"#red\").fadeTo(\"slow\", 0.15); $(\"#orange\").fadeTo(\"slow\", 0.4); $(\"#yellow\").fadeTo(\"slow\", 0.6); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法: 1$(selector).fadeTo(speed,opacity,callback); 滑动 slideDown() 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Slid Down&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #flip, #panel &#123; padding: 5px; text-align: center; background-color: aquamarine; &#125; #panel &#123; padding: 30px; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"flip\"&gt;点击下拉&lt;/div&gt; &lt;div id=\"panel\"&gt;这里是隐藏的内容&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"#flip\").click(function() &#123; $(\"#panel\").slideDown(\"slow\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法: 1$(selector).slideDown(speed,callback); slideUp() 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Slid Down&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #flip, #panel &#123; padding: 5px; text-align: center; background-color: aquamarine; &#125; #panel &#123; padding: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"flip\"&gt;点击上滑&lt;/div&gt; &lt;div id=\"panel\"&gt;这里是隐藏的内容&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"#flip\").click(function() &#123; $(\"#panel\").slideUp(\"slow\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法: 1$(selector).slideUp(speed,callback); slideToggle() jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。 如果元素向下滑动，则 slideToggle() 可向上滑动它们。 如果元素向上滑动，则 slideToggle() 可向下滑动它们。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Slid Down&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #flip, #panel &#123; padding: 5px; text-align: center; background-color: aquamarine; &#125; #panel &#123; padding: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"flip\"&gt;点击下拉/上滑&lt;/div&gt; &lt;div id=\"panel\"&gt;这里是隐藏的内容&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"#flip\").click(function() &#123; $(\"#panel\").slideToggle(\"slow\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法： 1$(selector).slideToggle(speed,callback); 动画 animate() jQuery animate() 方法用于创建自定义动画。默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute! 123$(\"button\").click(function()&#123; $(\"div\").animate(&#123;left:'250px'&#125;);&#125;); 操作多个属性 12345678$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); 使用相对值 1234567$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); 使用队列功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Animate&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #container &#123; width: 100px; height: 100px; background-color: yellow; margin: 30px; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;开始动画&lt;/button&gt; &lt;div id=\"container\"&gt;&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; var dom = $(\"#container\"); dom.animate(&#123; height: '300px', opacity: '0.4', &#125;, \"slow\"); dom.animate(&#123; width: '300px', opacity: '0.7', &#125;, \"slow\"); dom.animate(&#123; height: '100px', opacity: '0.4', &#125;, \"slow\"); dom.animate(&#123; width: '100px', opacity: '0.7', &#125;, \"slow\"); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 语法： 1$(selector).animate(&#123;params&#125;,speed,callback); 停止动画 stop() jQuery stop() 方法用于停止动画或效果，在它们完成之前。stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 语法: 1$(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Slid Down&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #flip, #panel &#123; padding: 5px; text-align: center; background-color: aquamarine; &#125; #panel &#123; padding: 30px; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击停止&lt;/button&gt; &lt;div id=\"flip\"&gt;点击下拉&lt;/div&gt; &lt;div id=\"panel\"&gt;这里是隐藏的内容&lt;/div&gt;&lt;script&gt; $(function() &#123; $(\"#flip\").click(function() &#123; $(\"#panel\").slideDown(3000); &#125;); $(\"button\").click(function() &#123; $(\"#panel\").stop(); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Callback Callback 函数在当前效果（动画） 100% 完成之后执行。回调函数在以上效果中作为可选参数，如果选择传入，则会在效果完成后触发函数。 链 jQuery允许把动作/方法链接在一起。这种链式操作是JS的一种特性。 1$(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000);","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"}]},{"title":"Python编程 - 文件和异常","slug":"python_10_file/file","date":"2019-07-22T16:00:00.000Z","updated":"2020-10-06T11:15:40.826Z","comments":true,"path":"2019/07/23/python_10_file/file/","link":"","permalink":"http://akashigakki.github.io/2019/07/23/python_10_file/file/","excerpt":"十、文件和异常10.1 从文件中读取数据 读取整个文件","text":"十、文件和异常10.1 从文件中读取数据 读取整个文件 首先要创建一个文本文件(pi_digits.txt)，用于存储圆周率PI小数点后30位 读取： 123with open('pi_digits.txt') as file_object: contents = file_object.read() print(contents) 读取流程 open()函数 打开文件 它接收一个参数：要打开文件的名称 返回一个表示文件的对象 关键字with 不再需要访问文件后将其关闭，Python会在合适的时候自动将其关闭 read()方法 读取文件的全部内容，并存储为字符串 注意：可以使用rstrip()删除字符串末尾空白字符 123with open('pi_digits.txt') as file_object: contents = file_object.read() print(contents.rstrip()) 文件路径 相对文件路径在Linux和OS X中 1with open('text_files/filename.text') as file_object: 在Windows中，在文件路径中使用的是反斜杠(\\)而不是斜杆(/) 1with open('text_files\\filename.text') as file_object: 绝对文件路径在Linux和OS X中类似于 12file_path = '/home/ehmatthes/other_files/text_files/filename.txt'with open(file_path) as file_object: 在Windows中，在文件路径中使用的是反斜杠(\\)而不是斜杆(/) 12file_path = 'C:\\Users\\ehmatthes\\other_files\\text_files\\finename.txt'with open(file_path) as file_object: 逐行读取 12345filename= 'pi_digits.txt'with open(filename) as file_object: for line in file_object: print(line) 去掉多余空行： 12345filename= 'pi_digits.txt'with open(filename) as file_object: for line in file_object: print(line.rstrip()) 创建一个包含文件各行内容的列表 1234567filename= 'pi_digits.txt'with open(filename) as file_object: lines = file_object.readlines()for line in lines: print(line.rstrip()) 方法readlines()从文件读取每一行，并将其存储在一个列表中。 使用文件内容 1234567891011filename= 'pi_digits.txt'with open(filename) as file_object: lines = file_object.readlines()pi_string = ''for line in lines: pi_string += line.strip()print(pi_string)print(len(pi_string)) 注意：strip()删除字符串两端的空格；读取文本文件时，文件被解析成字符串，如果是数字并且需要作为数值使用，就必须使用函数int()将其转换为整数，或者使用float()将其转换为浮点数。 10.2 写入文件 写入空文件 1234filename = 'programming.txt'with open(filename, 'w') as f_object: f_object.write(\"akashi\") open()传入的第二个实参： - `r`读取模式 - 只读模式，默认为只读模式打开文件 - `w`写入模式 - 如果指定文件已存在，返回的文件会覆盖之前的文件内容 - `a`附加模式 - 不会在返回文件对象时覆盖原来文件内容 - `r+`读取和写入文件 注意：Python只能将字符串写入文件，要将数值数据存储到文本文件中，必须先使用函数str()将其转换为字符串格式。 1234filename = 'programming.txt'with open(filename, 'w') as f_object: f_object.write(\"21\") or 1234filename = 'programming.txt'with open(filename, 'w') as f_object: f_object.write(str(21)) 写入多行 12345filename = 'programming.txt'with open(filename, 'w') as f_object: f_object.write(\"akashi\\n\") f_object.write(\"asuka\\n\") 附加到文件 123456filename = 'programming.txt'with open(filename, 'a') as f_object: # f_object.write(\"akashi\\n\") # f_object.write(\"asuka\\n\") f_object.write(\"gakki\\n\") 你会发现之前存储的两个字符串依然存在，没有被覆盖。 10.3 异常 处理ZeroDivisionError异常 使用try-except代码块 1234try: print(5/0)except ZeroDivisionError: print(\"You can't divide by zero!\") 使用异常避免奔溃 发生错误时，如果程序还有工作没有完成，妥善处理错误就尤其重要。 异常处理可以让程序接着运行，用户看到的是一条友好的错误消息，程序也不至于奔溃。 1234567891011121314151617print(\"Give me two numbers, and I'll divide them.\")print(\"\\nEnter 'q' to quit.\")while True: first_number = input(\"\\nFirst nmuber: \") if first_number == 'q': break second_number = input(\"Second number: \") if second_number == 'q': break try: answer = int(first_number) / int(second_number) except ZeroDivisionError: print(\"You can't divide by zero!\") else: print(answer) 处理FileNotFoundError异常 12345678filename = 'asuka.txt'try:with open(filename) as f_obj: contents = f_obj.read()except FileNotFoundError: msg = \"Sorry, the file \" + filename + \" does not exist.\" print(msg) 分析文本 使用split()方法分割字符串，默认以空格拆分，也可以传入参数进行拆分 123456789101112filename = 'programming.txt'try: with open(filename) as f_obj: contents = f_obj.read()except FileNotFoundError: msg = \"Sorry, the file \" + filename + \" does not exist.\" print(msg)else: words = contents.split() num_words = len(words) print(\"The file \" + filename + \" has about \" + str(num_words) + \" words.\") 决定报告哪些错误 并非每次捕获错误都需要告诉用户。使用pass语句可以像没发生过一样让代码继续运行。 123456 try: --snip--except FileNotFoundError: passelse: --snip-- 10.4 存储数据 使用json.dump()和json.load() 存储： 1234567import jsonnumber = [2, 3, 5, 7, 9, 11, 13]filename = 'number.json'with open(filename, 'w') as f_obj: json.dump(number, f_obj) 函数json.dump()接收两个实参，要存储的数据以及可用于存储数据的文件对象。 读取： 1234567import jsonfilename = 'number.json'with open(filename) as f_obj: numbers = json.load(f_obj)print(numbers) 保存和读取用户生成的数据 123456789101112131415161718import json# 如果之前存储了用户名，就加载它# 否则，就提示输入并存储它filename = 'username.json'try:with open(filename) as f_obj: username = json.load(f_obj)except FileNotFoundError: username = input(\"What is your name? \") with open(filename, 'w') as f_obj: json.dump(username, f_obj) print(\"We'll remember you when you come back, \" + username + \" !\")else: print(\"Welcome back \" + username.title() + \" !\") 重构 将代码划分成一系列完成具体工作的函数，这样的过程被称为重构。重构让代码更清晰，更易于理解，更容易扩展。 12345678910111213141516171819202122232425262728293031import jsondef greet_user(): \"\"\" 问候用户，并指明名字 \"\"\" username = get_stored_username() if username: print(\"Welcome back \" + username.title() + \" !\") else: username = get_new_username() print(\"We'll remember you when you come back, \" + username + \" !\")def get_stored_username(): \"\"\" 如果存取了用户名，就获取它 \"\"\" filename = 'username.json' try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: return None else: return usernamedef get_new_username(): \"\"\" 未存储用户名，提示用户输入用户名，并存储 \"\"\" username = input(\"What is your name? \") filename = 'username.json' with open(filename, 'w') as f_obj: json.dump(username, f_obj) return usernamegreet_user()","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python编程 - 类","slug":"python_9_class/class","date":"2019-07-21T16:00:00.000Z","updated":"2020-10-06T11:15:40.829Z","comments":true,"path":"2019/07/22/python_9_class/class/","link":"","permalink":"http://akashigakki.github.io/2019/07/22/python_9_class/class/","excerpt":"九、类9.1 创建和使用类1234567891011121314class Dog(): def __init__(self, name, age): \"\"\" 初始化属性name和age \"\"\" self.name = name self.age = age def sit(self): \"\"\" 模拟蹲下 \"\"\" print(self.name.title() + \" is now sitting.\") def roll_over(self): \"\"\" 模拟打滚 \"\"\" print(self.name.title() + \" rolled over!\")","text":"九、类9.1 创建和使用类1234567891011121314class Dog(): def __init__(self, name, age): \"\"\" 初始化属性name和age \"\"\" self.name = name self.age = age def sit(self): \"\"\" 模拟蹲下 \"\"\" print(self.name.title() + \" is now sitting.\") def roll_over(self): \"\"\" 模拟打滚 \"\"\" print(self.name.title() + \" rolled over!\") 方法__init__() 类中的函数被称为方法，__init__()是一个特殊的方法，每当根据类创建新的实例时，Python就会自动运行它。为了区别，放过名称开头和末尾各有两个下划线，方法的形参self必不可少！！！还必须位于其他形参的前面。它是指向实例本身的一个引用，让实例能够访问类中的属性和方法。self不用传递实参，由程序自动传入。 创建实例 1234my_dog = Dog(\"kii\", 6)print(my_dog.name.title())print(my_dog.age) 访问属性 通过点(.)访问 1Object.attribute 调用方法 1Object.function_name() 创建多个实例 12my_dog = Dog(\"kii\", 6)your_dog = Dog(\"chip\", 5) 9.2 使用类和实例 类可以用来模拟现实世界中的很多场景，创建好类以后，大部分的时间都使用根据类创建的实例上。 123456789101112131415class Car: def __init__(self, make, model, year): \"\"\" 初始化汽车属性 \"\"\" self.make = make self.model = model self.year = year def get_descriptive_name(self): \"\"\" 返回汽车信息 \"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title()my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name()) 给属性指定默认值 类中的每个属性都必须有初始值，哪怕这个值是0或者空字符串。可以在__init__()中指定属性的初始值，这样就无需它初始值的形参。 12345678910111213141516171819202122class Car: def __init__(self, make, model, year): \"\"\" 初始化汽车属性 \"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\" 返回汽车信息 \"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\" 打印汽车里程 \"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\")my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.read_odometer() 修改属性的值 直接修改属性的值 12my_new_car.odometer_reading = 23my_new_car.read_odometer() 通过方法修改属性的值 123456789101112131415161718192021222324252627class Car: def __init__(self, make, model, year): \"\"\" 初始化汽车属性 \"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\" 返回汽车信息 \"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\" 打印汽车里程 \"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): \"\"\" 更新汽车里程 \"\"\" self.odometer_reading = mileagemy_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.update_odometer(230)my_new_car.read_odometer() - 通过方法对属性的值进行递增 123456789101112131415161718192021222324252627282930313233class Car: def __init__(self, make, model, year): \"\"\" 初始化汽车属性 \"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\" 返回汽车信息 \"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\" 打印汽车里程 \"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): \"\"\" 更新汽车里程 \"\"\" self.odometer_reading = mileage def increment_odometer(self, miles): \"\"\" 更新汽车里程特定的量 \"\"\" self.odometer_reading += milesmy_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.update_odometer(230)my_new_car.increment_odometer(100)my_new_car.read_odometer() 9.3 继承 类的编写并非都要从空白开始，可以使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新的类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。 子类方法__init__() 创建子类的实例时，首先是给父类的所有属性赋值。 12345678910111213141516171819202122232425262728293031323334class Car: def __init__(self, make, model, year): \"\"\" 初始化汽车属性 \"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\" 返回汽车信息 \"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\" 打印汽车里程 \"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): \"\"\" 更新汽车里程 \"\"\" self.odometer_reading = mileage def increment_odometer(self, miles): \"\"\" 更新汽车里程特定的量 \"\"\" self.odometer_reading += milesclass ElectricCar(Car): \"\"\" 电动车 \"\"\" def __init__(self, make, model, year): \"\"\" 初始化父类属性 \"\"\" super().__init__(make, model, year)my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name()) super()是一个特殊函数，将父类和子类关联起来。父类也称为超类(superclass)。 给子类定义属性和方法 1234567891011121314class ElectricCar(Car): \"\"\" 电动车 \"\"\" def __init__(self, make, model, year): \"\"\" 初始化父类属性 \"\"\" super().__init__(make, model, year) self.battery_size = 70 def describe_battery(self): \"\"\" 电池容量 \"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\")my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name())my_tesla.describe_battery() 重写父类的方法 在子类里面定义一个和父类同名的方法，可以对父类方法进行重写。这样，Python将不会考虑父类的这个方法，而只关注在子类中定义的相应的方法。 将实例作用属性 类的代码过多（属性和方法），可以抽出类的部分，作为一个独立的类提取出来，进行细化拆分。 123456789101112131415161718192021class ElectricCar(Car): \"\"\" 电动车 \"\"\" def __init__(self, make, model, year): \"\"\" 初始化父类属性 \"\"\" super().__init__(make, model, year) self.battery = Battery()class Battery(): def __init__(self, battery_size = 70): self.battery_size = battery_size def describe_battery(self): \"\"\" 电池容量 \"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\")my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery() 9.4 导入类 导入单个类 1from car import Car 语法： 1from module_name import class_name 从一个模块中导入多个类 1from module_name import class_name1, class_name2 导入整个模块 1import module_name 注意：在导入整个模块后，使用必须通过模块访问。例如：module_name.class_name 123import carmy_car = car.Car('audi', 'a4', 2016) 导入模块中的所有类 1from module_name import *","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python编程 - 函数","slug":"python_8_function/function","date":"2019-07-20T16:00:00.000Z","updated":"2020-10-06T11:15:40.828Z","comments":true,"path":"2019/07/21/python_8_function/function/","link":"","permalink":"http://akashigakki.github.io/2019/07/21/python_8_function/function/","excerpt":"八、函数8.1 定义函数123456def greet_user(): \"\"\" 显示问候 \"\"\" print(\"Hello!\")#调用greet_user()","text":"八、函数8.1 定义函数123456def greet_user(): \"\"\" 显示问候 \"\"\" print(\"Hello!\")#调用greet_user() 定义 使用关键字def告诉Python定义一个函数 函数名，如greet_user()，括号里面传参数 定义以冒号结尾: 12def 函数名(形参): # 函数体 向函数传递信息 123456def greet_user(username): \"\"\" 显示问候 \"\"\" print(\"Hello, \" + username.title() + \" !\")#调用greet_user(input(\"What's you name?\")) 实参和形参 在函数定义中，传入的变量是一个形参 在函数的调用中，传递的变量是一个实参 8.2 传递实参 位置实参 函数调用中的每一个实参都关联到函数定义中的一个形参，基于实参的顺序进行关联的方式被称为位置实参 123456def describe_pet(animal_type, pet_name): \"\"\" 显示宠物信息 \"\"\" print(\"\\ntype: \" + animal_type) print(\"name: \" + pet_name)describe_pet('hamster', 'harry') 注意：传入不同的实参可以对函数多次调用，实现复用；位置实参的顺序很重要，要与形参的位置相对应。 关键字实参 关键字实参是传递给函数一个键值对，将实参的名称和值关联起来，顺序便无关紧要了。 123456def describe_pet(animal_type, pet_name): \"\"\" 显示宠物信息 \"\"\" print(\"\\ntype: \" + animal_type) print(\"name: \" + pet_name)describe_pet(animal_type = 'hamster', pet_name = 'harry') 默认值 可以给每个形参指定默认值，在调用时如果没有出入实参，则使用默认值。 123456def describe_pet(pet_name, animal_type = 'cat'): \"\"\" 显示宠物信息 \"\"\" print(\"\\ntype: \" + animal_type) print(\"name: \" + pet_name)describe_pet('nieko') 注意：在定义函数时需将有默认参数的形参（无需传递实参的形参）放在形参列表的最后面，因为Python依然将需要传入的实参视为位置实参，位置错误会报“非默认参数跟随默认参数”的错误。 注意：在无默认值的情况下，形参和实参的位置和个数都需要一一对应，缺少传入实参也会报错。 避免实参错误 实参不匹配问题，仔细查看错误，在无默认值的情况下，必须为形参提供实参，并一一关联（位置关联或关键字关联）。 8.3 返回值 返回简单值 return 1234567def get_formatted_name(first_name, last_name): \"\"\" 返回姓名 \"\"\" full_name = first_name + \" \" + last_name return full_name.title()person = get_formatted_name('akashi', 'sai')print(person) 返回字典 函数可以返回任何类型的值，包括列表和字典等较为复杂的数据结构。 1234567891011def build_person(name, age = '', sex = ''): \"\"\" 返回一个字典，定义个人信息 \"\"\" person = &#123; 'name': name, 'age': age, 'sex': sex &#125; return personperson = build_person('akashi', 21, 'male')print(person) 或者你也可以只传入name: 12person = build_person('akashi')print(person) 结合使用函数和while循环 12345678910111213141516171819def get_formatted_name(first_name, last_name): \"\"\" 返回姓名 \"\"\" full_name = first_name + \" \" + last_name return full_name.title()while True: print(\"\\nPlease tell me your name: \") print(\"(enter'q' at any time to quit)\") f_name = input(\"First name： \") if f_name == 'q': break l_name = input(\"Last name: \") if l_name == 'q': break person = get_formatted_name(f_name, l_name) print(\"\\nHello, \" + person + \" !\") 8.4 传递列表1234567def greet_users(names): for name in names: msg = \"Hello, \" + name + \"!\" print(msg)username = ['akashi', 'asuka', 'gakki']greet_users(username) 在函数中修改列表 123456789101112unprinted_designs = ['akashi', 'asuka', 'gakki']completed_models = []while unprinted_designs: current_design = unprinted_designs.pop(); print(\"Priint: \" + current_design) completed_models.append(current_design)print(\"\\nThe following models have been printed:\")for completed_model in completed_models: print(completed_model) 重新组织： 1234567891011121314151617def print_models(unprinted_designs, completed_models): while unprinted_designs: current_design = unprinted_designs.pop() print(\"Print model: \" + current_design) completed_models.append(current_design)def show_completed_models(completed_models): print(\"\\nThe following models have been printed:\") for completed_model in completed_models: print(completed_model)unprinted_designs = ['akashi', 'asuka', 'gakki']completed_models = []print_models(unprinted_designs, completed_models)show_completed_models(completed_models) 12345678910注意：重新梳理流程，提高效率，每个函数都只应负责一项具体的工作。- 禁止函数修改列表 - 将列表的副本传递给函数 ```python# 切片function_name(list_name[:]) 注意：除非有充分的理由需要传递副本，否则不推荐。考虑到效率，创建副本需要有时间和内存的开销。 8.5 传递任意数量的实参123456def make_pizza(*toppings): \"\"\" 打印顾客点的配料 \"\"\" print(toppings)make_pizza('pepperoni')make_pizza('mushrooms', 'green peppers', 'extra cheese') 形参名*toppings中的星号让Python创建了一个名为topping的元组，并将收到的所有的值都封装到元组中。这样，无论多少个实参，都可以传递。 12345678def make_pizza(*toppings): \"\"\" 打印顾客点的配料 \"\"\" print(\"\\ntoppings list:\") for topping in toppings: print(topping)make_pizza('pepperoni')make_pizza('mushrooms', 'green peppers', 'extra cheese') 结合使用位置实参和任意数量实参 123456789def make_pizza(size, *toppings): print(\"\\ntoppings list:\") print(size) for topping in toppings: print(topping)make_pizza(16, 'pepperoni')make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') 注意：函数定义时，先定义位置形参，将任意数量形参定义在最后。 使用任意数量的关键字实参 123456789101112def bulid_profile(name, age, **user_info): \"\"\" 创建一个空字典，存储用户信息 \"\"\" profile = &#123;&#125; profile['name'] = 'akashi' profile['age'] = 21 for key, value in user_info.items(): profile[key] = value return profileuser_profile = bulid_profile('akashi', 21, sex = 'male', location = 'Chengdu')print(user_profile) 形参名**user_info的两个星号让Python创建了一个user_info的空字典，并接收所有传入的键值对。 8.6 将函数存储在模块中 import允许在当前运行的程序文件中使用o模块中的代码。 导入整个模块 将之前编辑的文件创建为模块： pizza.py123456def make_pizza(size, *toppings):print(\"\\ntoppings list:\")print(size)for topping in toppings: print(topping) 创建make_pizzas.py并导入模块： 12345# 导入模块import pizzapizza.make_pizza(16, 'pepperoni')pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') 即：12345# 导入import module_name#使用module_name.function_name() 导入特定的函数 12345# 导入模块中的特定函数from module_name import function_name# 导入模块中的任意函数from module_name import function_0, functon_1 使用as给函数指定别名 1from module_name import function_name as fn 使用as给模块指定别名 1import module_name as mn 导入模块中的所有函数 1from module_name import * 注意：使用*导入模块中的所有函数","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"JavaScript DOM","slug":"basic-js-dom/JS_DOM","date":"2019-07-19T16:00:00.000Z","updated":"2020-10-06T11:15:40.728Z","comments":true,"path":"2019/07/20/basic-js-dom/JS_DOM/","link":"","permalink":"http://akashigakki.github.io/2019/07/20/basic-js-dom/JS_DOM/","excerpt":"JavaScript DOM 操作HTML DOM（文档对象模型） 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM树","text":"JavaScript DOM 操作HTML DOM（文档对象模型） 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM树 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;My Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#\"&gt;My Link&lt;/a&gt; &lt;h1&gt;My Header&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 通过可编程的对象模型，JavaScript可以创建动态的HTML。 改变页面中HTML的元素 改变页面中HTML的属性 改变页面中CSS的样式 对页面中的事件做出反应 查找HTML元素 通过id查找 1var x = document.getElementById(\"intro\"); 通过标签名查找 12var x = document.getElementById(\"main\");var y = x.getElementsByTagName(\"p\"); 通过类名查找 1var x = document.getElementsByClassName(\"intro\"); 改变HTML 改变HTML输出流 1document.write(Date()); 改变HTML内容 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"header\"&gt;Title&lt;/h1&gt;&lt;script&gt; var element = document.getElementById('header').innerHTML = 'new title';&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变HTML属性 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=\"images\" src=\"images/akashi.jpg\" alt=\"images\"&gt;&lt;script&gt; document.getElementById('images').src = \"images/asuka.jpg\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变CSS 改变HTML样式 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;style&gt; #block &#123; width: 200px; height: 200px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"block\"&gt;&lt;/div&gt; &lt;p id=\"p1\"&gt;Hello!&lt;/p&gt;&lt;script&gt; document.getElementById(\"block\").style.backgroundColor = \"red\"; document.getElementById(\"p1\").style.color = \"red\"; document.getElementById(\"p1\").style.fontFamily = \"plantc\"; document.getElementById(\"p1\").style.fontSize = \"larger\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：CSS属性使用中划线(-)分隔，在JS中，需要换成驼峰式写法。 使用事件 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;style&gt; #block &#123; width: 200px; height: 200px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"block\" onclick=\"change()\"&gt;&lt;/div&gt;&lt;script&gt; function change() &#123; document.getElementById(\"block\").style.backgroundColor = \"yellow\"; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM 事件 对事件做出反应 在事件发生时执行JavaScript，可以完成一系列功能。 eg: 当用户点击鼠标时； 当网页已加载时； 当图像已加载时； 当鼠标移动到元素上时； 当输入字段被改变时； 当提交HTML表单时； 当用户触发按键时； onload 和 onunload 事件 onload 和 onunload 事件会在用户进入或离开页面时被触发 onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本 onload 和 onunload 事件可用于处理 cookie onchange 事件 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;onChange&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\" id=\"demo\" onchange=\"change()\"&gt;&lt;script&gt; function change() &#123; var value = document.getElementById(\"demo\").value; console.log(value); alert(value); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：点击回车或者离开输入框后事件触发。 另一种写法： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;onChange&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\" id=\"demo\" onchange=\"change(this.value)\"&gt;&lt;script&gt; function change(obj) &#123; console.log(obj); alert(obj); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现了同样的效果，但第二种写法在一开始就通过this获取了输入框的值以实参的方式传入方法。 onmouseover 和 onmouseout 事件 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;onmouseover &amp;&amp; onmouseout&lt;/title&gt; &lt;style&gt; #block &#123; width: 200px; height: 200px; color: aliceblue; background-color: orange; text-align: center; line-height: 200px; font-size: larger; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"block\" onmouseover=\"overHandle(this)\" onmouseout=\"outHandle(this)\"&gt;Try&lt;/div&gt;&lt;script&gt; function overHandle(obj) &#123; obj.innerHTML = \"Over\"; &#125; function outHandle(obj) &#123; obj.innerHTML = \"Out\"; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; onmousedown、onmouseup 以及 onclick 事件 当点击鼠标按钮时，会触发 onmousedown 事件 当释放鼠标按钮时，会触发 onmouseup 事件 当完成鼠标点击时，会触发 onclick 事件 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;onChange&lt;/title&gt; &lt;style&gt; #block &#123; width: 200px; height: 200px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"block\" onclick=\"clickHandle(this)\"&gt;&lt;/div&gt;&lt;script&gt; function clickHandle(obj) &#123; obj.style.backgroundColor = \"yellow\"; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM 事件监听 addEventListener() 方法 addEventListener() 方法用于向指定元素添加事件句柄 addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄 可以向一个元素添加多个事件句柄 可以向同个元素添加多个同类型的事件句柄，如：两个 &quot;click&quot; 事件 语法： 1element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 “click” 或 “mousedown”;第二个参数是事件触发后调用的函数(只是函数名，不加括号；加括号是直接调用);第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;eventListener&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;Click!&lt;/button&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt; document.getElementById(\"btn\").addEventListener(\"click\", displayDate); function displayDate() &#123; document.getElementById(\"demo\").innerHTML = Date(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 传递参数 当传递参数值时，使用&quot;匿名函数&quot;调用带参数的函数 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;eventListener&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;Click!&lt;/button&gt;&lt;script&gt; document.getElementById(\"btn\").addEventListener(\"click\", function() &#123; clickHandle(this); &#125;); function clickHandle(obj) &#123; console.log(obj); obj.innerHTML = Date(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件冒泡或事件捕获 事件传递有两种方式：冒泡与捕获。 事件传递定义了元素事件触发的顺序。 如果将 &lt;p&gt; 元素插入到 &lt;div&gt; 元素中，用户点击 &lt;p&gt; 元素, 哪个元素的 &quot;click&quot; 事件先被触发呢？ 在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： &lt;p&gt; 元素的点击事件先触发，然后会触发 &lt;div&gt; 元素的点击事件。 在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： &lt;div&gt; 元素的点击事件先触发 ，然后再触发 &lt;p&gt; 元素的点击事件。 addEventListener() 方法可以指定 &quot;useCapture&quot; 参数来设置传递类型默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。 removeEventListener() 方法 1element.removeEventListener(\"click\", clickHandle); DOM 元素 创建新的 HTML 元素 (节点) appendChild() 添加到元素尾部 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;p id=\"p1\"&gt;这里是第一个段落&lt;/p&gt; &lt;p id=\"p2\"&gt;这里是第二个段落&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var para = document.createElement(\"p\"); var node = document.createTextNode(\"这里是插入的段落\"); para.appendChild(node); var element = document.getElementById(\"demo\").appendChild(para);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建新的 HTML 元素 (节点) insertBefore() 添加到开始位置 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;p id=\"p1\"&gt;这里是第一个段落&lt;/p&gt; &lt;p id=\"p2\"&gt;这里是第二个段落&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var para = document.createElement(\"p\"); var node = document.createTextNode(\"这里是插入的段落\"); para.appendChild(node); var element = document.getElementById(\"demo\"); var child = document.getElementById(\"p2\"); element.insertBefore(para, child);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 移除已存在的元素 removeChild() 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;p id=\"p1\"&gt;这里是第一个段落&lt;/p&gt; &lt;p id=\"p2\"&gt;这里是第二个段落&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var para = document.createElement(\"p\"); var node = document.createTextNode(\"这里是插入的段落\"); para.appendChild(node); var element = document.getElementById(\"demo\"); var child = document.getElementById(\"p2\"); element.insertBefore(para, child); var removeChild = document.getElementById(\"p1\"); element.removeChild(removeChild);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 已知要查找的子元素，然后查找其父元素，再删除这个子元素（删除节点必须知道父节点）: 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;p id=\"p1\"&gt;这里是第一个段落&lt;/p&gt; &lt;p id=\"p2\"&gt;这里是第二个段落&lt;/p&gt; &lt;/div&gt;&lt;script&gt; // 在p中插入内容 var para = document.createElement(\"p\"); var node = document.createTextNode(\"这里是插入的段落\"); para.appendChild(node); // 将新的段落插入到两个段落之间 var element = document.getElementById(\"demo\"); var child = document.getElementById(\"p2\"); element.insertBefore(para, child); // 删除第一个段落 var reChild = document.getElementById(\"p1\"); // 利用子节点查找父节点，再通过父节点删除子节点 reChild.parentNode.removeChild(reChild);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 替换 HTML 元素 replaceChild() 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;p id=\"p1\"&gt;这里是第一个段落&lt;/p&gt; &lt;p id=\"p2\"&gt;这里是第二个段落&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var para = document.createElement(\"p\"); var node = document.createTextNode(\"这里是插入的段落\"); para.appendChild(node); var element = document.getElementById(\"demo\"); var child = document.getElementById(\"p2\"); var reChild = document.getElementById(\"p1\"); reChild.parentNode.removeChild(reChild); // 替换 element.replaceChild(para, child);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"}]},{"title":"Python编程 - 用户输入和while循环","slug":"python_7_while/while","date":"2019-07-19T16:00:00.000Z","updated":"2020-10-06T11:15:40.828Z","comments":true,"path":"2019/07/20/python_7_while/while/","link":"","permalink":"http://akashigakki.github.io/2019/07/20/python_7_while/while/","excerpt":"七、用户输入和while循环7.1 input函数 input 函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便使用。","text":"七、用户输入和while循环7.1 input函数 input 函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便使用。 123name = input(\"Please enter your name: \")print(\"Hello, \" + name.title() + \"!\") 注意：input()接收一个参数，即要向用户显示的提示或说明。 123456prompt = \"If you tell ue who you are, we can personalize the message you see.\"prompt += \"\\nWhat is your first name? \"name = input(prompt)print(\"\\nHello! \" + name.title() + \"!\") 使用int()来获取数值输入 1234age = input(\"How old are you? \")age = int(age)print(age &gt;= 18) 求模运算符 可以通过是否被2整除判断奇偶。 12345678number = input(\"Enter a number, and I'll tell you if it's even or odd: \")number = int(number)if number % 2 == 0: print(\"\\nThe nubmer \" + str(number) + \" is even.\")else: print(\"\\nThe nubmer \" + str(number) + \" is odd.\") 7.2 while循环 使用while循环 1234current_number = 1while current_number &lt;= 5: print(current_number) current_number += 1 让用户选择何时退出 12345678prompt = \"\\nTell me something, and I will repeat it back to you:\"prompt += \"\\nEnter 'quit' to end the program. \"message = \"\"while message != 'quit': message = input(prompt) if message != 'quit': print(message) 使用标志 123456789101112prompt = \"\\nTell me something, and I will repeat it back to you:\"prompt += \"\\nEnter 'quit' to end the program. \"active = Truewhile active: message = input(prompt) if message == 'quit': active = False else: print(message) 使用break退出循环 12345678910prompt = \"\\nTell me something, and I will repeat it back to you:\"prompt += \"\\nEnter 'quit' to end the program. \"while True: message = input(prompt) if message == 'quit': break else: print(message) 使用continue继续下一次循环 1234567current_number = 0while current_number &lt; 10: current_number += 1 if current_number % 2 == 0: continue print(current_number) 7.3 使用while循环处理列表和字典 在列表之间移动元素 123456789101112unconfirmed_users = ['akashi', 'asuka', 'gakki']confirmed_users = []while unconfirmed_users: current_user = unconfirmed_users.pop() print(\"verifying user: \" + current_user.title()) confirmed_users.append(current_user)print(\"\\nconfirmed users: \")print(confirmed_users) 删除包含特定值的所有列表元素 1234567pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']print(pets)while 'cat' in pets: pets.remove('cat')print(pets) 使用用户输入来填充字典 12345678910111213141516responses = &#123;&#125;polling_active = Truewhile polling_active: name = input(\"\\nWhat's your name? \") age =input(\"How old are you? \") responses[name] = age repeat = input(\"next? (yes/no) \") if repeat == 'no': polling_active = Falseprint(\"\\n=== Poll Results ===\")print(responses)","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python编程 - 字典","slug":"python_6_dict/dictionary","date":"2019-07-18T16:00:00.000Z","updated":"2020-10-06T11:15:40.828Z","comments":true,"path":"2019/07/19/python_6_dict/dictionary/","link":"","permalink":"http://akashigakki.github.io/2019/07/19/python_6_dict/dictionary/","excerpt":"六、字典6.1 使用字典 在Pyhton中，字典是一系列键-值对。","text":"六、字典6.1 使用字典 在Pyhton中，字典是一系列键-值对。 字典 键-值对 用花括号{}表示 键和值之间用冒号:分隔 键值对之间用逗号,分隔 1234alien_0 = &#123;'color': 'green', 'points': 5&#125;print(alien_0['color'])print(alien_0['points']) 添加键-值对 字典是一种动态结构，可随时在其中添加键值对。 12345alien_0 = &#123;'color': 'green', 'points': 5&#125;alien_0['x_position'] = 0alien_0['y_position'] = 25print(alien_0) 输出：1&#123;'color': 'green', 'points': 5, 'x_position': 0, 'y_position': 25&#125; 先创建一个空字典 12345alien_1 = &#123;&#125;alien_1['color'] = 'green'alien_1['points'] = 5print(alien_1) 修改字典中的值 12345678alien_1 = &#123;&#125;alien_1['color'] = 'green'alien_1['points'] = 5print(alien_1)alien_1['color'] = 'yellow'print(alien_1) 输出：1&#123;'color': 'yellow', 'points': 5&#125; 删除键值对 使用del语句将相对应的键值对彻底删除 必须指定要删除的字典名和键 1234alien_1 = &#123;'color': 'green', 'points': 5&#125;del alien_1['points']print(alien_1) 输出：1&#123;'color': 'green'&#125; 6.2 遍历字典 遍历所有的键值对 使用方法items() 123456789user_0 = &#123; 'username': 'Akashi', 'age': 21, 'sex': 'male'&#125;for key, value in user_0.items(): print('\\nkey:' + key) print('value:' + str(value)) 注意：即便遍历字典时，键值对的返回顺序也与存储顺序不同，Python不关心键值对的存储顺序，而只跟踪键和值之间的关联关系。 遍历字典中所有的键 使用方法keys() 12345678user_0 = &#123; 'username': 'Akashi', 'age': 21, 'sex': 'male'&#125;for key in user_0.keys(): print(key.title()) 注意：将代码中for key in user_0.keys():替换为for key in user_0:输出不变。 显式地使用方法keys()可以让代码更容易理解，当然也可以省略。 按顺序遍历字典中所有的键 要以特定的顺序返回元素，一种办法是在for循环中对返回的键进行排序 使用sorted()来获得按特定顺序排列的键列表的副本 123456789user_0 = &#123; 'username': 'Akashi', 'age': 21, 'sex': 'male'&#125;# 按字母顺序排列for key in sorted(user_0.keys()): print(key) 遍历字典中所有的值 使用方法values() 12345678user_0 = &#123; 'username': 'Akashi', 'age': 21, 'sex': 'male'&#125;for value in user_0.values(): print(value) 剔除重复项，使用集合set() 12345678user_0 = &#123; 'username': 'Akashi', 'age': 21, 'sex': 'male'&#125;for value in set(user_0.values()): print(value) 6.3 嵌套 字典列表 12345678alien_0 = &#123;'color': 'green', 'points': 5&#125;alien_1 = &#123;'color': 'yellow', 'points': 10&#125;alien_2 = &#123;'color': 'red', 'points': 15&#125;aliens = [alien_0, alien_1, alien_2]for alien in aliens: print(alien) 在字典中存储列表 1234567891011favorite_languages = &#123; 'jen': ['python', 'ruby'], 'sarah': ['c'], 'edward': ['ruby', 'go'], 'phil': ['python', 'haskell']&#125;for name, languages in favorite_languages.items(): print(\"\\n\" + name.title() + \"'s favorite languages are:\") for language in languages: print('\\t' + language.title()) 在字典中存储字典 12345678910111213141516171819users = &#123; 'akashi': &#123; 'name': 'akashi', 'age': 21, 'sex': 'male' &#125;, 'asuka': &#123; 'name': 'asuka', 'age': 20, 'sex': 'female' &#125;&#125;for username, user_info in users.items(): print('\\nUsername: ' + username) print('\\tAge: ' + str(user_info['age'])) print('\\tSex: ' + user_info['sex'])","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python编程 - if条件语句","slug":"python_5_if/if","date":"2019-07-17T16:00:00.000Z","updated":"2020-10-06T11:15:40.827Z","comments":true,"path":"2019/07/18/python_5_if/if/","link":"","permalink":"http://akashigakki.github.io/2019/07/18/python_5_if/if/","excerpt":"五、if语句5.1 一个简单的示例1234567cars = ['audi', 'bmw', 'subaru', 'tuyota']for car in cars: if car == 'bmw': print(car.upper()) else: print(car.title())","text":"五、if语句5.1 一个简单的示例1234567cars = ['audi', 'bmw', 'subaru', 'tuyota']for car in cars: if car == 'bmw': print(car.upper()) else: print(car.title()) 5.2 条件测试 每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。 检查是否相等 使用==符号 注意：一个等号是陈述（赋值），两个等号是发问（判断是否相等）。 不考虑大小写 在Python中检查是否相等时区分大小写，那如何判断是不考虑区分大小写呢？ 转换为小写比较： 注意：原来的值不会发生改变。 检查是否不相等 使用!=符号1234requested_topping = 'mushrooms'if requested_topping != 'anchovies': print('Hold the anchovies!') 检查多个条件 使用and检查多个条件 使用or检查多个条件 检查特定值是否包含 使用in 检查特定值是否不包含 使用not in 布尔表达式 布尔表达式，即条件测试的别名。结果要么为True，要么False。 12game_active = Truecan_edit = False 5.3 if-elif-else结构12345678age = 12if age &lt; 4: print('Your admission cost is $0.')elif age &lt; 18: print('Your admission cost is $5.')else: print('Your admission cost is $10.') 5.4 使用if语句处理列表 检查特殊元素 123456requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']for requested_topping in requested_toppings:print('Adding ' + requested_topping + '.')print('\\nFinished making your pizza!') 确定列表不为空 123456789requested_toppings = []if requested_toppings: for requested_topping in requested_toppings: print('Adding ' + requested_topping + '.') print('\\nFinished making your pizza!')else: print('Are you sure you want a plain pizza?')","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python - 操作列表","slug":"python_4_list_handle/list_handle","date":"2019-07-16T16:00:00.000Z","updated":"2020-10-06T11:15:40.827Z","comments":true,"path":"2019/07/17/python_4_list_handle/list_handle/","link":"","permalink":"http://akashigakki.github.io/2019/07/17/python_4_list_handle/list_handle/","excerpt":"四、操作列表4.1 遍历整个列表 遍历1234mangicians = ['alice', 'david', 'carolina']for mangician in mangicians: print(mangician)","text":"四、操作列表4.1 遍历整个列表 遍历1234mangicians = ['alice', 'david', 'carolina']for mangician in mangicians: print(mangician) 4.2 避免缩进错误 Python根据缩进来判断代码行与前一个代码行的关系 缩进 忘记缩进 报错 逻辑错误 不必要的缩进 报错 循环后不必要的缩进 逻辑错误 遗漏了冒号 语法错误 for语句末尾的冒号告诉Python下一行是循环的第一行 4.3 创建数值列表 使用函数range() 从指定的第一个值开始，到指定的第二个值结束，不包含第二个值12for value in range(1, 5): print(value) 使用range()创建数字列表——使用list()转换为列表 使用list()转换为列表 12numbers = list(range(1, 5))print(numbers) 输出： [1, 2, 3, 4] 指定步长 打印1~10内的偶数：12numbers = list(range(2, 11, 2))print(numbers) 练习 打印1~10内的平方 12345squares = []for value in range(1, 11): square = value ** 2 squares.append(square)print(squares) 优化 使用临时变量会让代码更易读，而在其他情况下，只会让代码无谓地变长； 首先考虑编写清晰易懂且能完成所需功能的代码； 审核时，再考虑更高效的方法。1234squares = []for value in range(1, 11): squares.append(value ** 2)print(squares) 统计计算 最大值max()、最小值min()、总和sum()1234digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]print(max(digits))print(min(digits))print(sum(digits)) 列表解析 解析列表将for循环和创建新元素的代码合并成一行，并自动附加新元素12345\"\"\"列表解析\"\"\"squares = [value ** 2 for value in range(1, 11)]print(squares) 4.4 使用列表的一部分 切片 处理列表的部分元素 123456\"\"\"打印从第1个开始，到第4个为止，不包括第4个(下标从0开始)\"\"\"players = ['charles', 'martina', 'michael', 'florence', 'eli']print(players[0:3]) 如果没有指定第一个索引，将从列表开头开始 12345players = ['charles', 'martina', 'michael', 'florence', 'eli']\"\"\"打印从列表开头开始，到第5个为止，不包括第5个(下标从0开始)\"\"\"print(players[:4]) 如果省略终止索引，将终止于列表末尾 12345players = ['charles', 'martina', 'michael', 'florence', 'eli']\"\"\"打印从第2个开始，到列表末尾为止\"\"\"print(players[1:]) 负数索引返回离列末尾相应距离的元素 12345players = ['charles', 'martina', 'michael', 'florence', 'eli']\"\"\"打印从最后3个开始，到列表末尾为止\"\"\"print(players[-3:]) 遍历切片 1234players = ['charles', 'martina', 'michael', 'florence', 'eli']for player in players[:3]: print(player.title()) 复制列表 复制列表，可以创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]） 理解两个例子的差异 123456789my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foods[:]my_foods.append('cannoli')friend_foods.append('ice cream')print(my_foods)print(friend_foods) 输出： 123456789101112my_foods = ['pizza', 'falafel', 'carrot cake']\"\"\" 本质上是将friend_foods关联到了包含在my_foods的列表，两个变量都是指向了同一个表。所以分别对两个变量操作，列表都会发生变化，且两个变量的值是相同的\"\"\"friend_foods = my_foodsmy_foods.append('cannoli')friend_foods.append('ice cream')print(my_foods)print(friend_foods) 输出： 4.5 元组 一系列不可修改的元素，不可变的列表被称为元组 定义和遍历 尝试修改元组会报错12345dimensions = (200, 50)print(dimensions)for dimension in dimensions: print(dimension) 修改元组变量 虽然不能修改元组的元素，但可以给存储元组的变量赋值（重新定义元组）12345dimensions = (200, 50)dimensions = (400, 100)for dimension in dimensions:print(dimension) 如果需要存储一组值在程序的整个生命周期内都不变，可以使用元组。","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"JavaScript基础","slug":"basic-js/JavaScript基础","date":"2019-07-15T16:00:00.000Z","updated":"2020-10-06T11:15:40.728Z","comments":true,"path":"2019/07/16/basic-js/JavaScript基础/","link":"","permalink":"http://akashigakki.github.io/2019/07/16/basic-js/JavaScript基础/","excerpt":"JavaScript基础一、什么是JavaScript？ 1.1 JS JavaScript是一种脚本语言 JavaScript是一种轻量级的编程语言 JavaScript可插入HTML编程 JavaScript代码可由浏览器执行","text":"JavaScript基础一、什么是JavaScript？ 1.1 JS JavaScript是一种脚本语言 JavaScript是一种轻量级的编程语言 JavaScript可插入HTML编程 JavaScript代码可由浏览器执行 1.2 JavaScript直接写入HTML输出流123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;HTML输出流&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; document.write('&lt;h1&gt;这是一个标题&lt;/h1&gt;'); document.write('&lt;p&gt;这是一个段落&lt;/p&gt;'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：如果在文档已加载后使用（比如在函数中），会覆盖整个文档。 1.3 JavaScript对事件的反应123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;弹出事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button type=\"button\" onclick=\"alert('欢迎！')\"&gt;点我！&lt;/button&gt; &lt;button onclick=\"eventHandle()\"&gt;再点我！&lt;/button&gt;&lt;script&gt; function eventHandle() &#123; alert(\"欢迎！\") &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：两个Button的弹出效果是一样的，写法上第二个调用了函数，是常见写法。 1.4 JavaScript改变HTML的内容 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;改变HTML内容&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"demo\"&gt;这里是文档内容&lt;/p&gt; &lt;button onclick=\"change()\"&gt;点击修改&lt;/button&gt;&lt;script&gt; function change() &#123; x = document.getElementById('demo'); // 找到元素 x.innerHTML = '这里是修改后的内容'; // 修改内容&#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.5 JavaScript改变HTML的图像 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;判断替换src&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"/images/pic_bulboff.gif\" id=\"image\" onclick=\"changeImage()\" width=\"100\" height=\"180\" alt=\"images\"&gt;&lt;script&gt; function changeImage() &#123; document.getElementById('image'); if (element.src.match('bulbon')) &#123; element.src=\"/images/pic_bulboff.gif\"; &#125; else &#123; element.src=\"/images/pic_bulbon.gif\"; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6 JavaScript改变HTML的样式 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;改变HTML样式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"demo\"&gt;这里是元素样式&lt;/p&gt; &lt;button onclick=\"change()\"&gt;点击修改&lt;/button&gt;&lt;script&gt; function change() &#123; x = document.getElementById('demo'); x.style.color = '#ff0000'; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.7 ECMAScript 版本 年份 名称 描述 2009 ECMAScript 5 添加 “strict mode”，严格模式，添加 JSON 支持 2011 ECMAScript 5.1 版本变更 2015 ECMAScript 6 添加类和模块 2016 ECMAScript 7 增加指数运算符 (**)，增加 Array.prototype.includes 二、用法及输出 如需在HTML页面中插入JavaScript，需使用&lt;script&gt;标签。脚本可被放置在HTML 页面的&lt;body&gt; 和&lt;head&gt; 部分中。 2.1 导入JS的三种方式 &lt;body&gt;中的JS 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // 在这里编辑你的JS代码&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &lt;head&gt;中的JS 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 在这里编辑你的JS代码 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 外部的JS 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 从外部导入js文件 --&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2 JavaScript输出 使用window.alert()弹出警告框123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;输出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.alert('Hello!');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：window是JS的全局变量，可以省略不写。(例如alert(&#39;Hello!&#39;)) 使用document.write()方法将内容写到HTML文档中 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;输出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; document.write('Hello!');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用innerHTML写入到HTML元素 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;输出&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt; document.getElementById('demo').innerHTML = Date(); // 输出当前时间&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用console.log()写入到浏览器控制台输出 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;输出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; console.log('Hello!');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：从浏览器打开html文件，按F12打开开发者模式，在console控制台查看。 2.3 数据类型及变量 数据类型 值类型（基本类型） 字符串String 1var name = 'Akashi'; 数字Number 1var age = '21'; 布尔型Boolean 1var active = true; 对空Null 1var person = null; 未定义Undefined Symbol 引用数据类型 对象Object 1234var person = &#123; name = 'Akashi', age = 21,&#125; 数组Array 1var cars = ['audi', 'toyota', 'bmw']; or 1var cars = new Array('audi', 'toyota', 'bmw'); or 1234var cars2 = new Array();cars2[0] = 'audi';cars2[1] = 'toyota';cars2[2] = 'bmw'; 函数Function 123function name(params) &#123;&#125; 注意：Undefined和Null：Undefined 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。 注意：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 创建变量 使用var关键词声明变量1234567&lt;script&gt; var length = 16; // Number 通过数字字面量赋值 var points = x * 10; // Number 通过表达式字面量赋值 var lastName = \"Sai\"; // String 通过字符串字面量赋值 var cars = [\"Audi\", \"Toyota\", \"BMW\"]; // Array 通过数组字面量赋值 var person = &#123;firstName:\"Akashi\", lastName:\"Sai\"&#125;; // Object 通过对象字面量赋值&lt;/script&gt; 声明变量类型 动态类型 JavaScript拥有动态类型。这意味着相同的变量可用作不同的类型 使用关键词new声明变量类型1234567&lt;script&gt; var name = new String; var num = new Number; var flag = new Boolean; var list = new Array(); var person = new Object;&lt;/script&gt; 函数 12345&lt;script&gt; function functionName(params) &#123; // 函数体 &#125;&lt;/script&gt; 字母大小写 JavaScript对大小写敏感 注释 单行注释 单行注释以 // 开头 多行注释 多行注释以 /*开始，以 */结尾 2.4 作用域 在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。 局部变量 变量在函数内声明，变量为局部作用域 局部变量：只能在函数内部访问 12345// 函数外不能调用name变量function getName() &#123; name = 'akashi'; // 函数内可调用name变量&#125; 全局变量 变量在函数外定义，即为全局变量 全局变量有 全局作用域: 网页中所有脚本和函数均可使用 1234567var name = 'akashi';// 函数外可调用name变量function getName() &#123; // 函数内可调用name变量&#125; 生命周期 JavaScript 变量生命周期在它声明时初始化 局部变量在函数执行完毕后销毁 全局变量在页面关闭后销毁 函数参数 函数参数只在函数内起作用，是局部变量 HTML中的全局变量 在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象 1234567getName();// 可以调用window.nameconsole.log(window.name);function getName() &#123; name = 'akashi';&#125; 2.5 事件 HTML 事件可以是浏览器行为，也可以是用户行为。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;事件&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt;&lt;/div&gt; &lt;button onclick=\"clickHandle()\"&gt;现在的时间是？&lt;/button&gt;&lt;script&gt; function clickHandle() &#123; document.getElementById('demo').innerHTML = Date(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 常见的HTML事件表 事件 描述 onchange HTML元素改变 onclick 用户点击HTML元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 更多参考：https://blog.csdn.net/qwer_df_b/article/details/77509859 2.6 字符串 JavaScript字符串可以存储一系列字符，用于存储和处理文本。 获取字符串长度 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;String&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var str = 'qwertyuiopasdfghjklzxcvbnm'; console.log(str.length);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 特殊字符 使用转义字符（\\），反斜杠是一个转义字符。 转义字符将特殊字符转换为字符串字符 代码 输出 \\’ 单引号 \\” 双引号 \\ 反斜杠 \\n 换行 \\r 回车 \\t tab(制表符) \\b 退格符 \\f 换页符 字符串方法 方法 描述 charAt() 返回指定索引位置的字符 indexOf() 返回字符串中检索指定字符第一次出现的位置 lastIndexOf() 返回字符串中检索指定字符最后一次出现的位置 match() 找到一个或多个正则表达式的匹配 replace() 替换与正则表达式匹配的子串 search() 检索与正则表达式相匹配的值 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 split() 把字符串分割为子字符串数组 substr() 从起始索引号提取字符串中指定数目的字符 substring() 提取字符串中两个指定的索引号之间的字符 toString() 返回字符串对象值 2.7 运算符 算数运算符 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 取模（余数） ++ 自增 -- 自减 赋值运算符 运算符 例子 等同于 运算结果 = x=y x=5 += x+=y x=x+y x=15 -= x-=y x=x-y x=5 *= x*=y x=x*y x=50 /= x/=y x=x/y x=2 %= x%=y x=x%y x=0 字符串拼接 + 1234var firstname = 'akashi';var lastname = 'sai';var fullname = firstname + lastname;console.log(fullname); 2.8 比较运算符和逻辑运算符 比较运算符 运算符 描述 == 等于 === 绝对等于 != 不等于 !== 不绝对等于（值和类型有一个不相等，或两个都不相等） &gt; 大于 &lt; 小于 &gt;= 大于或等于 &lt;= 小于或等于 逻辑运算符 运算符 描述 例子 &amp;&amp; and (x &lt; 10 &amp;&amp; y &gt; 1) 为 true II or (x==5 II y==5) 为 false ! not !(x==y) 为 true 注意：列表中的II为双竖线||。 条件运算符 1variablename=(condition)?value1:value2 eg:1voteable=(age&lt;18)?\"年龄太小\":\"年龄已达到\"; 2.9 条件语句123456789if (condition1) &#123; // do something&#125;else if (condition2) &#123; // do something&#125;else &#123; // do something&#125; 2.10 switch语句12345678910switch(n) &#123; case 1: // 执行代码块 1 break; case 2: // 执行代码块 2 break; default: // 与 case 1 和 case 2 不同时执行的代码&#125; 2.11 for循环123for (语句 1; 语句 2; 语句 3) &#123; // 被执行的代码块&#125; for/in JavaScript for/in 语句循环遍历对象的属性 123456789var x;var person = &#123;name: \"akashi\", age: 21, sex: \"male\"&#125;;var text = '';for (x in list) &#123; text += list[x];&#125;console.log(text); 2.12 while循环123while (条件) &#123; // 需要执行的代码&#125; 123do &#123; // 需要执行的代码&#125; while (条件); 2.13 break和continue语句 break break 语句可用于跳出循环 break 语句跳出循环后，会继续执行该循环之后的代码 continuee continue 语句中断循环中的迭代 如果出现了指定的条件，然后继续循环中的下一个迭代","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"入门教程","slug":"入门教程","permalink":"http://akashigakki.github.io/tags/入门教程/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"}]},{"title":"Python编程 - 列表简介","slug":"python_3_list/list","date":"2019-07-15T16:00:00.000Z","updated":"2020-10-06T11:15:40.827Z","comments":true,"path":"2019/07/16/python_3_list/list/","link":"","permalink":"http://akashigakki.github.io/2019/07/16/python_3_list/list/","excerpt":"三、列表3.1 什么是列表列表由一系列按特定的顺序排列的元素组成。用[]来表示，并用逗号来分隔其中的元素。 12bicycles = ['trek', 'cannondale', 'redine', 'specialized']print(bicycles)","text":"三、列表3.1 什么是列表列表由一系列按特定的顺序排列的元素组成。用[]来表示，并用逗号来分隔其中的元素。 12bicycles = ['trek', 'cannondale', 'redine', 'specialized']print(bicycles) 输出： 访问列表元素 12bicycles = ['trek', 'cannondale', 'redine', 'specialized']print(bicycles[0]) 列表是有序集合，因此要访问列表的任何元素，只需要将元素位置的索引传入即可。 索引从0而不是1开始 123bicycles = ['trek', 'cannondale', 'redine', 'specialized']print(bicycles[1])print(bicycles[-1]) 第一个列表元素的索引为0；通过将索引指定为-1，可以返回最后一个列表元素。 输出： 3.2 修改、添加和删除元素 修改列表元素 12345motocycles = ['honda', 'yamaha', 'suzuki']print(motocycles)motocycles[0] = 'ducati'print(motocycles) 在列表中添加元素 在列表末尾添加元素 append()12345678motocycles = ['honda', 'yamaha', 'suzuki']print(motocycles)motocycles[0] = 'ducati'print(motocycles)motocycles.append('honda')print(motocycles) 在列表中插入元素 insert()12345motocycles = ['honda', 'yamaha', 'suzuki']print(motocycles)motocycles.insert(0, 'ducati')print(motocycles) 从列表中删除元素 使用del语句删除元素 12345motocycles = ['honda', 'yamaha', 'suzuki']print(motocycles)del motocycles[0]print(motocycles) 使用方法pop()删除元素 方法pop()可以删除列表末尾的元素，并且你可以接着使用它的值123456motocycles = ['honda', 'yamaha', 'suzuki']print(motocycles)poped_motocycles = motocycles.pop()print(motocycles)print(poped_motocycles) 弹出列表中任何位置处的元素 在括号中指定要删除的元素的索引，可以使用pop()来删除列表中任何位置的元素123456motocycles = ['honda', 'yamaha', 'suzuki']print(motocycles)next_motocycles = motocycles.pop(1)print(motocycles)print(next_motocycles) 根据值删除元素 remove() 使用remove()删除元素时，也可以接着使用它的值 方法remove()只删除第一个指定的值，如果该值在列表中出现多次，就需要使用循环判断1234567mark = 'ducati'motocycles = ['honda', 'yamaha', 'suzuki', 'ducati']print(motocycles)motocycles.remove(mark)print(mark)print(motocycles) 3.3 组织列表 使用方法sort()对列表进行永久性排序 按字母顺序排序 方法sort()的修改是永久性的，无法恢复到原来的排序123456789cars = ['bmw', 'audi', 'toyota', 'subaru']cars.sort()print(cars)'''反转列表'''cars.sort(reverse=True)print(cars) 使用函数sorted()对列表进行临时排序 sorted()可以按特定的顺序显示列表元素，同时不影响它们在列表中原始排列顺序12345678910cars = ['bmw', 'audi', 'toyota', 'subaru']print(\"Here is the original list: \")print(cars)print(\"\\nHere is the sorted list: \")print(sorted(cars))print(\"\\nHere is the original list: \")print(cars) 倒序打印列表 reverse()永久性的修改了排列的列表元素，但可以随时恢复，只需再次调用reverse()即可1234cars = ['bmw', 'audi', 'toyota', 'subaru']cars.reverse()print(cars) 确定列表的长度 123cars = ['bmw', 'audi', 'toyota', 'subaru']print(len(car)) 避免索引错误 当发生索引错误找不到解决办法时，可以尝试将列表或其长度打印出来","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python编程 - 数据类型","slug":"python_2_data_type/data_type","date":"2019-07-14T16:00:00.000Z","updated":"2020-10-06T11:15:40.827Z","comments":true,"path":"2019/07/15/python_2_data_type/data_type/","link":"","permalink":"http://akashigakki.github.io/2019/07/15/python_2_data_type/data_type/","excerpt":"二、变量和简单数据类型2.1 变量12message = \"Hello Python World!\"print(message)","text":"二、变量和简单数据类型2.1 变量12message = \"Hello Python World!\"print(message) 这里我们添加了一个message的变量，变量存储了一个值为文本 &quot;Hello Python World!&quot; 1234message = \"Hello Python World!\"message = \"Hello!\"print(message) 我们可以修改覆盖变量的值，Python将始终记录变量的最新值。这里的输出为&quot;Hello!&quot; 2.2 变量的命名和使用 命名规则： 变量只能包含字母、数字和下划线。变量名可以以字母或下划线开头，但不能以数字开头。 变量名不能包含空格，可以使用下划线来分隔单词。 不要将Python`关键字和函数名`用作变量名。 变量名应既简短又具有描述性。 慎用小写字母l和大写字母O，因为容易和数字1和0混淆。 2.3 字符串 字符串就是一系列字符，在Python中用引号括起来的都是字符串，其中引号可以使单引号也可以是双引号。 使用方法修改字符串的大小写 12name = \"akashi\"print(name.title()) 方法是Python可对数据执行的操作，在name.title()中通过点（.）来执行title()方法的操作。title()以首字母大写的方式显示每个单词。 首字母大写 title() 全部大写 upper() 全部小写 lower() 12345name = \"akashi\"print(name.title())print(name.upper())print(name.lower()) 输出：123AkashiAKASHIakashi 合并（拼接）字符串 Python中使用（+）来合并字符串。 123456first_name = \"akashi\"last_name = \"sai\"full_name = first_name + last_namemessage = \"Hello, \" + full_name.title() + \"!\"print(message) 输出：Hello Akashisai! 使用制表符或换行符添加空白 字符串\\n\\t让Python换到下一行，并在下一行添加一个制表符。 1print(\"Languages:\\n\\tPython\\n\\tC++\\n\\tJavaScript\") 输出： 删除空白 剔除字符串末尾空白 rstrip() 剔除字符串开头空白 lstrip() 剔除字符串两端的空白 strip() 2.4 数字 整数 加减乘除运算 乘方 Python使用两个乘号表示乘方运算。 浮点数 Python将带小数点的数字都称作浮点数。在进行浮点运算时，Python通常会按照你期望的方式处理它。 但需要注意的是，结果包含的小数位数可能不确定。但其实所有的语言都存在这种问题。浮点数计算得到的是一个近似的值。 使用函数str()避免类型错误 123age = 21message = \"Happy \" + age + \"rd Birthday!\"print(message) 你可能认为，上面的代码会打印一条生日祝福语，但其实它会引发一个错误： 这是一个类型错误，这意味着Python无法识别你使用的信息，为此，可调用函数str()将非字符串转换为字符串： 123age = 21message = \"Happy \" + str(age) + \"rd Birthday!\"print(message) 2.5 注释 单行注释 使用#进行单行注释 多行注释 使用&quot;&quot;&quot;包含进行多行注释 1234567# 这是一个单行注释&quot;&quot;&quot;这是一个多行注释&quot;&quot;&quot; 2.6 Python之禅 import this 避繁就简 漂亮而优雅 简单易懂 ……","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"Python编程 - 起步","slug":"python_1_start/start","date":"2019-07-13T16:00:00.000Z","updated":"2020-10-06T11:15:40.826Z","comments":true,"path":"2019/07/14/python_1_start/start/","link":"","permalink":"http://akashigakki.github.io/2019/07/14/python_1_start/start/","excerpt":"一、起步1.1 检查Python版本在终端Terminal输入： python","text":"一、起步1.1 检查Python版本在终端Terminal输入： python 打印以上信息，说明系统安装了python环境。 python3 打印以上信息，说明系统安装了python3环境。 使用exit()命令退出编程环境。 1.2 Hello Worldprint(&quot;Hello World!&quot;) 1.3 从终端运行Python程序 在Linux和OS X系统中从终端运行Python程序 使用cd（表示切换目录，change directory）在文件系统中导航 ls（list的简写）显示当前目录中所未隐藏的文件 123$ cd Source/Python$ ls$ python hello_world.py 在Windows系统中从终端运行Python程序 使用终端命令cd（表示切换目录，change directory）在文件系统中导航 dir（表示目录，directory）列出当前目录中的所有文件 123$ cd Source/Python$ dir$ python hello_world.py","categories":[{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"}]},{"title":"JetBrains IDE全家桶破解教程","slug":"JetBrains-IDE/JetBrains_IDE_全家桶破解","date":"2019-04-28T16:50:43.000Z","updated":"2020-10-06T11:15:40.719Z","comments":true,"path":"2019/04/29/JetBrains-IDE/JetBrains_IDE_全家桶破解/","link":"","permalink":"http://akashigakki.github.io/2019/04/29/JetBrains-IDE/JetBrains_IDE_全家桶破解/","excerpt":"通过本教程，你可以优雅的破解使用JetBrains旗下的一系列IDE，包括WebStorm、PyCharm、PhpsStorm、IntelliJ IDEA等。","text":"通过本教程，你可以优雅的破解使用JetBrains旗下的一系列IDE，包括WebStorm、PyCharm、PhpsStorm、IntelliJ IDEA等。 JetBrains IDE全家桶破解 方法一：修改hosts IDE下载以后，先运行一次，然后关闭进行破解。 找到hosts文件 Windows win+R调出运行窗口输入c:\\windows\\system32\\drivers\\etc 找到hosts文件用记事本打开修改 在最后面添加以下两项并保存退出120.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com 注意： 如果没有编辑权限可以先复制一份到桌面，便可以编辑。编辑之后粘贴回etc目录与原文件进行替换即可。 Mac 在桌面使用快捷键Shift+Command+G，并输入hosts文件所在的路径：/etc/hosts 同样添加修改项并保存 注意： 同样的，没有权限可以拷贝hosts文件到桌面，修改后替换/etc/hosts。 注册码填写 复制以下注册码（目测可用到2099年） 14RULSIH54N-eyJsaWNlbnNlSWQiOiI0UlVMU0lINTROIiwibGljZW5zZWVOYW1lIjoiMjA5OSAxODExIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE5LTExLTI3In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjcifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNyJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTExLTI3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE5LTExLTI3In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE5LTExLTI3In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjcifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNyJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTExLTI3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjcifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjcifV0sImhhc2giOiIxMTA3MzgwNy8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-rlH9JbPzbld/Oak51Co3HlhD6xgE7CsvbrLl6RCySuv2sw37KBfDPY1PT2lAEkW0MJkUtGtmSHVp/jk8F4RuHGvouJFMdCtnsKdnebdjaPsKpjgxoreWlOu8VCnrGh+3mmuswzGKouw52ffxbmsvGFa5ybvWv7mj9gqSY0V20OcgCmIT3dlj4f9xc0iA9o7z1pvedVzcOrxVKvLmmqRp+4zMfNuMQB5sraznW9BxslR1sWN0pUOu9/J+k7IH6Wld/oGv5dtHYFqk5RinSBMTjYlZ+X4AV5f83Z4SkzbHqy2fGC6S3NoifaVFxRSP5TQDe6hsg7Fzic6k1iWAup89pg==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 重启IDE，在弹出的激活对话框中选择Activation Code，若没有弹出激活框，可在Help下点击Register，选择Activation Code并粘贴注册码。 OK确认激活 以上，完成破解 持续更新……","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://akashigakki.github.io/tags/教程/"},{"name":"破解","slug":"破解","permalink":"http://akashigakki.github.io/tags/破解/"}]},{"title":"CSS基础","slug":"basic-css/CSS基础","date":"2019-03-28T16:03:45.000Z","updated":"2020-10-06T11:15:40.723Z","comments":true,"path":"2019/03/29/basic-css/CSS基础/","link":"","permalink":"http://akashigakki.github.io/2019/03/29/basic-css/CSS基础/","excerpt":"一、什么是CSS？ CSS 指层叠样式表 (Cascading Style Sheets)， 用于控制网页的样式和布局。","text":"一、什么是CSS？ CSS 指层叠样式表 (Cascading Style Sheets)， 用于控制网页的样式和布局。 1.1 CSS基本语法选择器 { 属性: 值; 属性: 值;} 123body&#123; background-color: red;&#125; 1.2 CSS的三种引入方式 外部样式表(External style sheet) 即link中的href属性，引用外部css文件 123&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"./app.css\"&gt;&lt;/head&gt; 内部样式表(Internal style sheet) 在head中的style标签中引用 1234567&lt;head&gt; &lt;style&gt; body&#123; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt; 内联样式(Inline style) 在标签中直接使用style属性 123&lt;div style=\"background-color:red;\"&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/div&gt; 1.3 三种基础选择器 标签选择器 直接接标签名 class选择器 以.开头，接class名 id选择器 以#开头，接id名 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: red; &#125; .box&#123; margin: 10px; width: 100px; height: 100px; background-color: white; &#125; #con&#123; width: 50px; height: 50px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div id=\"con\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二、常见属性 2.1 background CSS 背景属性用于定义HTML元素的背景。 background-color 背景颜色 background-image 背景图片 background-repeat 背景图像水平或垂直平铺 background-position 设置定位 简写123body &#123; background:#ffffff url('img_tree.png') no-repeat right top;&#125; 2.2 文本 color 设置文字颜色 十六进制值 如: ＃FF0000 一个RGB值 如: RGB(255,0,0) 颜色的名称 如: red 123h1 &#123; color: red;&#125; text-align 设置对齐方式 123p &#123; text-align: center;&#125; text-decoration 设置文本装饰 123a &#123; text-decoration: none;&#125; 2.3 字体 font-size 设置文本的字体大小 123p &#123; font-size:14px;&#125; font-family 设置文本的字体系列 123p &#123; font-family:\"Times New Roman\", Times, serif;&#125; 2.4 链接12345678910111213 a:link &#123; color:#000000; /* 未访问链接*/ &#125; a:visited &#123; color:#00FF00; /* 已访问链接 */ &#125; a:hover &#123; color:#FF00FF; /* 鼠标移动到链接上 */ &#125; a:active &#123; color:#0000FF; /* 鼠标点击时 */ &#125; &#125; 2.5 列表 list-style 设置列表样式 123ul &#123; list-style: none;&#125; 2.6 盒子模型 所有的HTML元素可以看作是一个盒子，CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 Margin(外边距) 清除边框外的区域，外边距是透明的。 Border(边框) 围绕在内边距和内容外的边框。 Padding(内边距) 清除内容周围的区域，内边距是透明的。 Content(内容) 盒子的内容，显示文本和图像。 2.7 边框 CSS边框属性允许你指定一个元素边框的样式和颜色。 属性 border-width border-style (required) border-color 简写 123p &#123; border:5px solid red;&#125; 2.8 margin 外边距 CSS margin(外边距)属性定义元素周围的空间。margin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。 属性 123456section &#123; margin-top:100px; margin-bottom:100px; margin-right:50px; margin-left:50px;&#125; 简写 123section &#123; margin: 100px 50px;&#125; 2.9 padding 填充 CSS padding 定义元素边框与元素内容之间的空间，即上下左右的内边距。当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。 属性 123456section &#123; padding-top:25px; padding-bottom:25px; padding-right:50px; padding-left:50px;&#125; 简写 123section &#123; padding:25px 50px;&#125; 2.10 position 定位 position 属性指定了元素的定位类型。 属性 static HTML 元素的默认值，即没有定位，遵循正常的文档流对象。 静态定位的元素不会受到 top, bottom, left, right的影响。 relative 相对定位元素是相对自己本身所在的位置进行定位的。 fixed 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动。 absolute 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。 sticky 基于用户的滚动位置来定位。 重叠元素 元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面） 123456img &#123; position:absolute; left:0px; top:0px; z-index:-1;&#125; 2.11 overflow 溢出 CSS overflow 属性用于控制内容溢出元素框时显示的方式。 属性 visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 2.12 float 浮动 CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。 注意： 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 eg. 123img &#123; float:left;&#125; 清除浮动 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。 eg. 123.text_line &#123; clear:both;&#125; 2.13 组合 组合选择符说明了两个选择器直接的关系。CSS组合选择符包括各种简单选择符的组合方式。 组合方式 后代选择器(以空格分隔) 子元素选择器(以大于号分隔） 相邻兄弟选择器（以加号分隔）-普通兄弟选择器（以破折号分隔） 后代选择器 后代选择器用于选取某元素的后代元素。 123div p &#123; background-color: yellow;&#125; 注意： 实例选取了所有&lt;div&gt;中的&lt;p&gt;元素 子元素选择器 与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素子元素的元素。 123div&gt;p &#123; background-color: yellow;&#125; 注意： 实例选择了&lt;div&gt;元素中所有直接子元素 &lt;p&gt; 相邻兄弟选择器 相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。 123div+p &#123; background-color: yellow;&#125; 注意： 实例选取了所有位于 &lt;div&gt; 元素后的第一个 &lt;p&gt; 元素 后续兄弟选择器 后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。 123div~p &#123; background-color: yellow;&#125; 注意： 实例选取了所有 &lt;div&gt; 元素之后的所有相邻兄弟元素 &lt;p&gt; 2.14 伪类 例如:hover, :link, :first-child被称作伪类 :hover 当鼠标悬停时，显示样式 123a:hover &#123; background-color:#FF704D;&#125; :first-child 选择父元素的第一个子元素 123p:first-child &#123; color:blue;&#125; fin","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://akashigakki.github.io/categories/前端/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"入门教程","slug":"入门教程","permalink":"http://akashigakki.github.io/tags/入门教程/"},{"name":"CSS","slug":"CSS","permalink":"http://akashigakki.github.io/tags/CSS/"}]},{"title":"HTML基础","slug":"basic-html/HTML基础","date":"2019-03-28T12:57:33.000Z","updated":"2020-10-06T11:15:40.723Z","comments":true,"path":"2019/03/28/basic-html/HTML基础/","link":"","permalink":"http://akashigakki.github.io/2019/03/28/basic-html/HTML基础/","excerpt":"一、准备工作 1.1 开发工具的选择 一款好用的编辑器可以让你在撸代码的过程中事半功倍。 VS Code Sublime text","text":"一、准备工作 1.1 开发工具的选择 一款好用的编辑器可以让你在撸代码的过程中事半功倍。 VS Code Sublime text ==注意： 配合Emmet自动补全使用，效果更佳。== 1.2 浏览器的选择 推荐开发者常用的开发与测试浏览器。 Chrome Firefox 1.3 HTML实例 什么是HTML？ HTML 指的是超文本标记语言: HyperText Markup Language 12345678910111213&lt;!DOCTYPE html&gt; &lt;!-- 声明这是一个html文档 --&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这里是一个文章标题&lt;/h1&gt; &lt;p&gt;这里是一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解析 &lt;!DOCTYPE html&gt; 声明为 HTML5 文档 &lt;html&gt; 是 HTML 页面的根元素 &lt;head&gt; 包含了文档的元（meta）数据，如 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为 utf-8。 &lt;title&gt; 描述了文档的标题 &lt;body&gt; 包含了可见的页面内容 &lt;h1&gt; 定义一个大标题 &lt;p&gt; 定义一个段落 二、HTML基础 2.1 标签（元素） 像&lt;body&gt;&lt;/body&gt;这些叫做标签，也称作元素。 123456&lt;body&gt; &lt;h1&gt;这里是一个文章标题&lt;/h1&gt; &lt;p&gt;这里是一个段落&lt;/p&gt;&lt;/body&gt; 2.2 属性 实例 HTML 链接由 &lt;a&gt; 标签定义。链接的地址在 href 属性中指定 1&lt;a href=\"https://akashi_sai.gitee.io/\"&gt;&lt;/a&gt; eg.1&lt;div id=\"idname\" class=\"classname\" name=\"value\"&gt;&lt;/div&gt; 2.3 常用标签2.3.1 div 块级元素，独占一行，用于组合其他HTML元素的容器。 123&lt;div&gt; &lt;div&gt;这里是一个容器&lt;/div&gt;&lt;/div&gt; 2.3.2 span 内联元素，从左到右排列，可用于文本的容器。 1&lt;span&gt;文本的容器&lt;/span&gt; 2.3.3 h1~h6 标题，&lt;h1&gt;定义最大标题，&lt;h6&gt;定义最小标题。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;h3&gt;Hello&lt;/h3&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;h5&gt;Hello&lt;/h5&gt; &lt;h6&gt;Hello&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 注释，以&lt;!--开始，以--&gt;结束。 12345&lt;body&gt; &lt;div&gt; &lt;!-- 这里是注释内容 --&gt; &lt;/div&gt;&lt;/body&gt; ==注意： 良好的注释习惯，可以提高代码的可读性。== 2.3.4 p 段落，可以将文档分割成若干段落。 12&lt;p&gt;这里是一个段落&lt;/p&gt;&lt;p&gt;这里是另一个段落&lt;/p&gt; 2.3.5 a 链接，可以用来设置超文本链接。 1&lt;a href=\"https://akashi_sai.gitee.io/\"&gt;&lt;/a&gt; 2.3.6 img 图像，src 指 &quot;source&quot;。源属性的值是图像的 URL 地址。 1&lt;img src=\"../logo.png\" alt=\"这是一张logo图片\"&gt; 2.3.7 列表 无序列表，ul &gt; li 1234 &lt;ul&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt;&lt;/ul&gt; 有序列表，ol &gt; li 1234 &lt;ol&gt; &lt;li&gt;first item&lt;/li&gt; &lt;li&gt;second item&lt;/li&gt;&lt;/ol&gt; 2.3.8 表格 table 表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;th&gt;表头1&lt;/th&gt; &lt;th&gt;表头2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第一行第一列&lt;/td&gt; &lt;td&gt;第一行第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二行第一列&lt;/td&gt; &lt;td&gt;第二行第二列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2.3.9 表单 form123456&lt;form action=\"#\"&gt; &lt;fieldset&gt; value: &lt;input type=\"text\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt; input 1&lt;input type=\"text\" placeholder=\"这里是一个输入框\"&gt; button 1&lt;button&gt;这是一个提交按钮&lt;/button&gt; textarea 123&lt;textarea rows=\"10\" cols=\"30\"&gt; 这里是一个文本框&lt;/textarea&gt; 2.3.10 头部 &lt;head&gt; &lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;. 123456&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;title&gt; 定义了不同文档的标题.1&lt;title&gt;Document&lt;/title&gt; &lt;link&gt; 定义了文档与外部资源之间的关系。通常用于链接到样式表. 123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt; &lt;style&gt; 定义了HTML文档的样式文件引用地址。123456&lt;head&gt; &lt;style type=\"text/css\"&gt; body &#123;background-color:yellow&#125; p &#123;color:blue&#125; &lt;/style&gt;&lt;/head&gt; &lt;meta&gt; 描述了一些基本的元数据。元数据也不显示在页面上，但会被浏览器解析。12345&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;&lt;/head&gt; fin","categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://akashigakki.github.io/categories/前端/HTML/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"入门教程","slug":"入门教程","permalink":"http://akashigakki.github.io/tags/入门教程/"},{"name":"HTML","slug":"HTML","permalink":"http://akashigakki.github.io/tags/HTML/"}]},{"title":"Hello Hexo","slug":"hello-world/hello-world","date":"2019-03-28T04:13:04.000Z","updated":"2020-10-06T11:15:40.739Z","comments":true,"path":"2019/03/28/hello-world/hello-world/","link":"","permalink":"http://akashigakki.github.io/2019/03/28/hello-world/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/categories/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/categories/Vue/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/categories/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/categories/Algorithm/"},{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/categories/Linux/"},{"name":"环境安装","slug":"Linux/环境安装","permalink":"http://akashigakki.github.io/categories/Linux/环境安装/"},{"name":"工具","slug":"Python/工具","permalink":"http://akashigakki.github.io/categories/Python/工具/"},{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/categories/Java/"},{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/categories/杂项/"},{"name":"云服务","slug":"杂项/云服务","permalink":"http://akashigakki.github.io/categories/杂项/云服务/"},{"name":"SSH","slug":"Linux/SSH","permalink":"http://akashigakki.github.io/categories/Linux/SSH/"},{"name":"SSR","slug":"Linux/SSR","permalink":"http://akashigakki.github.io/categories/Linux/SSR/"},{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/categories/数据库/"},{"name":"Redis","slug":"数据库/Redis","permalink":"http://akashigakki.github.io/categories/数据库/Redis/"},{"name":"Scrapy","slug":"Python/Scrapy","permalink":"http://akashigakki.github.io/categories/Python/Scrapy/"},{"name":"ftp","slug":"Linux/ftp","permalink":"http://akashigakki.github.io/categories/Linux/ftp/"},{"name":"Django","slug":"Python/Django","permalink":"http://akashigakki.github.io/categories/Python/Django/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"http://akashigakki.github.io/categories/数据库/MongoDB/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://akashigakki.github.io/categories/前端/HTML/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/"},{"name":"Charts","slug":"前端/JavaScript/Charts","permalink":"http://akashigakki.github.io/categories/前端/JavaScript/Charts/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://akashigakki.github.io/categories/前端/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://akashigakki.github.io/tags/前端/"},{"name":"Cesium","slug":"Cesium","permalink":"http://akashigakki.github.io/tags/Cesium/"},{"name":"Vue","slug":"Vue","permalink":"http://akashigakki.github.io/tags/Vue/"},{"name":"Python","slug":"Python","permalink":"http://akashigakki.github.io/tags/Python/"},{"name":"Nginx","slug":"Nginx","permalink":"http://akashigakki.github.io/tags/Nginx/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://akashigakki.github.io/tags/Algorithm/"},{"name":"Linux","slug":"Linux","permalink":"http://akashigakki.github.io/tags/Linux/"},{"name":"环境安装","slug":"环境安装","permalink":"http://akashigakki.github.io/tags/环境安装/"},{"name":"工具","slug":"工具","permalink":"http://akashigakki.github.io/tags/工具/"},{"name":"Java","slug":"Java","permalink":"http://akashigakki.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"http://akashigakki.github.io/tags/面向对象/"},{"name":"算法","slug":"算法","permalink":"http://akashigakki.github.io/tags/算法/"},{"name":"基础","slug":"基础","permalink":"http://akashigakki.github.io/tags/基础/"},{"name":"杂项","slug":"杂项","permalink":"http://akashigakki.github.io/tags/杂项/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"http://akashigakki.github.io/tags/虚拟环境/"},{"name":"图床","slug":"图床","permalink":"http://akashigakki.github.io/tags/图床/"},{"name":"云服务","slug":"云服务","permalink":"http://akashigakki.github.io/tags/云服务/"},{"name":"Google Cloud","slug":"Google-Cloud","permalink":"http://akashigakki.github.io/tags/Google-Cloud/"},{"name":"SSH","slug":"SSH","permalink":"http://akashigakki.github.io/tags/SSH/"},{"name":"SSR","slug":"SSR","permalink":"http://akashigakki.github.io/tags/SSR/"},{"name":"数据库","slug":"数据库","permalink":"http://akashigakki.github.io/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"http://akashigakki.github.io/tags/Redis/"},{"name":"Scrapy","slug":"Scrapy","permalink":"http://akashigakki.github.io/tags/Scrapy/"},{"name":"Spider","slug":"Spider","permalink":"http://akashigakki.github.io/tags/Spider/"},{"name":"爬虫","slug":"爬虫","permalink":"http://akashigakki.github.io/tags/爬虫/"},{"name":"ftp","slug":"ftp","permalink":"http://akashigakki.github.io/tags/ftp/"},{"name":"远程连接","slug":"远程连接","permalink":"http://akashigakki.github.io/tags/远程连接/"},{"name":"Django","slug":"Django","permalink":"http://akashigakki.github.io/tags/Django/"},{"name":"项目部署","slug":"项目部署","permalink":"http://akashigakki.github.io/tags/项目部署/"},{"name":"前端框架","slug":"前端框架","permalink":"http://akashigakki.github.io/tags/前端框架/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://akashigakki.github.io/tags/MongoDB/"},{"name":"可视化工具","slug":"可视化工具","permalink":"http://akashigakki.github.io/tags/可视化工具/"},{"name":"env","slug":"env","permalink":"http://akashigakki.github.io/tags/env/"},{"name":"终端","slug":"终端","permalink":"http://akashigakki.github.io/tags/终端/"},{"name":"美化","slug":"美化","permalink":"http://akashigakki.github.io/tags/美化/"},{"name":"包管理工具","slug":"包管理工具","permalink":"http://akashigakki.github.io/tags/包管理工具/"},{"name":"Homebrew","slug":"Homebrew","permalink":"http://akashigakki.github.io/tags/Homebrew/"},{"name":"MySQL","slug":"MySQL","permalink":"http://akashigakki.github.io/tags/MySQL/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://akashigakki.github.io/tags/正则匹配/"},{"name":"开发技巧","slug":"开发技巧","permalink":"http://akashigakki.github.io/tags/开发技巧/"},{"name":"H5","slug":"H5","permalink":"http://akashigakki.github.io/tags/H5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://akashigakki.github.io/tags/JavaScript/"},{"name":"charts","slug":"charts","permalink":"http://akashigakki.github.io/tags/charts/"},{"name":"python","slug":"python","permalink":"http://akashigakki.github.io/tags/python/"},{"name":"入门教程","slug":"入门教程","permalink":"http://akashigakki.github.io/tags/入门教程/"},{"name":"教程","slug":"教程","permalink":"http://akashigakki.github.io/tags/教程/"},{"name":"破解","slug":"破解","permalink":"http://akashigakki.github.io/tags/破解/"},{"name":"CSS","slug":"CSS","permalink":"http://akashigakki.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://akashigakki.github.io/tags/HTML/"}]}